<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <title>PA_record.log | Alternative Sky</title>
    <meta name="description" content="\.">
    <meta name="keywords" content>
    <meta name="HandheldFriendly" content="True">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="shortcut icon" href="https://p.sda1.dev/1/31a2170cd16f0fb7ab2e50b2e39bf9a1/avatar.jpg"> <link rel="alternate" href="/atom.xml" title="Alternative Sky">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="从指令集实现到操作系统nju-ics-pa 工程记录  那就让我来认真对待这个质量高的夸张的PA。NJU牛逼！ 我就是精神南大人（不）">
<meta property="og:type" content="article">
<meta property="og:title" content="PA_record.log">
<meta property="og:url" content="http://kr2.moe/2021/04/10/PA-record-log/index.html">
<meta property="og:site_name" content="Alternative Sky">
<meta property="og:description" content="从指令集实现到操作系统nju-ics-pa 工程记录  那就让我来认真对待这个质量高的夸张的PA。NJU牛逼！ 我就是精神南大人（不）">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://p.sda1.dev/1/20be5ddb765834950e53e28e62904124/image.png">
<meta property="og:image" content="https://p.sda1.dev/1/544e01f72a3251751867da0461d29ebb/image.png">
<meta property="og:updated_time" content="2021-08-16T09:30:57.908Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PA_record.log">
<meta name="twitter:description" content="从指令集实现到操作系统nju-ics-pa 工程记录  那就让我来认真对待这个质量高的夸张的PA。NJU牛逼！ 我就是精神南大人（不）">
<meta name="twitter:image" content="https://p.sda1.dev/1/20be5ddb765834950e53e28e62904124/image.png">

    <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
    <link href="//cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/style.css"> 

    <script>
      function setLoadingBarProgress(num) {
        document.getElementById("loading-bar").style.width = num + "%";
      }
    </script>

    <script>
      window.MathJax = {
        // mathjax config
        loader: { load: ["[tex]/ams"] },
        tex: {
          packages: { "[+]": ["ams"] },
          inlineMath: [["$", "$"]],
          displayMath: [["$$", "$$"]],
          processEscapes: true,
          digits: /^(?:[0-9]+(?:\{,\}[0-9]{3})*(?:\.[0-9]*)?|\.[0-9]+)/,
          maxBuffer: 5 * 1024,
        },
        options: {
          skipHtmlTags: [
            "script",
            "noscript",
            "style",
            "textarea",
            "pre",
            "code",
            "annotation",
            "annotation-xml",
          ],
          includeHtmlTags: {
            br: "\n",
            wbr: "",
            "#comment": "",
          },
          compileError: function (doc, math, err) {
            doc.compileError(math, err);
          },
          typesetError: function (doc, math, err) {
            doc.typesetError(math, err);
          },
        },
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.2.0/build/styles/atom-one-dark.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.2.0/build/highlight.min.js"></script>

    <script>
      hljs.configure({
        tabReplace: "    ",
      });

      document.addEventListener("DOMContentLoaded", (event) => {
        document.querySelectorAll("pre code").forEach((el) => {
          hljs.highlightElement(el);
        });
      });
    </script>

    <script src="//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script>
  <link rel="alternate" href="/atom.xml" title="Alternative Sky" type="application/atom+xml">
</head>
</html>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class="wrapper container">
		<a class="logo flat-box" href='/'>
			Alternative Sky
		</a>
		<div class='menu'>
			<ul class='h-list'>
				
				<li>
					<a class='flat-box nav-home' href='/'>
						Home
					</a>
				</li>
				
				<li>
					<a class='flat-box nav-archives' href='/archives'>
						Archives
					</a>
				</li>
				
				<li>
					<a class='flat-box nav-about' href='/about'>
						About
					</a>
				</li>
				
			</ul>
			<div class='underline'></div>
		</div>
		
		<div class="m_search">
			<form name="searchform" class="form u-search-form">
				<input type="text" class="input u-search-input" placeholder="Search" />
				<span class="icon icon-search"></span>
			</form>
		</div>
		
		<ul class='switcher h-list'>
			
			<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search"></span></a></li>
			
			<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu"></span></a></li>
		</ul>
	</div>
	<aside class="menu-phone">
		<nav>
			
			<a href="/" class="nav-home nav">
				Home
			</a>
			
			<a href="/archives" class="nav-archives nav">
				Archives
			</a>
			
			<a href="/about" class="nav-about nav">
				About
			</a>
			
		</nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container'>
      <div class='l_main'>
        <article id="post-PA-record-log" class="post white-box article-type-post" itemscope
	itemprop="blogPost">
	<section class='meta'>
		<h2 class="title">
			<a href="/2021/04/10/PA-record-log/">
				PA_record.log
			</a>
		</h2>

		

		

		<time>
			4月 10, 2021
		</time>

		<span class="vertical-line" style="color: #b5b5b5; margin: 0px 5px 0px 5px;">|</span>

		<span id="/2021/04/10/PA-record-log/" class="leancloud_visitors" data-flag-title="文章阅读量统计">
			<em class="post-meta-item-text"> 阅读量 </em>
			<i class="leancloud-visitors-count">0</i>
		</span>

		<span class="vertical-line" style="color: #b5b5b5; margin: 0px 5px 0px 5px;">|</span>

		<span class="words-count">
			总字数 7.1k
		</span>

		<span class="vertical-line" style="color: #b5b5b5; margin: 0px 5px 0px 5px;">|</span>

		<span class="time-count">
			期望阅读时间 26 min
		</span>
	</section>
	
	<section class="tog"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PA1"><span class="toc-number">1.</span> <span class="toc-text">PA1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA2"><span class="toc-number">2.</span> <span class="toc-text">PA2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA3"><span class="toc-number">3.</span> <span class="toc-text">PA3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA4"><span class="toc-number">4.</span> <span class="toc-text">PA4</span></a></li></ol></section>
	
	<section class="article typo">
		<div class="article-entry" itemprop="articleBody">
			<blockquote>
<p>从指令集实现到操作系统<br>nju-ics-pa 工程记录</p>
</blockquote>
<p>那就让我来认真对待这个质量高的夸张的PA。NJU牛逼！</p>
<p>我就是精神南大人（不）</p>
<a id="more"></a>

<h2 id="PA1"><a href="#PA1" class="headerlink" title="PA1"></a>PA1</h2><p>调用顺序：</p>
<p><code>main.c</code> 调用 <code>init_monitor()</code></p>
<ul>
<li><p><code>parse-args</code> 中的 <code>getopt_long</code> 函数的文档查看通过 <code>man 3 getopt</code> 进行。这个在 Arch 下有坑。（会显示 locale 未定义）只需要 RTFM(archwiki) 安装 <code>man-pages</code> 等两个包即可。而 <code>man</code> 后的第一个参数：</p>
<ul>
<li>1: Executable programs</li>
<li>2: System calls3: Library calls</li>
</ul>
</li>
</ul>
<p>最常见的就是这三个了。我们要查看 <code>getopt.h</code> 中的，选择第三个。找到 <code>getopt_long()</code> 的定义与使用方法。初始化 <code>struct option</code> 后… 详细的就不说了，下次用到的时候再看文档（x</p>
<ul>
<li><p><code>init_log</code> 中也无什么可以说的。包括 <code>init_mem()</code>。 </p>
</li>
<li><p>接下来是一个比较关键的 <code>init_isa()</code>。 <code>init_isa</code> 中（我选择 riscv32 来学习）。</p>
<p><code>init_isa</code> 函数中会将 <code>image</code> 复制到 <code>IMAGE_START</code> 中（为 <code>pmem</code> 所代表的地址，由 <code>guest_to_host</code> 函数进行映射，而 <code>guest_to_host</code> 函数的意思为</p>
<pre><code>/* convert the guest physical address in the guest program to host virtual address in NEMU */</code></pre></li>
</ul>
<p>NEMU 的执行会在$n$次循环后结束，而这个$n$由 <code>~0 (-1)</code> 得到。还算比较简单吧。</p>
<ul>
<li><p>踩了个坑，使用 uint 的时候，不能拿来判长度。不信你试试看，绝对挂。</p>
</li>
<li><p>在 +4 那里又挂了一次。一个 word 是两个字节 xxx</p>
</li>
<li><p><code>inline</code> 那个是咋回事？应该是定义函数的时候并不需要加上更多的qulifier？我也记不清了。</p>
</li>
</ul>
<p>需要注意的是，在编写获取寄存器内容的时候，需要特别处理 <code>pc</code>，因为 <code>pc</code> 并未出现在 <code>regsl</code> 中。</p>
<p>PA1 写完了，来个总结。（至于必答题… 我就偷懒惹</p>
<p>各类 <code>#include&lt;&gt;</code> 的写法， 我果然还得再努力学习一下。写完代码不能什么都不学到，至少得学到点工程的知识对吧，那就是 Think twice, code once，同一个道理。</p>
<blockquote>
<p>补充。实际上我的 debugger 有不少的 bug，但是鉴于此项目整体比较简单，而且启动 debugger 比较麻烦，我后来也没怎么用过这个 debugger。这部分的基础设施我就懒得再 fix bugs 了。</p>
</blockquote>
<h2 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h2><blockquote>
<p>一条指令在 NEMU 中的一生</p>
</blockquote>
<p>程序运行顺序：</p>
<p>在 <code>main.c</code> 开始运行后进入 <code>init_monitor</code>，其中 <code>load_img</code> 会加载其 <code>~.bin</code> 。</p>
<p>接下来在 <code>engine_start</code> 中，<code>ui_mainloop</code> 会识别其为 <code>batchmode</code> 并且进行 <code>cmd_c</code>进入 <code>cpu_exec</code>。该指令的一生从这里开始。</p>
<p>说错了点，其实是从循环里的 <code>isa_exec_once()</code> 开始，其在 <code>nemu/isa/riscv32/exec/exec.c</code> 中定义。</p>
<p>首先来看这个 <code>DecodeExecState</code>，在 <code>decode.h</code> 中定义，</p>
<pre><code class="c">typedef struct {
  uint32_t opcode;
  vaddr_t seq_pc;  // sequential pc
  uint32_t is_jmp;
  vaddr_t jmp_pc;
  Operand src1, dest, src2;
  int width;
  rtlreg_t tmp_reg[4];
  ISADecodeInfo isa;
} DecodeExecState;</code></pre>
<p>注意其中的几个关键点。我们按照<code>isa_exec_once()</code> 中的顺序介绍。首先默认不是 <code>jmp</code> 的类型（所以关于 <code>pc</code> 的操作可以暂时忽略）。并将 <code>seq_pc</code> 置为 <code>cpu.pc</code>（之后再管这部分）</p>
<p>其中的 ISADecodeInfo 是跟着 ISA 的，<code>isa.h</code> 中进行了宏定义将具体的 ISA 定义为了该 ISADecodeInfo。我们的 <code>riscv32_ISADecodeInfo</code> 大致内容如下</p>
<pre><code class="c">typedef struct {
  union {
    struct {
      uint32_t opcode1_0 : 2;
      ...
    } i;
    struct {
      uint32_t opcode1_0 : 2;
      ...
    } s;
    struct {
      uint32_t opcode1_0 : 2;
      ...
    } u;
     ...
    uint32_t val;
  } instr;
} riscv32_ISADecodeInfo;</code></pre>
<p>定义了 opcode 的几种形态，至于这几种形态的具体内容，refer to <code>riscv-spec.pdf</code> 的 page 16。后面带了一个 <code>val</code>，用来存储指令原有的样子。那个加冒号的写法实际上是位段的处理，保证 i/s/u 的二进制位和和标准的 instruction format 对应吧。这里非标准使用 <code>union</code> 的骚操作保证 <code>val</code> 里的每一位都直接被赋值…实在精彩。如果需要自己写这段，大小端的问题需要注意，算了今天就不处理了。</p>
<p>于是，这条指令进入了 <code>fetch_decode_exec()</code> 函数中。这个函数将带领这个指针走完其一生。</p>
<p>我们实现的CPU执行一条指令有四个步骤，IF | ID | EX | PC。</p>
<p>IF 比较简单，阅读 <code>instr_fetch</code> 可以发现，只是一次访问 <code>vaddr</code> 的询问，取其地址内容即可。</p>
<hr>
<p>开始 ID 并保证 <code>opcode1_0 == 0x3</code> 。（至于为什么，看文档去）</p>
<p>接下来是对 <code>opcode6_2</code> 进行 <code>switch</code>。其中 <code>IDEX</code> 是一份宏定义，在 <code>exec.h</code> 中。共进行了三步。确定 instruction 的宽度，通过宏定义 decode 到具体函数，通过宏定义执行具体函数。嘛，由于 switch 是使用跳表，所以会快一些。</p>
<p>我们在 switch 中使用的都是 IDEX，即默认将 width 置为 0。</p>
<blockquote>
<p>mips32和riscv32的访存指令会有不同操作数宽度的版本, 包括32位, 16位和8位, 因此我们还需要把宽度信息记录到<code>s</code>中提供后续过程使用.</p>
</blockquote>
<p>然后，设置完宽度后，我们花大篇幅来修改一下译码(ID)操作。给宏提供的参数为具体的 <code>I/S/U</code>，及会被解析为 <code>decode_load_I</code> 函数。依次类推。</p>
<p>然后是操作数(Operand)的控制，这要求我们进行进一步 Decode，由 Decode Helper Function 完成。 DHF 的宏定义在 <code>include/cpu/decode.h</code> ，而 Decode Operand Helper Function 的宏定义在 <code>local_include/decode.h</code> 中，目前只有两种操作，即 <code>decode_op_i</code> 和 <code>decode_op_r</code>，对应立即数和寄存器。在被宏定义的 <code>decode_op_r</code> 中，有一个 <code>op-&gt;preg</code>，是一个指向对应寄存器的指针。这样做避免了每次都访问 <code>reg_l(val)</code>。</p>
<p>被 DHF 定义的一系列函数基本都是重复的工程操作，查 specification 即可。照着这个类型，再多实现些指令类型也可。</p>
<hr>
<p>译码部分就这样，我们可爱的指令终于可以开始执行了。</p>
<p>执行部分的函数定义由 <code>def_EHelper</code> 进行。</p>
<p>需要执行的指令可能有多种情况，即 <code>isa.{}.funct3</code>  就可以区分不同指令，与 <code>funct3/funct7</code> 同时需要以区分指令。但是 <code>EX</code> 系列的宏并不允许我们在指令中进行 <code>switch</code>（你明明就可以不用它！），但是为了与 <code>load</code>, <code>store</code> 代码的整体性，我还是选择用 <code>EX</code> 宏 + 新添加一个函数来处理。</p>
<p>在操作寄存器的过程中，我们使用 <code>rtl</code>与<code>rtl pseudo</code>。<code>rtl pseudo</code> 存在的意义是方便我们使用 <code>rtl</code>。</p>
<p>总而言之，经过了大半周摸摸搞搞的修改（这部分没有写 <code>pa-record</code>），终于实现了 <code>RV32I</code> 和 <code>RV32M</code> 系列的指令，实现了部分 <code>klib</code> 后，离项目的完成又尽了一步（躺）</p>
<hr>
<p>接下来就是 I/O 的部分了，即设备的输入输出。</p>
<p>设备的输入输出有集中常见方式。端口 I/O 和内存映射 I/O。</p>
<p>前者的对寄存器操作设备的方案依赖于 <code>in/out</code> 指令。这两个指令能够负责向某个端口的寄存器写入某些值，设备读取这些值并且进行对应操作。</p>
<p>MMIO 则更加先进，在物理内存空间上分配一段空间给设备，然后 CPU 在操作某段内存的时候，不知不觉就操作了对应的设备。</p>
<hr>
<p><code>mainargs</code> 传入的过程：在 <code>nemu.mk</code> 的 line 19</p>
<pre><code class="c">CFLAGS += -DMAINARGS=\&quot;$(mainargs)\&quot;</code></pre>
<p>在编译时这个会被传入到 <code>mainargs[]</code> 变量中，再在 <code>_trm_inirt()</code> 中被传入到 <code>main</code> 函数中去。神秘。</p>
<hr>
<p>接下来让我尝试理清楚 NEMU 和 AM 在软硬件上配合的关系。</p>
<p>首先从硬件层的 NEMU 说起吧。NEMU 在每条指令运行的时候都会尝试观测 <code>device_update_flag</code> 的情况。如果为 <code>true</code>，则会在指令执行结束之后运行 <code>device.c</code> 中的 <code>device_update</code> 函数，这个函数目前（主要）负责：</p>
<ol>
<li>进行 <code>vga_update</code>，将会调用 <code>vga.c</code> 中的 <code>vga_update_screen</code> 函数，该函数会观测寄存器 <code>sync</code> 的情况，如果其值为 <code>1</code> 则真正意义上进行同步。</li>
<li>进行 <code>key_down</code> 的观测，这个是基于 SDL 的 API，就不深究了。</li>
</ol>
<p>既然现在要写显卡，我们来看一看 VGA 的部分。<code>update_screen</code> 函数会操作 SDL 读取 <code>vmem</code> 中的内容显示图像，我们姑且不管这一部分，回到软件层面来看一看。</p>
<p>既然 AM 是 NEMU 的抽象，我们就不能简单从“这俩会通信”来入手。</p>
<p>最基础的最基础的问题是，NEMU 是编译在 x86-64 上的，而 AM 是跑在 riscv32 上的。而事实上，NEMU 当然能获取自己的寄存器（及内存）信息，AM 也能修改其寄存器（及内存）信息。所以这俩就建立了通信。我们的目的是让自己写的 C 能跑在 riscv32 上。 AM 给用户程序提供了几个常规的 API，比如说 <code>io_read</code> 和 <code>io_write</code>。这两个函数能操作 AM 让 AM  让 AM 修改寄存器信息。</p>
<hr>
<p>声卡，虽然会很砖，但是必须实现。仙剑奇侠传怎么能没声音呢？</p>
<pre><code class="c">/* * * * * * * * * * AUDIO PART * * * * * * * * * * *
 * AURIO_CTRL   : Audio control, to change freq/channel/samples
 * AUDIO_STATUS : Used buffer size
 * AUDIO_PLAY   : Write [buf.start, buf.end) to buffer, wait until there&#39;s space
 * */
AM_DEVREG(14, AUDIO_CONFIG, RD, bool present; int bufsize);
AM_DEVREG(15, AUDIO_CTRL,   WR, int freq, channels, samples);
AM_DEVREG(16, AUDIO_STATUS, RD, int count);
AM_DEVREG(17, AUDIO_PLAY,   WR, Area buf);
// * * * * * * * * * AUDIO PART * * * * * * * * * * *</code></pre>
<p>首先我们来分析一下 <code>am-tests</code> 中的 <code>audio.c</code>。这是一段播放小星星的代码。</p>
<p><code>audio.c</code> 最开始是检测 <code>AM_AUDIO_CONFIG</code> 的 <code>present</code> 是否为 <code>true</code>，当然，我们需要将其设为 <code>true</code>。</p>
<p>接下来是初始化 <code>freq</code> 等基本信息，略过。</p>
<p><code>AUDIO_PLAY</code> 需要一段 <code>Area</code>，用于存即将写入 <code>buffer</code> 的内容…</p>
<p>我靠，从昨天晚上写到刚才，终于能跑了，来检讨一下笨死了的自己。</p>
<p>我实现的是一个由 AM 上的 <code>push</code> 和 nemu 里的 <code>pop</code> 维护的一个 queue，这个 queue 装在对应内存里。内存的前 8 个字节用于装 <code>head</code> 和 <code>end</code>，是队列所对应的循环数组的首尾。</p>
<p>由程序调用 <code>AM</code> 中的 <code>__am_audio_play</code>，其会等待直到 <code>buffer</code> 中有空余空间后进行写入。这里其实有不少问题，是依赖于主机的 context switch 的，所以我采用一种比较保守的实现，但是实际上好像… 额，性能比较弱。即在 <code>push</code> 和 <code>pop</code> 函数内部对 queue 的 size 通过 MMIO 进行维护。 之后可以在这里多想想，然后尝试实现一些以一个 <code>segment</code> 为单位的队列？性能应该会高不少。</p>
<p>SDL 的回调函数每次会取 2048 个元素（有可能），性能还算不错。但是 <code>push</code> 那边的话因为需要等待空间，性能就比较弱。</p>
<p>不过第一次写是为了正确实现，抽象的比较高。现在的实现应该是没有问题的，如果仙剑那边跑的实在太卡的话我就用 <code>mem</code> 系列指令重写一下。（虽然 <code>mem</code> 系列我也没优化就是了，肯定要优化一下的，比如给 mem 系列实现一个硬件层的接口让宿主来进行 memset ？？？x）</p>
<p>之后有心情的话可以去读一下 LiteNES 的代码，这次就算了。居然还能学优化x 之后再说。</p>
<hr>
<h2 id="PA3"><a href="#PA3" class="headerlink" title="PA3"></a>PA3</h2><p>PA3 这部分比较难懂，有一些 <code>undoc feature</code>。</p>
<p>我们来做那个必答题，<code>yield()</code> 调用之后发生了什么。</p>
<p>进入了 <code>yield</code> 函数，将 <code>a7</code> 作为参数（即 <code>sstatus</code>）传给了 <code>ecall</code>，<code>ecall</code> 执行对应操作，并调用 <code>raise_instr</code> 执行了设置 <code>sepc</code> 和设置 <code>scause</code> 等操作。需要注意，在 <code>cte_init</code> 中，我们将 <code>__am_asm_trap</code> 的<strong>函数指针</strong>传入了 <code>stvec</code>，所以其会 <code>jmp</code> 到 <code>__am_asm_trap</code> 里。<code>__am_asm_trap</code> 的操作相对比较迷惑，大概意思就是在栈里初始化了 <code>Context*</code>，于是在接下来的函数就能访问之前的内容。大概是，这样吧。我是有点没读懂的。</p>
<hr>
<p>我一直不太熟悉 ELF 的格式，今天再来 review 一下。</p>
<blockquote>
<p> ELF 有面向链接的 section 视角，提供了可重定位信息。第二个是面向执行的 segment 视角，这个视角提供了加载可执行文件的信息。 通过 <code>readelf</code> 我们能看到 <code>section</code> 和 <code>segment</code> 的映射关系。</p>
<p> ELF 采用 <code>program header table</code> 来管理 <code>segment</code>。通过 <code>ehdr</code> 来管理 <code>section</code>。其中 <code>ehdr</code> 包含了所有 <code>segment</code> 放置的位置（通过一个数组）</p>
<p> 所以我们的 <code>loader</code> 需要负责加载所有的 <code>segment</code>。</p>
</blockquote>
<p>ELF 还有很多我不太熟悉的操作，还是以后遇到问题 <code>man 5 elf</code> 吧。（上面的东西是前几天写的了，懒得补充了）</p>
<hr>
<p>今天我们再来梳理一下从 <code>hello.c</code> 到最后程序运行的过程。</p>
<p><code>hello.c</code> 由其 Makefile 管理。这里再让我吐槽一下 CLion 的逻辑，Makefile 在 CLion 里完全不可用（躺）。我也不想一点一点做移植，就这样将就了。</p>
<p>然后我们将 <code>hello.c</code> <code>mv</code> 到 <code>ramdisk.img</code>，其为一个已经并未链接的 elf。它会在 nanos-lite 链接的时候由 <code>resource.S</code> 链接到其 <code>.data</code> 段中。（？？？感觉这操作好神秘）</p>
<pre><code class="asm">.section .data
.global ramdisk_start, ramdisk_end
ramdisk_start:
.incbin &quot;build/ramdisk.img&quot;
ramdisk_end:
// ...</code></pre>
<p>关于上述步骤，用 <code>readelf</code> 查看 nanos-lite 的编译结果可以看到，<code>.symtab</code> 里有 <code>ramdisk_start</code> 和 <code>ramdisk_end</code> 的痕迹。<code>ramdisk</code> 的一系列 API 能够让读取该段内存的内容。而我们的 <code>loader()</code> 则负责将该段内存读取到其应该存在的地方。（即其自身 ELF header 设置的 entry 及其之后的内容）</p>
<p>既然 <code>loader</code> 返回了 <code>entry</code>，<code>naive_uload</code> 将 <code>pc</code> 切换到 <code>loader</code> 的 <code>entry</code>，即开始运行 <code>ramdisk</code> 的内容了。</p>
<p>关于 <code>ecall</code> 的部分我再给自己哆嗦两句。<code>ecall</code> 的类型参数存放在 <code>a7</code> 中，我们规定 <code>a7  = [0..20)</code> 是系统调用。其编号的具体内容在 navy_apps 的 <code>syscall.h</code> 中存放着。<code>syscall.c</code> 中实现了一些系统调用（说来我咋觉得这些东西该放在 nanos-lite 中呢，不过放在 navy-apps 中也有一定道理倒是x）</p>
<hr>
<p>终于写完虚拟文件系统了… 写了一周多。这套文件系统里有不少的坑，我们慢慢道来。</p>
<p>虚拟文件系统又是一层抽象（尽管会略微降低性能？），我们实现了一份比较简单的文件系统，支持基础的读写操作。虚拟文件系统实现的核心是，为特殊文件实现特殊的读写函数，而这个读写函数不一定是针对储存空间操作的，可能是针对某一些特殊的数据流操作的。当然，通用的读写函数也是必须被实现的，这些读写函数将操作真正的一块处于硬盘（？）中的一块被抽象的，称作文件的空间。关于文件的格式已经研究过了，在这里就不再赘述。</p>
<p>我们在此处只需考虑那些特殊的，“被抽象”出来的文件。比如：</p>
<pre><code class="c"> typedef struct {
  char *name;
  size_t size;
  size_t disk_offset;
  ReadFn read;
  WriteFn write;
} Finfo;

// ...
{&quot;/dev/events&quot;, 0, 0, events_read, invalid_write},
{&quot;/proc/dispinfo&quot;, 0, 0, dispinfo_read, invalid_write},
{&quot;/dev/fb&quot;, 0, 0, invalid_read, fb_write},</code></pre>
<p>这三者是被抽象出的文件，抽象出的文件的核心在于那个 <code>ReadFn</code> 函数，这个函数是可以被自行定义的，比如 <code>dispinfo_read</code> 就会调用 AM 中实现的一系列接口，返回一段字符。这段字符并没有放在硬盘上。</p>
<p>在对文件读写时，首先尝试调用 <code>ReadFn</code> 以及 <code>WriteFn</code>，若失败，才会跌落至常规的对文件的读写。</p>
<p>在此基础上实现了 <code>device.c</code> 中的一系列函数，包括：</p>
<ul>
<li><code>serial_write</code>: 串口输入输出，抽象为 <code>stdout</code>/<code>stderr</code></li>
<li><code>events_read</code>: 从 <code>AM_INPUT_KEYBRD</code> 获取键盘输入信息，抽象为 <code>/dev/events</code></li>
<li><code>dispinfo_read</code>: 已经提到了</li>
<li><code>fb_write</code>: 是显存的抽象，实现不太友好（还有不少瑕疵），不想提了。</li>
</ul>
<p>总而言之，经过了一段时间，已经解决了这部分的内容，该进入 PA3 的最后一部分啦！</p>
<hr>
<blockquote>
<p>Fixed-point arithmetic</p>
</blockquote>
<p>神秘的，可以避开 FPU 实现的方法。</p>
<p>定点算数实现的核心是避开 IEEE 标准，自己实现一套更加简便的，和当前 ALU 同构的规范。浮点数和定点数的运算本身没有过大的区别，都是数字和数字的碰撞，IEEE 标准徒增功耗（不）</p>
<p>于是我们定义一套新的标准，对于一个实数 $a$，我们将其表示为 $A = a \cdot 2^8$，在内存中存储为</p>
<pre><code>31  30                           8          0
+----+---------------------------+----------+
|sign|          integer          | fraction |
+----+---------------------------+----------+</code></pre><blockquote>
<p>（书里的图，我就嫖来了）</p>
</blockquote>
<p>鉴于小数的最低位是在 $2^{-8}$，我们乘上 $2^8$ 之后可以建立一套双射。</p>
<p>回答这个问题：</p>
<blockquote>
<p>阅读<code>fixedpt_rconst()</code>的代码, 从表面上看, 它带有非常明显的浮点操作, 但从编译结果来看却没有任何浮点指令. 你知道其中的原因吗?</p>
</blockquote>
<p>确实啊（沉思），先总结一下，<code>fixedpt</code> 让编译器来负责大部分的浮点处理。</p>
<p>我们用 <a href="https://godbolt.org/" target="_blank" rel="noopener">godbolt</a> 来测试一下，<code>int a = (int)1.333;</code>，得出的指令并没有浮点运算。<code>fixedpt_rconst</code> 也同理</p>
<pre><code class="c">#define fixedpt_rconst(R) ((fixedpt)((R) * FIXEDPT_ONE + ((R) &gt;= 0 ? 0.5 : -0.5)))
#define FIXEDPT_ONE    ((fixedpt)((fixedpt)1 &lt;&lt; FIXEDPT_FBITS))</code></pre>
<p><code>FIXEDPT_ONE</code> 则是之前提到的 $2^8$，这部分预处理会在编译器完成。而例如，$-1.2$，会出现 $-1.2 \cdot 2^8 - 0.5 \rightarrow -307.7 \rightarrow -307$ 的情况，这个 $\pm0.5$ 估计是拿来修正整数值的吧。晕乎乎，不管了。</p>
<hr>
<p>稍微深挖一下 <code>switch_boot_pcb()</code> 的作用，切换到 boot pcb 有什么好处啊？</p>
<pre><code class="cpp">void switch_boot_pcb() {
  current = &amp;pcb_boot;
}</code></pre>
<p>就干了这么简单一件事，再看我们目前的 <code>schedule</code> “算法”</p>
<pre><code class="cpp">Context* schedule(Context *prev) {
  current-&gt;cp = prev;
  current = (current == &amp;pcb[0] ? &amp;pcb[1] : &amp;pcb[0]);
  return current-&gt;cp;
}</code></pre>
<p>这个问题我思考了好一会儿，还是得跳回 <code>main</code> 函数开始思考。一切的一切都是从 <code>main</code> 函数里调用那次 <code>yield()</code>，开始，走过我画的图中的那些部分，一直走到需要 <code>schedule</code> 的部分。</p>
<hr>
<p>解决了，没啥用，大概是 PA 没有描述到的地方，关于回到 <code>pcb_boot</code> 之后该如何调度，这个问题先不管它了… 等遇到复杂的调度问题再说。</p>
<hr>
<blockquote>
<p>不过, 这片空闲的内存位置是操作系统的加载器在加载时刻指定的, 但进程代码真的可以在这一内存位置上正确运行吗?</p>
</blockquote>
<p>对对对，我也想问这个问题（不是）</p>
<p>以前的方法是使用绝对代码，但是这种方法比较笨，程序会维护多个不同加载地址的版本，并且祈祷其中一份能被加载成功。</p>
<p>一旦存在抽象，就可以通过同构映射出各种奇奇怪怪的东西，比如说 cache，一切可以写入可以读出的东西。但是，对于进程的管理理论上来说，需要操作系统的协助。所以说虚拟内存是一个软硬协同的过程。通过 CPU 内部的 Memory Management Unit。</p>
<blockquote>
<p>所谓虚拟内存, 就是在真正的内存(也叫物理内存)之上的一层专门给进程使用的抽象.</p>
</blockquote>
<p>然后讨论了一下分段机制的问题，因为分段实在太过混乱，所以我们需要分页。分页机制能够让我们以更低的成本重载代码，之类的。</p>
<p>分页中的虚拟地址，有如下的表示：</p>
<p><img src="https://p.sda1.dev/1/20be5ddb765834950e53e28e62904124/image.png" alt="image"></p>
<p>其中 <code>page offset</code> 为 12 位，刚好足以表示 4kb, 而 V P N (virtual page number) 用于帮助页表进行索引，找到物理地址所属的 frame.</p>
<p>riscv32 采用二级页表的玩法，每一个进程维护一个页目录，页目录通过 <code>VPN[1]</code> 索引到页目录项，页目录项包含了页表的起始地址，我们通过页目录项找到页表。再在页表中通过 <code>VPN[0]</code> 找到对应页面的物理地址，通过 <code>page offset</code> 找到对应的物理地址。页表中保存的内容均为物理地址。 <a href="[https://xy-plus.gitbook.io/rcore-step-by-step/ye-biao-jian-jie](https://xy-plus.gitbook.io/rcore-step-by-step/ye-biao-jian-jie)">参考</a> 和 <code>riscv-privileged.pdf</code></p>
<blockquote>
<p>于是，对一个 null pointer 解引用的时候，实际上发生了页表的访问。至于具体，就是左侧所述的几个步骤。</p>
</blockquote>
<p>于是，页表可以抽象成这样的一个函数！对，是我最爱的抽象</p>
<p>$$<br>y = \mathrm{page}(x)<br>$$</p>
<hr>
<blockquote>
<p>抽象的生命力就在于：尽管人们往往不会注意到，但她能仅仅通过在一整个对象之间插入一层，就使逻辑变得简单了许多。抽象↔同构</p>
</blockquote>
<hr>
<p>这个所谓的 <code>page</code> 函数实际上可能会很复杂，</p>
<hr>
<p>因为 page table walk 的行为可能很频繁，而多次访问同一个地址的可能性也很高。每次 page table walk 的成本可能比较高，于是就有了TLB。TLB 缓存了一些之前的结果。</p>
<p>页表本身是针对进程为单位维护的，所以 TLB 也需要考虑进程的问题。x86 的方法比较暴力，直接在 CR3 更新的时候冲刷 TLB 的内容，保留 Global 位为 1 以避免系统调用的时候发生 TLB Miss.</p>
<p>Cache 的性能至关重要，因为访问之与访问内存的效率千差万别。</p>
<p>mips32 中，TLB 的填充由软件进行（天哪？）。</p>
<hr>
<p>读完了 VME 实现要求的部分… 真的好复杂…</p>
<p>总结起来，有这几点需要实现的</p>
<ul>
<li>由操作系统填入页表的映射，由 <code>map</code> 函数进行</li>
<li>由操作系统管理的具体的 page 分配 <code>pg_alloc()</code> 等函数</li>
<li>由 CPU 内 MMU 管理的具体的虚拟地址解析</li>
</ul>
<p>我觉得我先花点时间搞点研究，think twice, code once.</p>
<p>至于之前 PA 所说的是通用的，我们现在针对 Sv32 进行一些细致的学习。</p>
<p><a href="https://www.notion.so/Sv32-Page-Based-32-bit-Virtual-Memory-Systems-f5c3a66dcca14b7c8e374728d4d92762" target="_blank" rel="noopener">Sv32: Page-Based 32-bit Virtual-Memory Systems</a></p>
<h2 id="PA4"><a href="#PA4" class="headerlink" title="PA4"></a>PA4</h2><p>我们还是先开始 PA4 好了，毕竟 PA3 的后面部分有点砖。我简单修了一下批处理系统那套，应该能够基本运行了。不过我还是对分时多任务感兴趣一点，于是就先做 PA4 了。</p>
<p>PA4 难度不低，我们先解决基本的 Context Switch 的问题。分为几步比较神秘的。</p>
<p>首先把 <code>Context</code> 和 <code>PCB</code> 的定义扔在这里。</p>
<pre><code class="c">typedef union {
  uint8_t stack[STACK_SIZE] PG_ALIGN;
  struct {
    Context *cp;
    AddrSpace as;
    // we do not free memory, so use `max_brk&#39; to determine when to call _map()
    uintptr_t max_brk;
  };
} PCB;

struct Context {
  uintptr_t gpr[32];
  uintptr_t cause, status, epc;
  void *pdir;
};</code></pre>
<p>其定义比较清晰，<code>PCB</code> 的意思是进程控制块，用户保存内核栈和 <code>cp</code>，<code>Context pointer</code>，指向保存的用于 Context switch 的“虚假的上下文”。而这个虚假的上下文是虚假给 <code>trap.S</code> 看的，<code>trap.S</code> 会还原这个偷梁换柱的上下文中的信息，并且通过 <code>sret</code> 跳转到其 <code>epc</code> 的位置。偷梁换柱进行的位置是 <code>trap.S</code> 中的 <code>jal __am_irq_handle</code>，这个函数会产生返回值并且放在 <code>a0</code>。我们只需 <code>mv sp, a0</code> 即可漂漂亮亮地替换被还原的上下文。</p>
<p><code>init_irq</code> 的时候调用了 <code>cte_init</code>，<code>do_event</code> 被作为全局变量<code>user_handler</code> 放入到了 <code>cte.c</code> 中，这个函数指针今后会在 <code>__am_irq_handle</code> 调用，并且会返回 <code>c</code>，在 <code>trap.S</code> 中的 <code>a0</code> 寄存器被接收，先不谈这里。</p>
<p><code>kcontext</code> 会创建一个上下文，将其放在 <code>kstack</code> 的最底部。然后 <code>PCB</code> 的 <code>union</code> 会将 <code>cp</code> 指向 <code>context</code> 的顶部。<code>sret</code> 会将这玩意儿倒回 <code>Context</code> 设定的位置，开始 <code>Context</code> 部分的运行。</p>
<p>为了清晰地解释，画一张图。</p>
<p><img src="https://p.sda1.dev/1/544e01f72a3251751867da0461d29ebb/image.png" alt="image.png"></p>
<p>为了节约空间（懒）我没有画3一些细节的部分。</p>
<blockquote>
<p>[实在太久没有阶段性的成就感了，先把这玩意儿丢到博客里好了]</p>
</blockquote>
<hr>
<p>因为期中考试的原因，有很长一段时间没有写代码，这里回来总结一下。分页机制的实现是为了虚拟内存，这段实现比较复杂，请听我慢慢道来。</p>
<p>我们从零开始总结一下虚拟内存的支持机制。首先，在任意一次  <code>set_satp()</code> 函数运行前，CPU 均没有开启 VME（因为 <code>set_satp()</code> 函数将设置的值 xor 了 <code>0x80000000</code>，即将最高位设置为 1，开启 VME）.</p>
<p>在 qemu 初始化过程中，直到运行到 <code>vme_init</code> 之前，都不会处理 VM. 比较有意思的是，在 VME 开启后，nemu 中的 <code>isa_vaddr_check</code> 函数会返回 <code>MEM_RET_NEED_TRANSLATE</code>，即这次内存访问是依赖于 page table walk 的。<code>isa_mmu_translate</code> 会进行 page table walk（它会获取 <code>satp</code> 中 <code>ppn</code> 的值作为 root）。</p>
<p>现在我们看回 nanos-lite 的部分，nanos-lite 中实现了 <code>map</code> 函数，用于初始化页表。具体实现就不讲了，这里稍微强调一下，任意一个内存地址，都是由一级/二级页表的访问下标和 offset 组成。<code>vaddr</code> 就是 <code>[vpn][vpn][offset]</code> 构成，要索引一个 <code>vaddr</code> 的物理地址，首先获取 <code>satp</code> 的值，然后将其中的 <code>ppn</code> 转换为根页表的初始位置，并且用 <code>vpn1</code> 作为下标在根页表中找到指名下一级页表的 pte(page table entry), 再次使用它的 ppn 计算到下一级页表的具体地址，然后使用 <code>vpn0</code> 再次索引，找到最终的 leaf pte, 计算其 <code>ppn</code> 表示的位置（即 paddr 所在的物理页的地址），并且加上 <code>offset</code>，得到最终的 paddr.</p>
<p>真的好绕，但是好歹还是实现完了， 但是这只是噩梦的第一步。</p>
<p>你会发现，之前写了半天的用户进程，居然还需要添加 VME 支持。主要修改了以下部分（按照我实现的时间顺序）</p>
<ul>
<li><code>context_uload</code> 中，为 AddrSpace 添加一个页表。<ul>
<li><code>context_uload</code> 中，</li>
</ul>
</li>
</ul>
<hr>
<p>好家伙，后期的 <code>bug</code> 一个比一个玄妙，反正就是极难。还是最好做一步测试一步。</p>
<p>第一个遇到的是，我找了很久，发现出现了一个空指针的问题，但是我无论如何也没找到空指针是在哪里。读了半天代码，我让它运行起来，结果发现，明明是被初始化为 <code>NULL</code> 的全局变量，居然有值。改这个 BUG 的时候有点浮躁，总之找了好久才发现是 loader 中没有处理 <code>filesz</code> 和 <code>memsz</code> 的边界条件，导致 <code>bss</code> 段等末尾的 <code>section</code> 加载后没有清零（当然，也是因为我的 <code>fs_read</code> 写丑了）</p>
<p>于是，第一个 <code>bug</code> 通过修改 <code>loader</code> 解决了。</p>
<p>现在我遇到的是，程序会莫名其妙 <code>HIT BAD TRAP</code> 掉。但是我根本没有地方调用 <code>halt()</code> 啊？于是经过大概一个小时的寻找，我发现 <code>halt()</code> 恰好被放在了 <code>putch() + 4</code> 的位置。这里就出现问题了，如果刚好在 <code>ret</code> 或者 <code>jmp</code> 的位置切换 <code>Context</code>，那锅就大了。</p>
<p>因为一次指令运行的顺序是这样的：前面的忽略，等指令运行结束，这时候所有的状态本应该是确定的。但是还要检查一次 <code>INTR</code>，如果 <code>intr</code> 为 <code>true</code>，之前放在 <code>jmp_pc</code> 中的值就会被忽略掉，<code>jmp</code> 指令的操作就失效了。于是我们需要特判一下前面是否进行的是会更改 <code>pc</code> 的指令。</p>
<pre><code class="c">  if (s-&gt;is_jmp == 1) {
    reg_csr(0x141) = s-&gt;jmp_pc;
    reg_csr(0x142) = NO;
    s-&gt;jmp_pc      = epc;
  } else {
    s-&gt;is_jmp      = 1;
    s-&gt;jmp_pc      = epc;
    reg_csr(0x141) = s-&gt;seq_pc; // set sepc &lt;- seq_pc
    reg_csr(0x142) = NO;        // scause
  }</code></pre>
<p>这样才能解决问题。</p>
<p>解决这个问题的时间里，我最开始是猜测 <code>SPIE, SIE</code> 构成的状态机会有一些问题，导致 <code>trap.S</code> 中的 <code>sstatus</code> 被还原后直接在 <code>trap.S</code> 运行一半时出锅，但实际上就不是这个问题。</p>
<p>但是在实现 VME 之后，性能就变得极拉，也暂时也无法优化了。</p>
<p>其中我还遇到了著名的 Heisenbugs, 即一调试就会消失的 bug.</p>
<p>主要的 bugs 应该就是这两个，解决之后用户线程和内核线程已经可以共存了。</p>
<hr>
<p>该解决最终的 ‘bug’ 了，用户线程的并行问题。</p>
<p>据说这是最难的问题，我也试了好久… 可惜完全没有头猪。根据 PA4 最后给出的解答：</p>
<p>最简单的情况，在 <code>A</code> 与 <code>B</code> 之间进行调度。假设目前，我们可爱的操作系统受到了硬件中断，要将 <code>A</code> 切换为 <code>B</code>.</p>
<p><code>trap.S</code> 最开头会将所有的内容保存到 <code>A</code> 的用户栈上，然后调用 <code>__am_irq_handle</code>，坑就坑在 <code>__am_irq_handle</code> 的最后更改了内存地址空间，切换为了 <code>B</code> 的内存地址空间。</p>
<p>然后，我们执行了 <code>return c;</code>。 但这时候的 <code>c</code>，已经不是之前的 <code>c</code> 了。这时候的用户栈是 <code>B</code> 的用户栈，一切的 <code>sp</code> 操作都是错误的。</p>
<p>比如说，<code>c</code> 是在 <code>a0</code> 中(<code>__am_asm_trap</code> 中调用的时候，是把 <code>Context</code> 指针根据调用约定扔在 <code>a0</code> 中的)，而 <code>return</code> 后，可能根本回不到正确的地点。</p>
<hr>
<p>这个问题先搁置了，比较恼火…</p>

		</div>
		
	</section>
	
</article>

<!-- comments config -->
<br>
<div id="vcomments" class="post white-box article-type-post"></div>
<br>
<script>
	new Valine({
		el: '#vcomments',
		appId: '0P1DwbIiwq7XB7nsT9teGpNs-MdYXbMMI',
		appKey: 'uEuSv3RSeUF1uR0spxgvezR2',
		placeholder: 'QwQ.',
		notify: true,
		verify: true,
		avatar: 'mp',
		visitor: true
	})
</script>
      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='https://p.sda1.dev/1/31a2170cd16f0fb7ab2e50b2e39bf9a1/avatar.jpg' />

<div class='header'>Traceback</div>
<div class='content'>
<div></div>
</div>
</section>

  <section class='m_widget friendly-links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://lirewriter.cn">
            <div class='name'>LittleRewriter</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://mgt.moe">
            <div class='name'>Margatroid</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://7li.moe">
            <div class='name'>HigHwind</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://q234rty.top">
            <div class='name'>Q234rty</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://vixbob.moe">
            <div class='name'>ViXbob</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/CS/"><div class='name'>CS</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/Daily/"><div class='name'>Daily</div><div class='badget'>5</div></a></li>
    
        <li><a class="flat-box" href="/categories/Design/"><div class='name'>Design</div><div class='badget'>3</div></a></li>
    
        <li><a class="flat-box" href="/categories/Math/"><div class='name'>Math</div><div class='badget'>2</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/tags/Algorithms/" style="font-size: 14px; color: #808080">Algorithms</a> <a href="/tags/Atcoder/" style="font-size: 14px; color: #808080">Atcoder</a> <a href="/tags/Learning/" style="font-size: 17px; color: #404040">Learning</a> <a href="/tags/Memories/" style="font-size: 14px; color: #808080">Memories</a> <a href="/tags/杂记/" style="font-size: 14px; color: #808080">杂记</a> <a href="/tags/瞎写/" style="font-size: 20px; color: #000">瞎写</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">
  <div class="social-wrapper">
     
    <a
      href="https://github.com/kririae"
      class="social github"
      target="_blank"
      rel="external"
    >
      <span class="icon icon-github"></span>
    </a>
    
    <a
      href="/atom.xml"
      class="social rss"
      target="_blank"
      rel="external"
    >
      <span class="icon icon-rss"></span>
    </a>
     
  </div>

  <div>
    Theme
    <a
      href="https://github.com/stkevintan/hexo-theme-material-flow"
      class="codename"
      >MaterialFlow</a
    >
    designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.
  </div>

  <div>Modified by <a href="https://kr2.moe">krr.</a></div>
</footer>

  <script>setLoadingBarProgress(80);</script>
  

<script src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src='//cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js'></script>
<script src="//cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>

<script src="/js/jquery.fitvids.js"></script>
<script>
  var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
  var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
  var ALGOLIA_API_KEY = "";
  var ALGOLIA_APP_ID = "";
  var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/" || "/";
  if (!ROOT.endsWith('/')) ROOT += '/';
  var BANNER_IMAGE = "true" == "true";
  var BANNER_HITOKOTO = "true" == "true";
  var BANNER_TITLE = "\." || "Alternative Sky";
  var BANNER_CUSTOMIMAGE = "true" == "true";
  var BANNER_IMAGELIST = "https://p.sda1.dev/1/b66fc4a626a011019bc8fe204188f93d/BG.jpg".split(',');
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>
  <script>setLoadingBarProgress(100);</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
