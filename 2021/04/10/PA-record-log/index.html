<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <title>PA_record.log | Alternative Sky</title>
    <meta name="description" content="\.">
    <meta name="keywords" content>
    <meta name="HandheldFriendly" content="True">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <link rel="shortcut icon" href="https://p.sda1.dev/1/31a2170cd16f0fb7ab2e50b2e39bf9a1/avatar.jpg"> <link rel="alternate" href="/atom.xml" title="Alternative Sky">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="从指令集实现到操作系统nju-ics-pa 工程记录  那就让我来认真对待这个质量高的夸张的PA。NJU牛逼！ 我就是精神南大人（不）">
<meta property="og:type" content="article">
<meta property="og:title" content="PA_record.log">
<meta property="og:url" content="http://kr2.moe/2021/04/10/PA-record-log/index.html">
<meta property="og:site_name" content="Alternative Sky">
<meta property="og:description" content="从指令集实现到操作系统nju-ics-pa 工程记录  那就让我来认真对待这个质量高的夸张的PA。NJU牛逼！ 我就是精神南大人（不）">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://p.sda1.dev/1/544e01f72a3251751867da0461d29ebb/image.png">
<meta property="og:updated_time" content="2021-05-06T15:46:34.737Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PA_record.log">
<meta name="twitter:description" content="从指令集实现到操作系统nju-ics-pa 工程记录  那就让我来认真对待这个质量高的夸张的PA。NJU牛逼！ 我就是精神南大人（不）">
<meta name="twitter:image" content="https://p.sda1.dev/1/544e01f72a3251751867da0461d29ebb/image.png">

    <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
    <link href="//cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/style.css"> 

    <script>
      function setLoadingBarProgress(num) {
        document.getElementById("loading-bar").style.width = num + "%";
      }
    </script>

    <script>
      MathJax = {
        // mathjax config
        tex: {
          packages: ["base"],
          inlineMath: [
            ["$", "$"],
            ["\\(", "\\)"],
          ],
          displayMath: [
            ["$$", "$$"],
            ["\\[", "\\]"],
          ],
          processEscapes: true,
          digits: /^(?:[0-9]+(?:\{,\}[0-9]{3})*(?:\.[0-9]*)?|\.[0-9]+)/,
          maxBuffer: 5 * 1024,
        },
        options: {
          skipHtmlTags: [
            "script",
            "noscript",
            "style",
            "textarea",
            "pre",
            "code",
            "annotation",
            "annotation-xml",
          ],
          includeHtmlTags: {
            br: "\n",
            wbr: "",
            "#comment": "",
          },
          compileError: function (doc, math, err) {
            doc.compileError(math, err);
          },
          typesetError: function (doc, math, err) {
            doc.typesetError(math, err);
          },
        },
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/styles/atom-one-dark.min.css">

    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.5.0/build/highlight.min.js"></script>

    <script>
      hljs.configure({
        tabReplace: "    ",
      });
      hljs.initHighlightingOnLoad();
    </script>

    <script src="//cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script>
  <link rel="alternate" href="/atom.xml" title="Alternative Sky" type="application/atom+xml">
</head>
</html>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class="wrapper container">
		<a class="logo flat-box" href='/'>
			Alternative Sky
		</a>
		<div class='menu'>
			<ul class='h-list'>
				
				<li>
					<a class='flat-box nav-home' href='/'>
						Home
					</a>
				</li>
				
				<li>
					<a class='flat-box nav-archives' href='/archives'>
						Archives
					</a>
				</li>
				
				<li>
					<a class='flat-box nav-about' href='/about'>
						About
					</a>
				</li>
				
			</ul>
			<div class='underline'></div>
		</div>
		
		<div class="m_search">
			<form name="searchform" class="form u-search-form">
				<input type="text" class="input u-search-input" placeholder="Search" />
				<span class="icon icon-search"></span>
			</form>
		</div>
		
		<ul class='switcher h-list'>
			
			<li class='s-search'><a href='javascript:void(0)'><span class="icon icon-search"></span></a></li>
			
			<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu"></span></a></li>
		</ul>
	</div>
	<aside class="menu-phone">
		<nav>
			
			<a href="/" class="nav-home nav">
				Home
			</a>
			
			<a href="/archives" class="nav-archives nav">
				Archives
			</a>
			
			<a href="/about" class="nav-about nav">
				About
			</a>
			
		</nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container'>
      <div class='l_main'>
        <article id="post-PA-record-log" class="post white-box article-type-post" itemscope
	itemprop="blogPost">
	<section class='meta'>
		<h2 class="title">
			<a href="/2021/04/10/PA-record-log/">
				PA_record.log
			</a>
		</h2>

		

		

		<time>
			4月 10, 2021
		</time>

		<span class="vertical-line" style="color: #b5b5b5; margin: 0px 5px 0px 5px;">|</span>

		<span id="/2021/04/10/PA-record-log/" class="leancloud_visitors" data-flag-title="文章阅读量统计">
			<em class="post-meta-item-text"> 阅读量 </em>
			<i class="leancloud-visitors-count">0</i>
		</span>

		<span class="vertical-line" style="color: #b5b5b5; margin: 0px 5px 0px 5px;">|</span>

		<span class="words-count">
			总字数 4.8k
		</span>

		<span class="vertical-line" style="color: #b5b5b5; margin: 0px 5px 0px 5px;">|</span>

		<span class="time-count">
			期望阅读时间 18 min
		</span>
	</section>
	
	<section class="tog"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PA1"><span class="toc-number">1.</span> <span class="toc-text">PA1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA2"><span class="toc-number">2.</span> <span class="toc-text">PA2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PA3"><span class="toc-number">3.</span> <span class="toc-text">PA3</span></a></li></ol></section>
	
	<section class="article typo">
		<div class="article-entry" itemprop="articleBody">
			<blockquote>
<p>从指令集实现到操作系统<br>nju-ics-pa 工程记录</p>
</blockquote>
<p>那就让我来认真对待这个质量高的夸张的PA。NJU牛逼！</p>
<p>我就是精神南大人（不）</p>
<a id="more"></a>

<h2 id="PA1"><a href="#PA1" class="headerlink" title="PA1"></a>PA1</h2><p>调用顺序：</p>
<p><code>main.c</code> 调用 <code>init_monitor()</code></p>
<ul>
<li><p><code>parse-args</code> 中的 <code>getopt_long</code> 函数的文档查看通过 <code>man 3 getopt</code> 进行。这个在 Arch 下有坑。（会显示 locale 未定义）只需要 RTFM(archwiki) 安装 <code>man-pages</code> 等两个包即可。而 <code>man</code> 后的第一个参数：</p>
<ul>
<li>1: Executable programs</li>
<li>2: System calls3: Library calls</li>
</ul>
</li>
</ul>
<p>最常见的就是这三个了。我们要查看 <code>getopt.h</code> 中的，选择第三个。找到 <code>getopt_long()</code> 的定义与使用方法。初始化 <code>struct option</code> 后… 详细的就不说了，下次用到的时候再看文档（x</p>
<ul>
<li><p><code>init_log</code> 中也无什么可以说的。包括 <code>init_mem()</code>。 </p>
</li>
<li><p>接下来是一个比较关键的 <code>init_isa()</code>。 <code>init_isa</code> 中（我选择 riscv32 来学习）。</p>
<p><code>init_isa</code> 函数中会将 <code>image</code> 复制到 <code>IMAGE_START</code> 中（为 <code>pmem</code> 所代表的地址，由 <code>guest_to_host</code> 函数进行映射，而 <code>guest_to_host</code> 函数的意思为</p>
<pre><code>/* convert the guest physical address in the guest program to host virtual address in NEMU */</code></pre></li>
</ul>
<p>NEMU 的执行会在$n$次循环后结束，而这个$n$由 <code>~0 (-1)</code> 得到。还算比较简单吧。</p>
<ul>
<li><p>踩了个坑，使用 uint 的时候，不能拿来判长度。不信你试试看，绝对挂。</p>
</li>
<li><p>在 +4 那里又挂了一次。一个 word 是两个字节 xxx</p>
</li>
<li><p><code>inline</code> 那个是咋回事？应该是定义函数的时候并不需要加上更多的qulifier？我也记不清了。</p>
</li>
</ul>
<p>需要注意的是，在编写获取寄存器内容的时候，需要特别处理 <code>pc</code>，因为 <code>pc</code> 并未出现在 <code>regsl</code> 中。</p>
<p>PA1 写完了，来个总结。（至于必答题… 我就偷懒惹</p>
<p>各类 <code>#include&lt;&gt;</code> 的写法， 我果然还得再努力学习一下。写完代码不能什么都不学到，至少得学到点工程的知识对吧，那就是 Think twice, code once，同一个道理。</p>
<blockquote>
<p>补充。实际上我的 debugger 有不少的 bug，但是鉴于此项目整体比较简单，而且启动 debugger 比较麻烦，我后来也没怎么用过这个 debugger。这部分的基础设施我就懒得再 fix bugs 了。</p>
</blockquote>
<h2 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h2><blockquote>
<p>一条指令在 NEMU 中的一生</p>
</blockquote>
<p>程序运行顺序：</p>
<p>在 <code>main.c</code> 开始运行后进入 <code>init_monitor</code>，其中 <code>load_img</code> 会加载其 <code>~.bin</code> 。</p>
<p>接下来在 <code>engine_start</code> 中，<code>ui_mainloop</code> 会识别其为 <code>batchmode</code> 并且进行 <code>cmd_c</code>进入 <code>cpu_exec</code>。该指令的一生从这里开始。</p>
<p>说错了点，其实是从循环里的 <code>isa_exec_once()</code> 开始，其在 <code>nemu/isa/riscv32/exec/exec.c</code> 中定义。</p>
<p>首先来看这个 <code>DecodeExecState</code>，在 <code>decode.h</code> 中定义，</p>
<pre><code class="c">typedef struct {
  uint32_t opcode;
  vaddr_t seq_pc;  // sequential pc
  uint32_t is_jmp;
  vaddr_t jmp_pc;
  Operand src1, dest, src2;
  int width;
  rtlreg_t tmp_reg[4];
  ISADecodeInfo isa;
} DecodeExecState;</code></pre>
<p>注意其中的几个关键点。我们按照<code>isa_exec_once()</code> 中的顺序介绍。首先默认不是 <code>jmp</code> 的类型（所以关于 <code>pc</code> 的操作可以暂时忽略）。并将 <code>seq_pc</code> 置为 <code>cpu.pc</code>（之后再管这部分）</p>
<p>其中的 ISADecodeInfo 是跟着 ISA 的，<code>isa.h</code> 中进行了宏定义将具体的 ISA 定义为了该 ISADecodeInfo。我们的 <code>riscv32_ISADecodeInfo</code> 大致内容如下</p>
<pre><code class="c">typedef struct {
  union {
    struct {
      uint32_t opcode1_0 : 2;
      ...
    } i;
    struct {
      uint32_t opcode1_0 : 2;
      ...
    } s;
    struct {
      uint32_t opcode1_0 : 2;
      ...
    } u;
     ...
    uint32_t val;
  } instr;
} riscv32_ISADecodeInfo;</code></pre>
<p>定义了 opcode 的几种形态，至于这几种形态的具体内容，refer to <code>riscv-spec.pdf</code> 的 page 16。后面带了一个 <code>val</code>，用来存储指令原有的样子。那个加冒号的写法实际上是位段的处理，保证 i/s/u 的二进制位和和标准的 instruction format 对应吧。这里非标准使用 <code>union</code> 的骚操作保证 <code>val</code> 里的每一位都直接被赋值…实在精彩。如果需要自己写这段，大小端的问题需要注意，算了今天就不处理了。</p>
<p>于是，这条指令进入了 <code>fetch_decode_exec()</code> 函数中。这个函数将带领这个指针走完其一生。</p>
<p>我们实现的CPU执行一条指令有四个步骤，IF | ID | EX | PC。</p>
<p>IF 比较简单，阅读 <code>instr_fetch</code> 可以发现，只是一次访问 <code>vaddr</code> 的询问，取其地址内容即可。</p>
<hr>
<p>开始 ID 并保证 <code>opcode1_0 == 0x3</code> 。（至于为什么，看文档去）</p>
<p>接下来是对 <code>opcode6_2</code> 进行 <code>switch</code>。其中 <code>IDEX</code> 是一份宏定义，在 <code>exec.h</code> 中。共进行了三步。确定 instruction 的宽度，通过宏定义 decode 到具体函数，通过宏定义执行具体函数。嘛，由于 switch 是使用跳表，所以会快一些。</p>
<p>我们在 switch 中使用的都是 IDEX，即默认将 width 置为 0。</p>
<blockquote>
<p>mips32和riscv32的访存指令会有不同操作数宽度的版本, 包括32位, 16位和8位, 因此我们还需要把宽度信息记录到<code>s</code>中提供后续过程使用.</p>
</blockquote>
<p>然后，设置完宽度后，我们花大篇幅来修改一下译码(ID)操作。给宏提供的参数为具体的 <code>I/S/U</code>，及会被解析为 <code>decode_load_I</code> 函数。依次类推。</p>
<p>然后是操作数(Operand)的控制，这要求我们进行进一步 Decode，由 Decode Helper Function 完成。 DHF 的宏定义在 <code>include/cpu/decode.h</code> ，而 Decode Operand Helper Function 的宏定义在 <code>local_include/decode.h</code> 中，目前只有两种操作，即 <code>decode_op_i</code> 和 <code>decode_op_r</code>，对应立即数和寄存器。在被宏定义的 <code>decode_op_r</code> 中，有一个 <code>op-&gt;preg</code>，是一个指向对应寄存器的指针。这样做避免了每次都访问 <code>reg_l(val)</code>。</p>
<p>被 DHF 定义的一系列函数基本都是重复的工程操作，查 specification 即可。照着这个类型，再多实现些指令类型也可。</p>
<hr>
<p>译码部分就这样，我们可爱的指令终于可以开始执行了。</p>
<p>执行部分的函数定义由 <code>def_EHelper</code> 进行。</p>
<p>需要执行的指令可能有多种情况，即 <code>isa.{}.funct3</code>  就可以区分不同指令，与 <code>funct3/funct7</code> 同时需要以区分指令。但是 <code>EX</code> 系列的宏并不允许我们在指令中进行 <code>switch</code>（你明明就可以不用它！），但是为了与 <code>load</code>, <code>store</code> 代码的整体性，我还是选择用 <code>EX</code> 宏 + 新添加一个函数来处理。</p>
<p>在操作寄存器的过程中，我们使用 <code>rtl</code>与<code>rtl pseudo</code>。<code>rtl pseudo</code> 存在的意义是方便我们使用 <code>rtl</code>。</p>
<p>总而言之，经过了大半周摸摸搞搞的修改（这部分没有写 <code>pa-record</code>），终于实现了 <code>RV32I</code> 和 <code>RV32M</code> 系列的指令，实现了部分 <code>klib</code> 后，离项目的完成又尽了一步（躺）</p>
<hr>
<p>接下来就是 I/O 的部分了，即设备的输入输出。</p>
<p>设备的输入输出有集中常见方式。端口 I/O 和内存映射 I/O。</p>
<p>前者的对寄存器操作设备的方案依赖于 <code>in/out</code> 指令。这两个指令能够负责向某个端口的寄存器写入某些值，设备读取这些值并且进行对应操作。</p>
<p>MMIO 则更加先进，在物理内存空间上分配一段空间给设备，然后 CPU 在操作某段内存的时候，不知不觉就操作了对应的设备。</p>
<hr>
<p><code>mainargs</code> 传入的过程：在 <code>nemu.mk</code> 的 line 19</p>
<pre><code class="c">CFLAGS += -DMAINARGS=\&quot;$(mainargs)\&quot;</code></pre>
<p>在编译时这个会被传入到 <code>mainargs[]</code> 变量中，再在 <code>_trm_inirt()</code> 中被传入到 <code>main</code> 函数中去。神秘。</p>
<hr>
<p>接下来让我尝试理清楚 NEMU 和 AM 在软硬件上配合的关系。</p>
<p>首先从硬件层的 NEMU 说起吧。NEMU 在每条指令运行的时候都会尝试观测 <code>device_update_flag</code> 的情况。如果为 <code>true</code>，则会在指令执行结束之后运行 <code>device.c</code> 中的 <code>device_update</code> 函数，这个函数目前（主要）负责：</p>
<ol>
<li>进行 <code>vga_update</code>，将会调用 <code>vga.c</code> 中的 <code>vga_update_screen</code> 函数，该函数会观测寄存器 <code>sync</code> 的情况，如果其值为 <code>1</code> 则真正意义上进行同步。</li>
<li>进行 <code>key_down</code> 的观测，这个是基于 SDL 的 API，就不深究了。</li>
</ol>
<p>既然现在要写显卡，我们来看一看 VGA 的部分。<code>update_screen</code> 函数会操作 SDL 读取 <code>vmem</code> 中的内容显示图像，我们姑且不管这一部分，回到软件层面来看一看。</p>
<p>既然 AM 是 NEMU 的抽象，我们就不能简单从“这俩会通信”来入手。</p>
<p>最基础的最基础的问题是，NEMU 是编译在 x86-64 上的，而 AM 是跑在 riscv32 上的。而事实上，NEMU 当然能获取自己的寄存器（及内存）信息，AM 也能修改其寄存器（及内存）信息。所以这俩就建立了通信。我们的目的是让自己写的 C 能跑在 riscv32 上。 AM 给用户程序提供了几个常规的 API，比如说 <code>io_read</code> 和 <code>io_write</code>。这两个函数能操作 AM 让 AM  让 AM 修改寄存器信息。</p>
<hr>
<p>声卡，虽然会很砖，但是必须实现。仙剑奇侠传怎么能没声音呢？</p>
<pre><code class="c">/* * * * * * * * * * AUDIO PART * * * * * * * * * * *
 * AURIO_CTRL   : Audio control, to change freq/channel/samples
 * AUDIO_STATUS : Used buffer size
 * AUDIO_PLAY   : Write [buf.start, buf.end) to buffer, wait until there&#39;s space
 * */
AM_DEVREG(14, AUDIO_CONFIG, RD, bool present; int bufsize);
AM_DEVREG(15, AUDIO_CTRL,   WR, int freq, channels, samples);
AM_DEVREG(16, AUDIO_STATUS, RD, int count);
AM_DEVREG(17, AUDIO_PLAY,   WR, Area buf);
// * * * * * * * * * AUDIO PART * * * * * * * * * * *</code></pre>
<p>首先我们来分析一下 <code>am-tests</code> 中的 <code>audio.c</code>。这是一段播放小星星的代码。</p>
<p><code>audio.c</code> 最开始是检测 <code>AM_AUDIO_CONFIG</code> 的 <code>present</code> 是否为 <code>true</code>，当然，我们需要将其设为 <code>true</code>。</p>
<p>接下来是初始化 <code>freq</code> 等基本信息，略过。</p>
<p><code>AUDIO_PLAY</code> 需要一段 <code>Area</code>，用于存即将写入 <code>buffer</code> 的内容…</p>
<p>我靠，从昨天晚上写到刚才，终于能跑了，来检讨一下笨死了的自己。</p>
<p>我实现的是一个由 AM 上的 <code>push</code> 和 nemu 里的 <code>pop</code> 维护的一个 queue，这个 queue 装在对应内存里。内存的前 8 个字节用于装 <code>head</code> 和 <code>end</code>，是队列所对应的循环数组的首尾。</p>
<p>由程序调用 <code>AM</code> 中的 <code>__am_audio_play</code>，其会等待直到 <code>buffer</code> 中有空余空间后进行写入。这里其实有不少问题，是依赖于主机的 context switch 的，所以我采用一种比较保守的实现，但是实际上好像… 额，性能比较弱。即在 <code>push</code> 和 <code>pop</code> 函数内部对 queue 的 size 通过 MMIO 进行维护。 之后可以在这里多想想，然后尝试实现一些以一个 <code>segment</code> 为单位的队列？性能应该会高不少。</p>
<p>SDL 的回调函数每次会取 2048 个元素（有可能），性能还算不错。但是 <code>push</code> 那边的话因为需要等待空间，性能就比较弱。</p>
<p>不过第一次写是为了正确实现，抽象的比较高。现在的实现应该是没有问题的，如果仙剑那边跑的实在太卡的话我就用 <code>mem</code> 系列指令重写一下。（虽然 <code>mem</code> 系列我也没优化就是了，肯定要优化一下的，比如给 mem 系列实现一个硬件层的接口让宿主来进行 memset ？？？x）</p>
<p>之后有心情的话可以去读一下 LiteNES 的代码，这次就算了。居然还能学优化x 之后再说。</p>
<hr>
<h2 id="PA3"><a href="#PA3" class="headerlink" title="PA3"></a>PA3</h2><p>PA3 这部分比较难懂，有一些 <code>undoc feature</code>。</p>
<p>我们来做那个必答题，<code>yield()</code> 调用之后发生了什么。</p>
<p>进入了 <code>yield</code> 函数，将 <code>a7</code> 作为参数（即 <code>sstatus</code>）传给了 <code>ecall</code>，<code>ecall</code> 执行对应操作，并调用 <code>raise_instr</code> 执行了设置 <code>sepc</code> 和设置 <code>scause</code> 等操作。需要注意，在 <code>cte_init</code> 中，我们将 <code>__am_asm_trap</code> 的<strong>函数指针</strong>传入了 <code>stvec</code>，所以其会 <code>jmp</code> 到 <code>__am_asm_trap</code> 里。<code>__am_asm_trap</code> 的操作相对比较迷惑，大概意思就是在栈里初始化了 <code>Context*</code>，于是在接下来的函数就能访问之前的内容。大概是，这样吧。我是有点没读懂的。</p>
<hr>
<p>我一直不太熟悉 ELF 的格式，今天再来 review 一下。</p>
<blockquote>
<p> ELF 有面向链接的 section 视角，提供了可重定位信息。第二个是面向执行的 segment 视角，这个视角提供了加载可执行文件的信息。 通过 <code>readelf</code> 我们能看到 <code>section</code> 和 <code>segment</code> 的映射关系。</p>
<p> ELF 采用 <code>program header table</code> 来管理 <code>segment</code>。通过 <code>ehdr</code> 来管理 <code>section</code>。其中 <code>ehdr</code> 包含了所有 <code>segment</code> 放置的位置（通过一个数组）</p>
<p> 所以我们的 <code>loader</code> 需要负责加载所有的 <code>segment</code>。</p>
</blockquote>
<p>ELF 还有很多我不太熟悉的操作，还是以后遇到问题 <code>man 5 elf</code> 吧。（上面的东西是前几天写的了，懒得补充了）</p>
<hr>
<p>今天我们再来梳理一下从 <code>hello.c</code> 到最后程序运行的过程。</p>
<p><code>hello.c</code> 由其 Makefile 管理。这里再让我吐槽一下 CLion 的逻辑，Makefile 在 CLion 里完全不可用（躺）。我也不想一点一点做移植，就这样将就了。</p>
<p>然后我们将 <code>hello.c</code> <code>mv</code> 到 <code>ramdisk.img</code>，其为一个已经并未链接的 elf。它会在 nanos-lite 链接的时候由 <code>resource.S</code> 链接到其 <code>.data</code> 段中。（？？？感觉这操作好神秘）</p>
<pre><code class="asm">.section .data
.global ramdisk_start, ramdisk_end
ramdisk_start:
.incbin &quot;build/ramdisk.img&quot;
ramdisk_end:
// ...</code></pre>
<p>关于上述步骤，用 <code>readelf</code> 查看 nanos-lite 的编译结果可以看到，<code>.symtab</code> 里有 <code>ramdisk_start</code> 和 <code>ramdisk_end</code> 的痕迹。<code>ramdisk</code> 的一系列 API 能够让读取该段内存的内容。而我们的 <code>loader()</code> 则负责将该段内存读取到其应该存在的地方。（即其自身 ELF header 设置的 entry 及其之后的内容）</p>
<p>既然 <code>loader</code> 返回了 <code>entry</code>，<code>naive_uload</code> 将 <code>pc</code> 切换到 <code>loader</code> 的 <code>entry</code>，即开始运行 <code>ramdisk</code> 的内容了。</p>
<p>关于 <code>ecall</code> 的部分我再给自己哆嗦两句。<code>ecall</code> 的类型参数存放在 <code>a7</code> 中，我们规定 <code>a7  = [0..20)</code> 是系统调用。其编号的具体内容在 navy_apps 的 <code>syscall.h</code> 中存放着。<code>syscall.c</code> 中实现了一些系统调用（说来我咋觉得这些东西该放在 nanos-lite 中呢，不过放在 navy-apps 中也有一定道理倒是x）</p>
<hr>
<p>终于写完虚拟文件系统了… 写了一周多。这套文件系统里有不少的坑，我们慢慢道来。</p>
<p>虚拟文件系统又是一层抽象（尽管会略微降低性能？），我们实现了一份比较简单的文件系统，支持基础的读写操作。虚拟文件系统实现的核心是，为特殊文件实现特殊的读写函数，而这个读写函数不一定是针对储存空间操作的，可能是针对某一些特殊的数据流操作的。当然，通用的读写函数也是必须被实现的，这些读写函数将操作真正的一块处于硬盘（？）中的一块被抽象的，称作文件的空间。关于文件的格式已经研究过了，在这里就不再赘述。</p>
<p>我们在此处只需考虑那些特殊的，“被抽象”出来的文件。比如：</p>
<pre><code class="c"> typedef struct {
  char *name;
  size_t size;
  size_t disk_offset;
  ReadFn read;
  WriteFn write;
} Finfo;

// ...
{&quot;/dev/events&quot;, 0, 0, events_read, invalid_write},
{&quot;/proc/dispinfo&quot;, 0, 0, dispinfo_read, invalid_write},
{&quot;/dev/fb&quot;, 0, 0, invalid_read, fb_write},</code></pre>
<p>这三者是被抽象出的文件，抽象出的文件的核心在于那个 <code>ReadFn</code> 函数，这个函数是可以被自行定义的，比如 <code>dispinfo_read</code> 就会调用 AM 中实现的一系列接口，返回一段字符。这段字符并没有放在硬盘上。</p>
<p>在对文件读写时，首先尝试调用 <code>ReadFn</code> 以及 <code>WriteFn</code>，若失败，才会跌落至常规的对文件的读写。</p>
<p>在此基础上实现了 <code>device.c</code> 中的一系列函数，包括：</p>
<ul>
<li><code>serial_write</code>: 串口输入输出，抽象为 <code>stdout</code>/<code>stderr</code></li>
<li><code>events_read</code>: 从 <code>AM_INPUT_KEYBRD</code> 获取键盘输入信息，抽象为 <code>/dev/events</code></li>
<li><code>dispinfo_read</code>: 已经提到了</li>
<li><code>fb_write</code>: 是显存的抽象，实现不太友好（还有不少瑕疵），不想提了。</li>
</ul>
<p>总而言之，经过了一段时间，已经解决了这部分的内容，该进入 PA3 的最后一部分啦！</p>
<hr>
<blockquote>
<p>Fixed-point arithmetic</p>
</blockquote>
<p>神秘的，可以避开 FPU 实现的方法。</p>
<p>定点算数实现的核心是避开 IEEE 标准，自己实现一套更加简便的，和当前 ALU 同构的规范。浮点数和定点数的运算本身没有过大的区别，都是数字和数字的碰撞，IEEE 标准徒增功耗（不）</p>
<p>于是我们定义一套新的标准，对于一个实数 $a$，我们将其表示为 $A = a \cdot 2^8$，在内存中存储为</p>
<pre><code>31  30                           8          0
+----+---------------------------+----------+
|sign|          integer          | fraction |
+----+---------------------------+----------+</code></pre><blockquote>
<p>（书里的图，我就嫖来了）</p>
</blockquote>
<p>鉴于小数的最低位是在 $2^{-8}$，我们乘上 $2^8$ 之后可以建立一套双射。</p>
<p>回答这个问题：</p>
<blockquote>
<p>阅读<code>fixedpt_rconst()</code>的代码, 从表面上看, 它带有非常明显的浮点操作, 但从编译结果来看却没有任何浮点指令. 你知道其中的原因吗?</p>
</blockquote>
<p>确实啊（沉思），先总结一下，<code>fixedpt</code> 让编译器来负责大部分的浮点处理。</p>
<p>我们用 <a href="https://godbolt.org/" target="_blank" rel="noopener">godbolt</a> 来测试一下，<code>int a = (int)1.333;</code>，得出的指令并没有浮点运算。<code>fixedpt_rconst</code> 也同理</p>
<pre><code class="c">#define fixedpt_rconst(R) ((fixedpt)((R) * FIXEDPT_ONE + ((R) &gt;= 0 ? 0.5 : -0.5)))
#define FIXEDPT_ONE    ((fixedpt)((fixedpt)1 &lt;&lt; FIXEDPT_FBITS))</code></pre>
<p><code>FIXEDPT_ONE</code> 则是之前提到的 $2^8$，这部分预处理会在编译器完成。而例如，$-1.2$，会出现 $-1.2 \cdot 2^8 - 0.5 \rightarrow -307.7 \rightarrow -307$ 的情况，这个 $\pm0.5$ 估计是拿来修正整数值的吧。晕乎乎，不管了。</p>
<hr>
<p>TODO: PA3</p>
<hr>
<p>我们还是先开始 PA4 好了，毕竟 PA3 的后面部分有点砖。我简单修了一下批处理系统那套，应该能够基本运行了。不过我还是对分时多任务感兴趣一点，于是就先做 PA4 了。</p>
<p>PA4 难度不低，我们先解决基本的 Context Switch 的问题。分为几步比较神秘的。</p>
<p>首先把 <code>Context</code> 和 <code>PCB</code> 的定义扔在这里。</p>
<pre><code class="c">typedef union {
  uint8_t stack[STACK_SIZE] PG_ALIGN;
  struct {
    Context *cp;
    AddrSpace as;
    // we do not free memory, so use `max_brk&#39; to determine when to call _map()
    uintptr_t max_brk;
  };
} PCB;

struct Context {
  uintptr_t gpr[32];
  uintptr_t cause, status, epc;
  void *pdir;
};</code></pre>
<p>其定义比较清晰，<code>PCB</code> 的意思是进程控制块，用户保存内核栈和 <code>cp</code>，<code>Context pointer</code>，指向保存的用于 Context switch 的“虚假的上下文”。而这个虚假的上下文是虚假给 <code>trap.S</code> 看的，<code>trap.S</code> 会还原这个偷梁换柱的上下文中的信息，并且通过 <code>sret</code> 跳转到其 <code>epc</code> 的位置。偷梁换柱进行的位置是 <code>trap.S</code> 中的 <code>jal __am_irq_handle</code>，这个函数会产生返回值并且放在 <code>a0</code>。我们只需 <code>mv sp, a0</code> 即可漂漂亮亮地替换被还原的上下文。</p>
<p><code>init_irq</code> 的时候调用了 <code>cte_init</code>，<code>do_event</code> 被作为全局变量<code>user_handler</code> 放入到了 <code>cte.c</code> 中，这个函数指针今后会在 <code>__am_irq_handle</code> 调用，并且会返回 <code>c</code>，在 <code>trap.S</code> 中的 <code>a0</code> 寄存器被接收，先不谈这里。</p>
<p><code>kcontext</code> 会创建一个上下文，将其放在 <code>kstack</code> 的最底部。然后 <code>PCB</code> 的 <code>union</code> 会将 <code>cp</code> 指向 <code>context</code> 的顶部。<code>sret</code> 会将这玩意儿倒回 <code>Context</code> 设定的位置，开始 <code>Context</code> 部分的运行。</p>
<p>为了清晰地解释，画一张图。</p>
<p><img src="https://p.sda1.dev/1/544e01f72a3251751867da0461d29ebb/image.png" alt="image.png"></p>
<p>为了节约空间（懒）我没有画3一些细节的部分。</p>
<blockquote>
<p>[实在太久没有阶段性的成就感了，先把这玩意儿丢到博客里好了]</p>
</blockquote>

		</div>
		
	</section>
	
</article>

<!-- comments config -->
<br>
<div id="vcomments" class="post white-box article-type-post"></div>
<br>
<script>
	new Valine({
		el: '#vcomments',
		appId: '0P1DwbIiwq7XB7nsT9teGpNs-MdYXbMMI',
		appKey: 'uEuSv3RSeUF1uR0spxgvezR2',
		placeholder: 'QwQ.',
		notify: true,
		verify: true,
		avatar: 'mp',
		visitor: true
	})
</script>
      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='https://p.sda1.dev/1/31a2170cd16f0fb7ab2e50b2e39bf9a1/avatar.jpg' />

<div class='header'>Traceback</div>
<div class='content'>
<div></div>
</div>
</section>

  <section class='m_widget friendly-links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://lirewriter.cn">
            <div class='name'>LittleRewriter</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://mgt.moe">
            <div class='name'>Margatroid</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://7li.moe">
            <div class='name'>HigHwind</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://q234rty.top">
            <div class='name'>Q234rty</div>
        </a></li>
    
        <li><a class="flat-box" target="_blank" href="https://vixbob.moe">
            <div class='name'>ViXbob</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/CS/"><div class='name'>CS</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/Daily/"><div class='name'>Daily</div><div class='badget'>5</div></a></li>
    
        <li><a class="flat-box" href="/categories/Design/"><div class='name'>Design</div><div class='badget'>3</div></a></li>
    
        <li><a class="flat-box" href="/categories/Math/"><div class='name'>Math</div><div class='badget'>2</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/tags/Algorithms/" style="font-size: 14px; color: #808080">Algorithms</a> <a href="/tags/Atcoder/" style="font-size: 14px; color: #808080">Atcoder</a> <a href="/tags/Learning/" style="font-size: 17px; color: #404040">Learning</a> <a href="/tags/Memories/" style="font-size: 14px; color: #808080">Memories</a> <a href="/tags/杂记/" style="font-size: 14px; color: #808080">杂记</a> <a href="/tags/瞎写/" style="font-size: 20px; color: #000">瞎写</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">
  <div class="social-wrapper">
     
    <a
      href="https://github.com/kririae"
      class="social github"
      target="_blank"
      rel="external"
    >
      <span class="icon icon-github"></span>
    </a>
    
    <a
      href="/atom.xml"
      class="social rss"
      target="_blank"
      rel="external"
    >
      <span class="icon icon-rss"></span>
    </a>
     
  </div>

  <div>
    Theme
    <a
      href="https://github.com/stkevintan/hexo-theme-material-flow"
      class="codename"
      >MaterialFlow</a
    >
    designed by <a href="http://keyin.me/" target="_blank">Kevin Tan</a>.
  </div>

  <div>Modified by <a href="https://kr2.moe">krr.</a></div>
</footer>

  <script>setLoadingBarProgress(80);</script>
  

<script src="//cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src='//cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js'></script>
<script src="//cdn.jsdelivr.net/npm/scrollreveal@4.0.6/dist/scrollreveal.min.js"></script>

<script src="/js/jquery.fitvids.js"></script>
<script>
  var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
  var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
  var ALGOLIA_API_KEY = "";
  var ALGOLIA_APP_ID = "";
  var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/" || "/";
  if (!ROOT.endsWith('/')) ROOT += '/';
  var BANNER_IMAGE = "true" == "true";
  var BANNER_HITOKOTO = "true" == "true";
  var BANNER_TITLE = "\." || "Alternative Sky";
  var BANNER_CUSTOMIMAGE = "true" == "true";
  var BANNER_IMAGELIST = "https://p.sda1.dev/1/b66fc4a626a011019bc8fe204188f93d/BG.jpg".split(',');
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>
  <script>setLoadingBarProgress(100);</script>
</body>
</html>
