{"meta":{"title":"Alternative Sky","subtitle":"\\.","description":"\\.","author":"Traceback","url":"http://kr2.moe","root":"/"},"pages":[{"title":"About","date":"2018-02-12T01:08:58.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"about/index.html","permalink":"http://kr2.moe/about/index.html","excerpt":"","text":"About @ShanghaiTech SISTors 高三学生。 Preparing for college entrance examination. AFO。本博客不光更新关于算法的问题了。高二。请多指教 Update Records 2018/02/12 修改 tab-size 2018/02/13 修改 gitment 和本主题 css 冲突的问题，感谢冰河姐 2018/05/26 修改被屏蔽的 cdn ，感谢q姐 2019/09/22 restart 2019/10/13 添加 Valine，字数统计，修改代码块渲染。 2020/07/13 使用 github actions + github pages Q&amp;AQ：明明是 About，为什么没个个人简介？A：一方面是出于隐私考虑，但现在的设计似乎也只能防君子不防小人。另一方面则是，没有必要把自己介绍的明明白白，穿插在博文中让读者自己去了解吧？哈哈 Q：你不是CS学生么，为什么技术类博客那么少？A：因为能力不足，我目前的水平(2020)能写出来的博文，也都是和随处可见的博文类似，什么学习笔记啊总结啊之类的，大多数是没有必要单独开博文发出来的。以后若见技术类博文，大概也都是我为之投入了很多的。 Q：为什么会有那么多个人经历类内容？A：因为喜欢写，我喜欢写。虽然很抱歉浪费了各位的时间，但有一点很确认的是：那些内容是独一无二的，是一个博客真正该承载的。"}],"posts":[{"title":"PA_record.log","slug":"PA-record-log","date":"2021-04-10T06:26:19.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2021/04/10/PA-record-log/","link":"","permalink":"http://kr2.moe/2021/04/10/PA-record-log/","excerpt":"从指令集实现到操作系统nju-ics-pa 工程记录 那就让我来认真对待这个质量高的夸张的PA。NJU牛逼！ 我就是精神南大人（不）","text":"从指令集实现到操作系统nju-ics-pa 工程记录 那就让我来认真对待这个质量高的夸张的PA。NJU牛逼！ 我就是精神南大人（不） PA1调用顺序： main.c 调用 init_monitor() parse-args 中的 getopt_long 函数的文档查看通过 man 3 getopt 进行。这个在 Arch 下有坑。（会显示 locale 未定义）只需要 RTFM(archwiki) 安装 man-pages 等两个包即可。而 man 后的第一个参数： 1: Executable programs 2: System calls3: Library calls 最常见的就是这三个了。我们要查看 getopt.h 中的，选择第三个。找到 getopt_long() 的定义与使用方法。初始化 struct option 后… 详细的就不说了，下次用到的时候再看文档（x init_log 中也无什么可以说的。包括 init_mem()。 接下来是一个比较关键的 init_isa()。 init_isa 中（我选择 riscv32 来学习）。 init_isa 函数中会将 image 复制到 IMAGE_START 中（为 pmem 所代表的地址，由 guest_to_host 函数进行映射，而 guest_to_host 函数的意思为 /* convert the guest physical address in the guest program to host virtual address in NEMU */ NEMU 的执行会在$n$次循环后结束，而这个$n$由 ~0 (-1) 得到。还算比较简单吧。 踩了个坑，使用 uint 的时候，不能拿来判长度。不信你试试看，绝对挂。 在 +4 那里又挂了一次。一个 word 是两个字节 xxx inline 那个是咋回事？应该是定义函数的时候并不需要加上更多的qulifier？我也记不清了。 需要注意的是，在编写获取寄存器内容的时候，需要特别处理 pc，因为 pc 并未出现在 regsl 中。 PA1 写完了，来个总结。（至于必答题… 我就偷懒惹 各类 #include&lt;&gt; 的写法， 我果然还得再努力学习一下。写完代码不能什么都不学到，至少得学到点工程的知识对吧，那就是 Think twice, code once，同一个道理。 补充。实际上我的 debugger 有不少的 bug，但是鉴于此项目整体比较简单，而且启动 debugger 比较麻烦，我后来也没怎么用过这个 debugger。这部分的基础设施我就懒得再 fix bugs 了。 PA2 一条指令在 NEMU 中的一生 程序运行顺序： 在 main.c 开始运行后进入 init_monitor，其中 load_img 会加载其 ~.bin 。 接下来在 engine_start 中，ui_mainloop 会识别其为 batchmode 并且进行 cmd_c进入 cpu_exec。该指令的一生从这里开始。 说错了点，其实是从循环里的 isa_exec_once() 开始，其在 nemu/isa/riscv32/exec/exec.c 中定义。 首先来看这个 DecodeExecState，在 decode.h 中定义， typedef struct { uint32_t opcode; vaddr_t seq_pc; // sequential pc uint32_t is_jmp; vaddr_t jmp_pc; Operand src1, dest, src2; int width; rtlreg_t tmp_reg[4]; ISADecodeInfo isa; } DecodeExecState; 注意其中的几个关键点。我们按照isa_exec_once() 中的顺序介绍。首先默认不是 jmp 的类型（所以关于 pc 的操作可以暂时忽略）。并将 seq_pc 置为 cpu.pc（之后再管这部分） 其中的 ISADecodeInfo 是跟着 ISA 的，isa.h 中进行了宏定义将具体的 ISA 定义为了该 ISADecodeInfo。我们的 riscv32_ISADecodeInfo 大致内容如下 typedef struct { union { struct { uint32_t opcode1_0 : 2; ... } i; struct { uint32_t opcode1_0 : 2; ... } s; struct { uint32_t opcode1_0 : 2; ... } u; ... uint32_t val; } instr; } riscv32_ISADecodeInfo; 定义了 opcode 的几种形态，至于这几种形态的具体内容，refer to riscv-spec.pdf 的 page 16。后面带了一个 val，用来存储指令原有的样子。那个加冒号的写法实际上是位段的处理，保证 i/s/u 的二进制位和和标准的 instruction format 对应吧。这里非标准使用 union 的骚操作保证 val 里的每一位都直接被赋值…实在精彩。如果需要自己写这段，大小端的问题需要注意，算了今天就不处理了。 于是，这条指令进入了 fetch_decode_exec() 函数中。这个函数将带领这个指针走完其一生。 我们实现的CPU执行一条指令有四个步骤，IF | ID | EX | PC。 IF 比较简单，阅读 instr_fetch 可以发现，只是一次访问 vaddr 的询问，取其地址内容即可。 开始 ID 并保证 opcode1_0 == 0x3 。（至于为什么，看文档去） 接下来是对 opcode6_2 进行 switch。其中 IDEX 是一份宏定义，在 exec.h 中。共进行了三步。确定 instruction 的宽度，通过宏定义 decode 到具体函数，通过宏定义执行具体函数。嘛，由于 switch 是使用跳表，所以会快一些。 我们在 switch 中使用的都是 IDEX，即默认将 width 置为 0。 mips32和riscv32的访存指令会有不同操作数宽度的版本, 包括32位, 16位和8位, 因此我们还需要把宽度信息记录到s中提供后续过程使用. 然后，设置完宽度后，我们花大篇幅来修改一下译码(ID)操作。给宏提供的参数为具体的 I/S/U，及会被解析为 decode_load_I 函数。依次类推。 然后是操作数(Operand)的控制，这要求我们进行进一步 Decode，由 Decode Helper Function 完成。 DHF 的宏定义在 include/cpu/decode.h ，而 Decode Operand Helper Function 的宏定义在 local_include/decode.h 中，目前只有两种操作，即 decode_op_i 和 decode_op_r，对应立即数和寄存器。在被宏定义的 decode_op_r 中，有一个 op-&gt;preg，是一个指向对应寄存器的指针。这样做避免了每次都访问 reg_l(val)。 被 DHF 定义的一系列函数基本都是重复的工程操作，查 specification 即可。照着这个类型，再多实现些指令类型也可。 译码部分就这样，我们可爱的指令终于可以开始执行了。 执行部分的函数定义由 def_EHelper 进行。 需要执行的指令可能有多种情况，即 isa.{}.funct3 就可以区分不同指令，与 funct3/funct7 同时需要以区分指令。但是 EX 系列的宏并不允许我们在指令中进行 switch（你明明就可以不用它！），但是为了与 load, store 代码的整体性，我还是选择用 EX 宏 + 新添加一个函数来处理。 在操作寄存器的过程中，我们使用 rtl与rtl pseudo。rtl pseudo 存在的意义是方便我们使用 rtl。 总而言之，经过了大半周摸摸搞搞的修改（这部分没有写 pa-record），终于实现了 RV32I 和 RV32M 系列的指令，实现了部分 klib 后，离项目的完成又尽了一步（躺） 接下来就是 I/O 的部分了，即设备的输入输出。 设备的输入输出有集中常见方式。端口 I/O 和内存映射 I/O。 前者的对寄存器操作设备的方案依赖于 in/out 指令。这两个指令能够负责向某个端口的寄存器写入某些值，设备读取这些值并且进行对应操作。 MMIO 则更加先进，在物理内存空间上分配一段空间给设备，然后 CPU 在操作某段内存的时候，不知不觉就操作了对应的设备。 mainargs 传入的过程：在 nemu.mk 的 line 19 CFLAGS += -DMAINARGS=\\&quot;$(mainargs)\\&quot; 在编译时这个会被传入到 mainargs[] 变量中，再在 _trm_inirt() 中被传入到 main 函数中去。神秘。 接下来让我尝试理清楚 NEMU 和 AM 在软硬件上配合的关系。 首先从硬件层的 NEMU 说起吧。NEMU 在每条指令运行的时候都会尝试观测 device_update_flag 的情况。如果为 true，则会在指令执行结束之后运行 device.c 中的 device_update 函数，这个函数目前（主要）负责： 进行 vga_update，将会调用 vga.c 中的 vga_update_screen 函数，该函数会观测寄存器 sync 的情况，如果其值为 1 则真正意义上进行同步。 进行 key_down 的观测，这个是基于 SDL 的 API，就不深究了。 既然现在要写显卡，我们来看一看 VGA 的部分。update_screen 函数会操作 SDL 读取 vmem 中的内容显示图像，我们姑且不管这一部分，回到软件层面来看一看。 既然 AM 是 NEMU 的抽象，我们就不能简单从“这俩会通信”来入手。 最基础的最基础的问题是，NEMU 是编译在 x86-64 上的，而 AM 是跑在 riscv32 上的。而事实上，NEMU 当然能获取自己的寄存器（及内存）信息，AM 也能修改其寄存器（及内存）信息。所以这俩就建立了通信。我们的目的是让自己写的 C 能跑在 riscv32 上。 AM 给用户程序提供了几个常规的 API，比如说 io_read 和 io_write。这两个函数能操作 AM 让 AM 让 AM 修改寄存器信息。 声卡，虽然会很砖，但是必须实现。仙剑奇侠传怎么能没声音呢？ /* * * * * * * * * * AUDIO PART * * * * * * * * * * * * AURIO_CTRL : Audio control, to change freq/channel/samples * AUDIO_STATUS : Used buffer size * AUDIO_PLAY : Write [buf.start, buf.end) to buffer, wait until there&#39;s space * */ AM_DEVREG(14, AUDIO_CONFIG, RD, bool present; int bufsize); AM_DEVREG(15, AUDIO_CTRL, WR, int freq, channels, samples); AM_DEVREG(16, AUDIO_STATUS, RD, int count); AM_DEVREG(17, AUDIO_PLAY, WR, Area buf); // * * * * * * * * * AUDIO PART * * * * * * * * * * * 首先我们来分析一下 am-tests 中的 audio.c。这是一段播放小星星的代码。 audio.c 最开始是检测 AM_AUDIO_CONFIG 的 present 是否为 true，当然，我们需要将其设为 true。 接下来是初始化 freq 等基本信息，略过。 AUDIO_PLAY 需要一段 Area，用于存即将写入 buffer 的内容… 我靠，从昨天晚上写到刚才，终于能跑了，来检讨一下笨死了的自己。 我实现的是一个由 AM 上的 push 和 nemu 里的 pop 维护的一个 queue，这个 queue 装在对应内存里。内存的前 8 个字节用于装 head 和 end，是队列所对应的循环数组的首尾。 由程序调用 AM 中的 __am_audio_play，其会等待直到 buffer 中有空余空间后进行写入。这里其实有不少问题，是依赖于主机的 context switch 的，所以我采用一种比较保守的实现，但是实际上好像… 额，性能比较弱。即在 push 和 pop 函数内部对 queue 的 size 通过 MMIO 进行维护。 之后可以在这里多想想，然后尝试实现一些以一个 segment 为单位的队列？性能应该会高不少。 SDL 的回调函数每次会取 2048 个元素（有可能），性能还算不错。但是 push 那边的话因为需要等待空间，性能就比较弱。 不过第一次写是为了正确实现，抽象的比较高。现在的实现应该是没有问题的，如果仙剑那边跑的实在太卡的话我就用 mem 系列指令重写一下。（虽然 mem 系列我也没优化就是了，肯定要优化一下的，比如给 mem 系列实现一个硬件层的接口让宿主来进行 memset ？？？x） 之后有心情的话可以去读一下 LiteNES 的代码，这次就算了。居然还能学优化x 之后再说。 PA3PA3 这部分比较难懂，有一些 undoc feature。 我们来做那个必答题，yield() 调用之后发生了什么。 进入了 yield 函数，将 a7 作为参数（即 sstatus）传给了 ecall，ecall 执行对应操作，并调用 raise_instr 执行了设置 sepc 和设置 scause 等操作。需要注意，在 cte_init 中，我们将 __am_asm_trap 的函数指针传入了 stvec，所以其会 jmp 到 __am_asm_trap 里。__am_asm_trap 的操作相对比较迷惑，大概意思就是在栈里初始化了 Context*，于是在接下来的函数就能访问之前的内容。大概是，这样吧。我是有点没读懂的。 我一直不太熟悉 ELF 的格式，今天再来 review 一下。 ELF 有面向链接的 section 视角，提供了可重定位信息。第二个是面向执行的 segment 视角，这个视角提供了加载可执行文件的信息。 通过 readelf 我们能看到 section 和 segment 的映射关系。 ELF 采用 program header table 来管理 segment。通过 ehdr 来管理 section。其中 ehdr 包含了所有 segment 放置的位置（通过一个数组） 所以我们的 loader 需要负责加载所有的 segment。 ELF 还有很多我不太熟悉的操作，还是以后遇到问题 man 5 elf 吧。（上面的东西是前几天写的了，懒得补充了） 今天我们再来梳理一下从 hello.c 到最后程序运行的过程。 hello.c 由其 Makefile 管理。这里再让我吐槽一下 CLion 的逻辑，Makefile 在 CLion 里完全不可用（躺）。我也不想一点一点做移植，就这样将就了。 然后我们将 hello.c mv 到 ramdisk.img，其为一个已经并未链接的 elf。它会在 nanos-lite 链接的时候由 resource.S 链接到其 .data 段中。（？？？感觉这操作好神秘） .section .data .global ramdisk_start, ramdisk_end ramdisk_start: .incbin &quot;build/ramdisk.img&quot; ramdisk_end: // ... 关于上述步骤，用 readelf 查看 nanos-lite 的编译结果可以看到，.symtab 里有 ramdisk_start 和 ramdisk_end 的痕迹。ramdisk 的一系列 API 能够让读取该段内存的内容。而我们的 loader() 则负责将该段内存读取到其应该存在的地方。（即其自身 ELF header 设置的 entry 及其之后的内容） 既然 loader 返回了 entry，naive_uload 将 pc 切换到 loader 的 entry，即开始运行 ramdisk 的内容了。 关于 ecall 的部分我再给自己哆嗦两句。ecall 的类型参数存放在 a7 中，我们规定 a7 = [0..20) 是系统调用。其编号的具体内容在 navy_apps 的 syscall.h 中存放着。syscall.c 中实现了一些系统调用（说来我咋觉得这些东西该放在 nanos-lite 中呢，不过放在 navy-apps 中也有一定道理倒是x） 终于写完虚拟文件系统了… 写了一周多。这套文件系统里有不少的坑，我们慢慢道来。 虚拟文件系统又是一层抽象（尽管会略微降低性能？），我们实现了一份比较简单的文件系统，支持基础的读写操作。虚拟文件系统实现的核心是，为特殊文件实现特殊的读写函数，而这个读写函数不一定是针对储存空间操作的，可能是针对某一些特殊的数据流操作的。当然，通用的读写函数也是必须被实现的，这些读写函数将操作真正的一块处于硬盘（？）中的一块被抽象的，称作文件的空间。关于文件的格式已经研究过了，在这里就不再赘述。 我们在此处只需考虑那些特殊的，“被抽象”出来的文件。比如： typedef struct { char *name; size_t size; size_t disk_offset; ReadFn read; WriteFn write; } Finfo; // ... {&quot;/dev/events&quot;, 0, 0, events_read, invalid_write}, {&quot;/proc/dispinfo&quot;, 0, 0, dispinfo_read, invalid_write}, {&quot;/dev/fb&quot;, 0, 0, invalid_read, fb_write}, 这三者是被抽象出的文件，抽象出的文件的核心在于那个 ReadFn 函数，这个函数是可以被自行定义的，比如 dispinfo_read 就会调用 AM 中实现的一系列接口，返回一段字符。这段字符并没有放在硬盘上。 在对文件读写时，首先尝试调用 ReadFn 以及 WriteFn，若失败，才会跌落至常规的对文件的读写。 在此基础上实现了 device.c 中的一系列函数，包括： serial_write: 串口输入输出，抽象为 stdout/stderr events_read: 从 AM_INPUT_KEYBRD 获取键盘输入信息，抽象为 /dev/events dispinfo_read: 已经提到了 fb_write: 是显存的抽象，实现不太友好（还有不少瑕疵），不想提了。 总而言之，经过了一段时间，已经解决了这部分的内容，该进入 PA3 的最后一部分啦！ Fixed-point arithmetic 神秘的，可以避开 FPU 实现的方法。 定点算数实现的核心是避开 IEEE 标准，自己实现一套更加简便的，和当前 ALU 同构的规范。浮点数和定点数的运算本身没有过大的区别，都是数字和数字的碰撞，IEEE 标准徒增功耗（不） 于是我们定义一套新的标准，对于一个实数 $a$，我们将其表示为 $A = a \\cdot 2^8$，在内存中存储为 31 30 8 0 +----+---------------------------+----------+ |sign| integer | fraction | +----+---------------------------+----------+ （书里的图，我就嫖来了） 鉴于小数的最低位是在 $2^{-8}$，我们乘上 $2^8$ 之后可以建立一套双射。 回答这个问题： 阅读fixedpt_rconst()的代码, 从表面上看, 它带有非常明显的浮点操作, 但从编译结果来看却没有任何浮点指令. 你知道其中的原因吗? 确实啊（沉思），先总结一下，fixedpt 让编译器来负责大部分的浮点处理。 我们用 godbolt 来测试一下，int a = (int)1.333;，得出的指令并没有浮点运算。fixedpt_rconst 也同理 #define fixedpt_rconst(R) ((fixedpt)((R) * FIXEDPT_ONE + ((R) &gt;= 0 ? 0.5 : -0.5))) #define FIXEDPT_ONE ((fixedpt)((fixedpt)1 &lt;&lt; FIXEDPT_FBITS)) FIXEDPT_ONE 则是之前提到的 $2^8$，这部分预处理会在编译器完成。而例如，$-1.2$，会出现 $-1.2 \\cdot 2^8 - 0.5 \\rightarrow -307.7 \\rightarrow -307$ 的情况，这个 $\\pm0.5$ 估计是拿来修正整数值的吧。晕乎乎，不管了。 TODO: PA3 我们还是先开始 PA4 好了，毕竟 PA3 的后面部分有点砖。我简单修了一下批处理系统那套，应该能够基本运行了。不过我还是对分时多任务感兴趣一点，于是就先做 PA4 了。 PA4 难度不低，我们先解决基本的 Context Switch 的问题。分为几步比较神秘的。 首先把 Context 和 PCB 的定义扔在这里。 typedef union { uint8_t stack[STACK_SIZE] PG_ALIGN; struct { Context *cp; AddrSpace as; // we do not free memory, so use `max_brk&#39; to determine when to call _map() uintptr_t max_brk; }; } PCB; struct Context { uintptr_t gpr[32]; uintptr_t cause, status, epc; void *pdir; }; 其定义比较清晰，PCB 的意思是进程控制块，用户保存内核栈和 cp，Context pointer，指向保存的用于 Context switch 的“虚假的上下文”。而这个虚假的上下文是虚假给 trap.S 看的，trap.S 会还原这个偷梁换柱的上下文中的信息，并且通过 sret 跳转到其 epc 的位置。偷梁换柱进行的位置是 trap.S 中的 jal __am_irq_handle，这个函数会产生返回值并且放在 a0。我们只需 mv sp, a0 即可漂漂亮亮地替换被还原的上下文。 init_irq 的时候调用了 cte_init，do_event 被作为全局变量user_handler 放入到了 cte.c 中，这个函数指针今后会在 __am_irq_handle 调用，并且会返回 c，在 trap.S 中的 a0 寄存器被接收，先不谈这里。 kcontext 会创建一个上下文，将其放在 kstack 的最底部。然后 PCB 的 union 会将 cp 指向 context 的顶部。sret 会将这玩意儿倒回 Context 设定的位置，开始 Context 部分的运行。 为了清晰地解释，画一张图。 为了节约空间（懒）我没有画3一些细节的部分。 [实在太久没有阶段性的成就感了，先把这玩意儿丢到博客里好了]","categories":[],"tags":[],"author":"Traceback"},{"title":"Recapture That Power of Setu","slug":"ghs","date":"2021-02-04T06:58:35.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2021/02/04/ghs/","link":"","permalink":"http://kr2.moe/2021/02/04/ghs/","excerpt":"这件事儿还挺有意思的（挠头），水一篇博客。 不是一篇技术博文，这是为了爱和正义与网络安全进行的斗争","text":"这件事儿还挺有意思的（挠头），水一篇博客。 不是一篇技术博文，这是为了爱和正义与网络安全进行的斗争 因为不知道什么原因，2021/2/3 日，我终于发现是因为一些神秘的问题，进而导致无法自定义 header 的 eagle extension 无法方便地从 pixiv 上下载色图！ 盗链这部分就使用 firefox 测试了，比较简单。 这本应该是一个容易解决的问题。我只是想下色图，而下色图只需要在 referer 中添加 https://www.pixiv.net 即可。但是这件事儿落到 eagle extension 上就变复杂了，因为涉及阅读的 eagle extension 源码的问题，还涉及浏览器安全的问题。 首先进到 edge 的插件目录里，找到 eagle 的插件，复制出去，然后进行修改。通过开发者模式进行导入。 观察到下载图片的核心函数，background.js 的 line: 480(and 380，注意有两处，分别对应拖拽和右键菜单) 左右出现了获取图片 base64 等操作。 ensureEagleIsOpen(function () { msg.src = convertSrc(msg.src); if (!msg.src) return; // console.time(&quot;取得图片 base64&quot;); toDataURL(msg.src, function(base64) { // console.timeEnd(&quot;取得图片 base64&quot;); var result = base64 || msg.src; var data = { ... 不得不吐槽一句 toDataURL 的可读性简直了，还把 custom 拼错了 其一部分代码是这样的 xhr.onload = function() { clearTimeout(timeout); var reader = new FileReader(); reader.onloadend = function() { if (!sent) { sent = true; if (reader.result.indexOf(&quot;data:image&quot;) &gt; -1) { callback(reader.result); } else { callback(undefined); }}} reader.readAsDataURL(xhr.response); }; ... timeout = setTimeout(function () { if (!sent) { sent = true; xhr.abort(); callback(undefined); } }, timeout); XMLHttpRequest.onload callback is the function to be executed when the request completes successfully.” The FileReader.onload property contains an event handler executed when the load event is fired. 总而言之，这段代码通过 toDataURL 来尝试获取对应图片的 base64，若失败，将 URL 再传给主程序处理，而主程序端若接受到 URL，则通过代理再次尝试获取该图片。现在的情况是，两次都失败了，因为两次都没有，也不可能设置 referer。 尝试使用服务端的方法，观察到 eagle 有两套 API，一套是官方最近公布的Open API，还有一套是原本用于 extension 和主程序通信的 API，端口号分别为 41593 与 41595。由于无法获取原 API 的信息，只能使用开放的 API。 尝试通过官方文档中的模板测试 eagle 服务端是否能进行下载，结论是不行，eagle 的进度条会卡住最后下载失败。 var data = { &quot;url&quot;: &quot;https://i.pximg.net/img-original/img/2021/02/02/19/18/33/87484491_p0.jpg&quot;, &quot;name&quot;: &quot;Test&quot;, &quot;headers&quot;: { &quot;referer&quot;: &quot;https://www.pixiv.net&quot; } }; var requestOptions = { method: &#39;POST&#39;, body: JSON.stringify(data), redirect: &#39;follow&#39; }; fetch(&quot;http://localhost:41595/api/item/addFromURL&quot;, requestOptions) .then(response =&gt; response.json()) .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(&#39;error&#39;, error)); 我使用其他的链接试了试，似乎 eagle 本身在 Open API 这部分的实现有部分问题，最明显的表现是 添加文件 (0/0)… 求求你赶紧把这部分的功能做好吧，我只能自己实现了orz 虽然不知道为什么，不过现在剩下的解法只有通过传递 base64 的方式来下载图片。jQuery 为了安全问题禁止更改 header 中的 referer，于是只能通过服务端的 request 来运行。 这里又因为经验吃亏了，我也测试了通过 fetch 来包含 header 信息，依然不行。通过抓包显示 fetch 根本没有添加上 referer 参数，似乎也是因为 ajax 不允许修改 referer 的问题。 再换方法，根据 stackoverflow 上的办法，可以通过给插件提供 webRequestBlocking 权限来发送修改 referer 参数。 好家伙，依然不行。 chrome.webRequest.onBeforeSendHeaders.addListener( function(details) { details.requestHeaders.push({name: &#39;Referer&#39;, value: &#39;https://www.pixiv.net&#39;}); return {requestHeaders: details.requestHeaders}; }, {urls: [&quot;http://i.pximg.net/*&quot;]}, [&quot;blocking&quot;, &quot;requestHeaders&quot;] ); fetch(&#39;http://i.pximg.net/img-original/img/2021/02/02/19/18/33/87484491_p0.jpg&#39;) 现在想来，应该就是跨域访问的问题，浏览器阻拦 referer 天经地义，只有我是傻逼和网络安全斗智斗勇。 除此之外，我还考虑了绕开 referer 的办法，即使用（及其古老的）referer killer 的思路，可惜在 2021 年早已行不通。 那么，不考虑和浏览器斗智斗勇，现在的解决办法有几个 搭建“反代”来绕过无法发送带 referer 请求的问题 写油猴脚本，通过油猴脚本来发送带 referer 的请求，已证明可行，但是工程量不小，我有点懒 还有一个，通过 inject code 来让浏览器自己发 referer（后续验证不太可行） 一觉睡了起来，脑子清醒了很多，重新找问题。 查一查 log，发现 eagle 2.0.0 版本更新是在 2021/1/21，而我最后一张图是在 2021/1/21 晚存的。再次查 log 发现，之前的内容都是通过 base64（见后） 下载的 [extension] version: 2.1.8 - Save image: [base64][2090658], source: https://www.pixiv.net/artworks/87159236所以有两种可能性，eagle 插件更新，edge 更新和 pixiv 外链政策更新导致的问题。 去查 qq 聊天记录，看到 edge 88 更新是在 2021/2/22 日（当时我去吐槽了好好看），现在唯一需要的是一个老版本的 eagle extension 插件。发现 extension 更新是 1.12 日，更不可能了。在之前发送请求的时候，edge 可能会回以缓存，现在的机制变化了。 但是换回老版本的 edge 不太可行，这段思考只能帮助我坚定地确定了，和浏览器斗智斗勇是不可能的，最优雅的解决办法是通过 inject code。那，终于到了写代码的时候了。 敢情我昨天一晚上白忙了啊… 不过也算学了不少东西 草，结果是，inject code 也没能解决问题，依然因为 CORS 限制。目前已知油猴脚本可以突破 CORS 的限制，但是完全不知道是怎么做到的。 通过在原脚本中添加 console.log(msg.src); chrome.tabs.executeScript( tab.id, { code: `window.inject_url = &quot;${msg.src}&quot;;` }, () =&gt; { chrome.tabs.executeScript( tab.id, { file: &quot;pixiv.js&quot; }, (res) =&gt; { console.log(&quot;Exec: &quot; + res); }); } ); 可以实现简单的跨域传递参数和返回参数， 脚本中的对应函数如下 (function () { console.log(&quot;Downloading&quot;: window.inject_url); var ret; function getPixivImage(url) { var xhr = new XMLHttpRequest(); var timeout = 700; var sent = false; // From background.js xhr.onload = function () { clearTimeout(timeout); var reader = new FileReader(); reader.onloadend = function () { if (!sent) { sent = true; if (reader.result.indexOf(&quot;data:image&quot;) &gt; -1) { ret = reader.result; } else { ret = undefined; } } }; reader.readAsDataURL(xhr.response); }; xhr.open(&quot;GET&quot;, url); xhr.responseType = &quot;blob&quot;; xhr.send(); timeout = setTimeout(function () { if (!sent) { sent = true; xhr.abort(); ret = undefined; } }, timeout); } getPixivImage(window.inject_url); return ret; })(); 为了防止 CSRF，这里会不工作也情有可原… 又是一个没有想到的地方。那，估计只能调用油猴脚本了，这操作越来越复杂了。 油猴脚本的 GM_xmlhttpRequest 可以实现跨域访问，但是还不太清楚其原理。 但是从外部访问油猴脚本看起来就不太可能… 最终办法真的只有用油猴和 eagle extension 配合了吗？ 使用油猴脚本进行跨域访问，将结果写入全局变量中（使用 messaging 也行） 通过pixiv.js 获取全局变量和油猴脚本对接，实现简单的跨域访问。 这里还需要了解 CORS 的简单请求有关内容。满足一系列条件（懒得ref）的请求为简单请求，而简单请求是先发送信息再检查。但是这回的 GET 中含有 referer，所以依然无法满足简单请求的条件。 这篇文档里描述了 content scripts 在 chromium 88 里已无法跨域。 我开了 bgm 上的讨论。 好家伙了，我直接好家伙，最后的解决方式有两个 第一个是，在 bgm 的讨论里有人提到给 eagle 发了 email 请求更改这部分的逻辑，然后… 然后更新版本后问题就解决了。 第二个是添加反代（没想到基于 cloudflare worker 的反代那么简单？！），既然问题已经解决了就不做了。 eagle 新版本的逻辑也很奇怪，会先将文件下载到一个 temp 目录里再让主程序从这个目录 fetch 图片。但是这就导致了一个问题：无法 retry。这是个很简单的问题，只要修改一下 retry 的逻辑就好了，但是 eagle 团队就是没有做好… 而且，什么时候能把设置代理给加回来… 我服气啦 有很多很幼稚的地方和问题，这就当成变强过程中的一篇幼稚的博文吧。 不过在写这篇博文里我有这样的感受，以前学的看似“无用”的东西总会有用武之地。哪怕是我已经放弃了的 CTF 也提供给了不少解决问题的能力。感谢自己写过的每一行代码，感谢自己学过的每一个奇奇怪怪的知识。","categories":[],"tags":[],"author":"Traceback"},{"title":"Learning Cpp","slug":"Learning-Cpp","date":"2021-01-22T14:05:56.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2021/01/22/Learning-Cpp/","link":"","permalink":"http://kr2.moe/2021/01/22/Learning-Cpp/","excerpt":"From C++ Primer (5th edition) From OI to Engineering","text":"From C++ Primer (5th edition) From OI to Engineering Basic 引用 == 别名。 引用的初值必须是一个同类型对象 顶层 const：指针本身是常量，int *const a = &amp;i; 底层 const：指针指向的内容是常量，const int *p2 = &amp;c1; 按照经验来说，复合类型的判断通过打括号来进行。如 (int*) (const a = &amp;i); 最靠近其的符号即其具体内容，”a 本身是个常量“。后者最靠近其的为*，说明其是个指针。 const expression 的定义为，需要在编译时就能计算得到结果的表达式。一旦你认定一个值为常量表达式，使用 constexpre 申明即可（这样是不是能够编译时计算圆周率） 在 type alias 中，可以使用 typedef 来创建类型别名。比如 typedef double base, *p;，在新方法中，可以使用 using db = double; 除了 auto，还有 decltype 能用于进行类型推断。decltype(f()) 甚至可以推断函数返回值的类型。decltype((var)) 的结果永远是引用 int b = 1, _b = 2; int *c = &amp;b; decltype((c)) d = c; cout &lt;&lt; *d &lt;&lt; endl; d = &amp;_b; cout &lt;&lt; *c &lt;&lt; endl; 输出是 1 2。若要直接写指针引用，则 int *(&amp;d) = c; 这种时候为了理解，还是打括号。(int*) (&amp;d) = c; 再叠加一层，声明顶层 const 附带的指针引用呢，算了算了（（（ 头文件中不应该包含 using，以免引发冲突。 返回数组指针的函数，int *func(int i)[10];，或者写作 auto func(int i) -&gt; int(*)[10]; 预处理功能中，assert(expr) 能够对表达式求值，若表达式非零则继续，否则停止。预处理器无需使用 std::assert(expr)。 使用 NDEBUG #ifndef NDEBUG std::cerr &lt;&lt; __func__ &lt;&lt; std::endl; #endif 若要脱离调试阶段，只需 #define NDEBUG 即可，即 not debug. 类似的预处理器定义的名字有 __FILE__ 文件名 __LINE__ 存储当前行号 __TIME__ 存放文件编译时间 __DATE__ 存放编译日期 Class函数指针，int (*pt)(const int &amp;, const int &amp;);，而将函数名作为一个值使用的时候，该函数名就被当成指针。比如，pt = apb，写成 pt = &amp;apb 也行。 const 成员函数，即常量成员函数。具体的写法为，valtype func(int, int) const { ... }，主要用于限制 this 指针的行为。类内部可以忽略 this，但是为了内容清晰，之后的写法还是加上 this-&gt;... 比较好。decltype(this) 的结果是 ClassType *const，即顶层 const，而顶层 const 是允许修改其指向对象的值的。添加 const 以后，this 的类型变为了 const ClassType *const，即同时满足顶层 const 与底层 const。本身不能被修改，也不能修改其成员函数。 友元函数，声明位于类最前或最后，意在为非成员函数提供访问 private 的途径。不光如此，还可以为某一个类的成员提供访问权限。但是啊，声明顺序的问题就出现了。假设我们由 A 给 B 提供友元，即 B 要操作 A 的 private 成员。顺序必须为 声明 A，但是不定义 A 的成员函数（因为这时候还没有进行友元声明） 在 B 的内容中给 A 添加友元 定义 A 中的成员函数 而友元函数真正出现在类的定义域时，是友元函数被定义的时候。所以才建议将类的成员函数分开写。 默认构造函数在 C++ 11 中的写法为 ClassName() = default; 通过添加 mutable，可以设置可变数据成员，即该对象可以被 const 对象修改。 一个类中，若存在常量成员变量或引用的成员变量时，需要在类的内部添加构造函数并且通过构造函数初始值列表为这些成员提供初始值。 需要注意，构造函数的初始值最好按照声明变量的顺序进行。否则可能会出现未定义的情况。 委托构造函数：在多种构造函数的情况下，委托构造函数能够复用之前构造函数的内容以进行构造。 构造函数偶尔会出现隐式转换，若要抑制隐式转换，使用 explicit 。 #include &lt;iostream&gt; #include &lt;memory&gt; using std::make_shared; using std::shared_ptr; using std::string; class Tmp { public: Tmp() = default; $qwq$ Tmp(const char *&amp;st) : s(st) { } void print() const { std::cout &lt;&lt; this-&gt;s &lt;&lt; std::endl; } private: string s; }; int main() { Tmp a = &quot;qwq&quot;; a.print(); } 若将 line 11 加上 explict，该编译不通过。因为 line 21 出现了隐式类型转换。 类的静态成员，即与类本身直接相关的成员。静态成员可以是 private 或者 public 的，只需要加上前缀 static 即可。既可以用作用域运算符来访问，也可以从类的对象引用或者指针来访问。 Generic泛型算法依赖于迭代器，而迭代器通常不会修改容器本身，于是我们可以知道，泛型算法不会进行容器的操作。 比如这份代码 void eraseDuplicated(std::vector&lt;std::string&gt; &amp;words) { std::sort(words.begin(), words.end()); auto end_unique = std::unique(words.begin(), words.end()); words.erase(end_unique, words.end()); } 有些时候，会遇到需要重载 sort 行为的情况，标准库接受一元谓词和二元谓词。stable_sort 表示，若无法判断大小，则保留原有的顺序。 lambda 表达式可以通过$$[\\text{capture list}](\\text{parameter list}) \\rightarrow \\text{return type} { \\ \\text{function body} \\ }$$定义。可以忽略 parameter list 和 return type，但是必须保留 capture list 和 function body int x = 3; // Capture the parameters auto f2 = [x](const int &amp;i) { return (i &gt; x); }; for (int i = 1; i &lt;= 5; ++i) cout &lt;&lt; f2(i) &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; 这么说，lambda 表达式是不是可以实现作用域的穿透。（从上向下的穿透） 而捕获分为几种，值捕获，引用捕获，等。 来个骚操作，假如，我是说假如哦，如果我想让 sort 函数输出排序的具体过程。 std::ostream&amp; os = cout; std::vector&lt;int&gt; lst{ 5, 4, 3, 2, 1 }; std::sort(lst.begin(), lst.end(), [&amp;os](const int &amp;a, const int &amp;b) { os &lt;&lt; &quot;Comparing:&quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; return a &lt;= b; }); 若要让编译器进行自动的捕获，parameter list 写成 &amp; 或 = 即可。前者是引用捕获，后者是值捕获。 若要让编译器进行返回值类型推断，必须使用尾置返回类型。 标准库的 bind 函数，可以 auto f = bind([](const int &amp;a, const int &amp;b) { return a + b; }, 1, 2)，则 f() 得到 3。类似于提供了参数默认值吧。感觉这操作有种人体改造的感觉。 之前实现的捕获，也可以用 bind 来复现，不过没多大意思了。顺带，_1，_2 可以被当作占位符使用。这玩意儿居然是 std::placeholders::_n，忽然觉得有点神奇。 ref 函数可以返回一个引用，而 cref 函数可以返回一个常量引用。 Memory 我每次在 C++ 中看到 Memory 都会觉得莫名浪漫 #include &lt;memory&gt; 智能指针 shared_ptr&lt;T&gt; sp 中，sp.get() 表示返回被管理的原指针，不要轻易使用。 如果混用 shared_ptr 和普通指针，会导致引用计数的实际值与期望值不符合。 理论上来说，unique_ptr 是不能被拷贝的。但是拷贝并不只有 = 的拷贝等等，从一个函数返回时，unique_ptr 是能够被拷贝的，因为原对象立马就会被销毁。 指向数组的 unique_ptr 不支持成员访问运算符（？） 而若要使用 shared_ptr 来管理数组，需要提供删除器，即 [] (int *p) { delete [] p; } 若不提供删除器，则会出现只 delete 某一个元素的问题。 Class, again合成拷贝构造函数，编译器为我们定义的通过拷贝进行构造的函数，会拷贝除了 static 成员之外的所有成员到正在创建的对象中。 这种操作让我感到了一丝不合缝的优雅，虽然对成员的类型进行不同方式的定义或许有必要，为了拷贝构造单独规范每种类型的拷贝方式也颇伤大雅了吧？如果将拷贝构造提升到一种更高的逻辑层次或许可以解释这种不和谐。或许是我的理解有些问题，就当我碎碎念了。 拷贝初始化和直接初始化的差距已经体现了出来，直接初始化采用普通的函数匹配。而（先不忙） 若拷贝构造函数初始化为 ClassName::ClassName(ClassName c); 而非 ClassName::ClassName(const ClassName &amp;c); 会出现怎样的问题？ 在拷贝时（调用拷贝构造函数），被拷贝对象被拷贝进 c 中，这个过程需要调用拷贝构造函数，而拷贝构造函数又会拷贝构造函数，如此往复。若使用常量引用，第一次的拷贝构造就会被停下来。 析构函数，指在类中的 ~ClassName(); 表示如何移除类所占用的空间。 虚函数，virtual，用于在派生类的类中重新定义这个函数而存在。在派生的类里，需要加上 override 来表明这是一个派生的函数。 派生类的定义需要添加 public/protected/private 三个访问说明符之一。class ClassName : public ClassName2 { ... }，这个说明符表示基类中的成员是否对派生类用户可见。 Template具体来说，模板函数写成这样 template&lt;typename T&gt; T max(const T &amp;a, const T &amp;b) { return a &gt; b ? a : b; } ... cout &lt;&lt; max(1, 2) &lt;&lt; endl; cout &lt;&lt; max(1.0, 2.0) &lt;&lt; endl; 这样写就能应付不同的数据类型。 再看一个 template&lt;typename T, typename U&gt; T max(const T &amp;a, const U &amp;b) { return a &gt; b ? a : b; } ... cout &lt;&lt; max(1, 2.0) &lt;&lt; endl; 其实 typename 和 class 是基本一样的，都能完成对类型的匹配。 但是，若这个类型没有同时定义 &gt; 和 &lt; 呢，","categories":[],"tags":[],"author":"Traceback"},{"title":"05","slug":"05-1","date":"2021-01-02T09:47:15.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2021/01/02/05-1/","link":"","permalink":"http://kr2.moe/2021/01/02/05-1/","excerpt":"","text":"","categories":[],"tags":[],"author":"Traceback"},{"title":"九月与十月杂记","slug":"sep_oct","date":"2020-10-21T15:52:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2020/10/21/sep_oct/","link":"","permalink":"http://kr2.moe/2020/10/21/sep_oct/","excerpt":"我也不知道我现在哪来的心情，在一篇论文两个网课一篇演讲还处于尚未动工的状态的情况下写这篇杂记，顺带明天还有 quiz，我还没复习。后天还有体测，我也没个底。可能是因为有很多东西想要表达，也可能是因为实在太久没有正经更新过博客，总之就是，我又开始写作了。","text":"我也不知道我现在哪来的心情，在一篇论文两个网课一篇演讲还处于尚未动工的状态的情况下写这篇杂记，顺带明天还有 quiz，我还没复习。后天还有体测，我也没个底。可能是因为有很多东西想要表达，也可能是因为实在太久没有正经更新过博客，总之就是，我又开始写作了。 如何完成从高三到大学的转变？ 一个暑假的摸鱼也没有改变我心目中摸鱼的形象——不能摸！无论如何，不能把学习的时间拿来摸鱼！但是结果是很可怜的，我依然抱着罪恶感摸鱼。 我也曾做过一些“逆反”的尝试，比如安排一整个下午来锻炼，比如花一整天的时间打 gal，我以为多多练习就会没有罪恶感了，然而事实证明不是，罪恶感只会满地堆积，摸鱼还会导致我差点没赶上 ddl。 很可笑是吧？一个学生为什么会去学习摸鱼。可是高三已经确切地在我心里刻下了深深的烙印，我认为这样是不正确的。我认为我不应该认为一切时间都应该为我的未来服务。我认为… 我应该留出时间来干自己喜欢的事情。我认为… 好吧，我在学习 CTF 的时候会想，我的线代是不是还不够扎实？我的数分是不是还有一些题目没有复习？然而这样的追求是永无止境的，我总会有题目没有复习，我也总会有知识还没有覆盖到，超过既定时间的复习大多都是无用功，然而我却在追求踏实感的路上越走越远，花费了大量的，原本应该去做自己喜欢的事的时间，或原本应该拿来放松摸鱼的时间。 然而高三就是这样，你除了学习和一些为了更好地学习的东西之外不应该花功夫，对于高考科目能力的追求是无止境的，因为竞争。高考是相对的竞争，你不变强你的竞争对手就会变强，于是你得变强，于是你就得花费大量时间去追求一个更高的高度，每一次考试都会告诉你你的高度，于是你就去追求一个更高的高度。 我错在把这种追求映射到了大学的科目上。摸鱼或许只是一个我的希望的代名词，我希望自己是一个会玩的人，我不能成为被文化课束缚的人。 这个问题尚未解决。 进了大学之后，曾经的朋友一个一个进入了算法竞赛圈。我得到这些信息之后的第一心情是，为什么我不会这样，为什么我没有想要这样，为什么我没有初升高时那样的，似乎比谁都要强烈的热情了？ 我便陷入了怀念中，怀念自己曾拥有的，却早已失去的各种东西。 我的青春似乎是有限的柴火，在我走来的路上，我曾获得过度温暖的幸福，在我再次感到寒冷的时候，却一根也找不到了。 你这不是，常有的中年大叔对青春的怀念么？我觉得不是，我确实是处在一个满溢着青春氛围的地方。看到一楼的活动室里男女共处娱乐的场景，我似乎也有想过要加入他们，我似乎也很想再次在我最熟悉的算法竞赛的领域挥霍我的空余时间，似乎也有过想要找好看的女孩子要 QQ 的想法，也想要稍微打理打理变干净点。这都是我曾熟练的事情。 我甚至会怀念一年前每天抱着高深书籍研究的自己。我曾想要用广博的知识武装自己，读了好多书，学了好多东西，感觉自己快要变得真的好厉害。那时候我一次一次被人类的智慧所惊艳，然后一次一次立誓自己以后也要干出一番事业。所以我才下定决心来这里，只是为了搞研究，做出一番“有意义”的东西。我曾为我这种思维感到骄傲。 但是现在我做不到了。 如果我不能做到棱角分明，就会留下空洞，所以我才不希望被磨平。 所以我才尝试去学生会做设计，想要留下一些突出的东西。但是似乎不行，第一次合作的体验真的很差，那时我也在考虑将大量精力投入 CTF，所以我在面试上说，“抱歉，我是来弃权的。” 可笑的是，我似乎并没有把大量精力投入 CTF，我对 CTF 的兴趣是断断续续的，或许今天有心情，我喜欢上 CTF 了，我就学一晚上，被比赛打击到了，于是我就很长一段时间不学。我深知这样是搞不出结果的。 于是我才回归到自己的茧中。 我懒得尝试新东西，于是尝试在文化课中寻求慰藉。但是我不喜欢这样的自己，所以我选择学习“摸鱼”。我喜欢那样那样的自己，于是我尝试通过行动在现在的自己中寻找过去的影子。 这时候肯定会有人劝我，你要走出自己的茧啊，你要去尝试挑战新事物！ 我想，但是我懒啊。 九月十月并不是很顺利的两个月，我做不到在这篇杂记的结尾来一个苏东坡式上扬。 就这样吧。","categories":[{"name":"Daily","slug":"Daily","permalink":"http://kr2.moe/categories/Daily/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://kr2.moe/tags/杂记/"}],"author":"Traceback"},{"title":"并不可爱的高三","slug":"start","date":"2020-07-24T15:24:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2020/07/24/start/","link":"","permalink":"http://kr2.moe/2020/07/24/start/","excerpt":"这或许是人生路上又一段稚嫩的歌曲，尽管我依然没能处理好许多事情，我还是决定将其记录下来，无论可爱与否，留给各位当一个参考，也给未来的自己送上一段回忆。而之所以决定在这个最难受的时期写这篇博文，大概也有自我安慰的因素。无论说了多少丧气话，发了多少呆，心里有多难受，无论怎么埋怨命运，我还是得咬着牙填写自己的未来，然后走在这完全被颠覆的人生的路上。","text":"这或许是人生路上又一段稚嫩的歌曲，尽管我依然没能处理好许多事情，我还是决定将其记录下来，无论可爱与否，留给各位当一个参考，也给未来的自己送上一段回忆。而之所以决定在这个最难受的时期写这篇博文，大概也有自我安慰的因素。无论说了多少丧气话，发了多少呆，心里有多难受，无论怎么埋怨命运，我还是得咬着牙填写自己的未来，然后走在这完全被颠覆的人生的路上。 Chapter Ⅰ我并不坚强，在高三开始时我就知道了。 进入高三后，我对自己的成绩的意识也越来越明确。直到那时我才认识到，原来拥有目标只是达成梦想中最微不足道的一环，而清晰的自我认知也极其重要。零诊的成绩相较我高三后期并不优异。对比后我大概发现，我离北航还很远。 我设定北航这个目标似乎并没有多少理由，梦想不需要理由。在那时，我是确确实实准备以北航为目标努力的。 我还记得高三刚开始时，我把「北航之路」几个字写在笔记本全新的一页上，踌躇满志地出发。那天晚上晚自习下课后，我一个人戴上耳机，走到校园后的菜地去。在夜晚，向日葵只拥有月光，一个个都低垂着头，无精打采地，却在为着第二天的阳光做好抬头的准备。当时我看着向日葵，咬咬牙，那时我知道，如果要达成去北航的可能性，一定得超过班上所有人，而我也知道，站在我前面的二十几位同学是有多可怕。但是天真的我却握着拳头说，我要超过你们所有人，踩在脚下，然后最终达成我的北航之梦。 那是最初的天真的梦，理综的出现将我打得措手不及。故事即将开始。 刚合卷的时候我很不习惯，选择题每次都会错三个及以上。第一次理综成绩似乎还能看，但是第二次，第三次，我有越来越多的题目做不完，也有越来越多的选择题失误。我的理综分数从年级的 50 名左右，总分一路后退，一直退到 100，甚至更后。那可能是我高三最痛苦的一段时间，连续五次的退步，似乎把我从竞赛回来后获得的一切赔得血本无归。 每一次退步后，我都会想，「万一高考是这样，我不就完蛋了」。我还记得那时我说，我能有什么努力的理由？无论怎么熬夜学习，得到的结果总是退步退步再退步。仅仅两个月的时间，足以让我把北航的梦忘得一干二净，那段时间，我没法把北航写在自己的笔记本上，后来的一次月考更是把我的心态打到谷底，我思考过放弃，嘴上也说了无数遍放弃算了，这种无用的竞争不存在好了。那时我也真正意识到了北航的距离与自己有多远，不知何时，我停止仰望星空了，我最终决定把北邮当作目标，这个目标相较来说更容易达到。目标的更换到底是好事还是坏事我说不清楚，这个问题或许需要更长久的时间来回答。 无论如何，最后行动上，我没有忘记我还有一个属于远方的梦想，一切的反转也即将开始。 从结果上来说，反转是彻底成功的。理综从近乎最弱的一科到了最强的一科，并且从未翻车（除了高考）。可我对于这个反转说不出所以然，那时的颓废的我一定不会用尽全力去学习理综，理综的提升也本不该是一两次考试的事。无论如何，我的理综在我从南科大夏令营回归文化课后完全反转，从完全做不完题，到了 12 月的近乎完美的答卷以及大笔大笔的检查时间。我也有思考过，我的理综为何能反转的问题（嘛，我高考理综是彻底的失败，不过那也是后话了）。现在想想，可能和一诊前大量的刷题不无关系，也和我固有的性质（慢热）有极大关联。 不到一个月的时间，我从一个失败者变成了同学眼里的成功者，从眼看着把原有的阵地都要丢下，却忽然达到了我定下的北邮的目标，似乎就要成功了呢？离北航的距离也不过十分，只要把语文水平提升起来就好了，高三后期我也只需要保持现状就好了呢。那时的我是这么想的。 Chapter Ⅰ的经历是最精彩的，也是最令人摸不着头脑的。这剧情是不是差了块拼图，为何忽然就反转了呢？我也不知道。这或许就是人生和小说的最大差距，不是什么剧情都需要足够的铺垫与组织。和最后的失败一样，真的不需要任何理由。 结尾处我也要为自己辩解一下，那时的我或许也不是真的颓废，每天把时间表排的满满的，写了不少的笔记，按照同桌的说法，我努力到他都想努力了，认为自己真的不努力的，可能也只有我自己。 Chapter Ⅱ看似顺利的 end 1 后是一段更加顺风顺水的日子，我的语文忽然考了班上第一名，理综也考了班上第一。在我的心情最膨胀时，放寒假了，我带着那膨胀的心情开始了寒假本该一个月的学习。 然后，疫情来了，彻底打乱了我的阵脚。 本来设定好的每天去图书馆自习，却因为疫情肆虐根本无法前往。我在家里的自习效率极其低，从高一开始就是这样。就这样挥霍了半个月，我急，但急不能当饭吃。心急的心情下，我的摸鱼次数变得越来越多。很可笑的是，我的摸鱼并不是专攻一项的摸鱼，甚至也不是沉下心来打一个游戏，而是无所事事的翻翻书，看看论坛，翻翻 im 的聊天消息。这种摸鱼形态带来的最终结果就是，无聊。无聊的心情是难以享受的，娱乐行为的存在就是为了填补无聊带来的无力感，而加以高考的 dead line 的压迫，之后的一个月我一直处于抑郁+无聊的状态。 反馈也是调节心态的重要方式之一，而那段时间的反馈着实让人胃疼。网课下的考试水，这是全员皆知的，可我认定他们都没作弊，当看到理综的平均分渐渐迫近 270，成绩差的同学都慢慢超过我，我越发烦躁，而每当想到不到 100 天的倒计时，我都会产生呕吐感。有几个晚自习，我都完全无法沉下心来写作业，只能眼睁睁看着会议软件上同学们都埋头苦读，我却在电脑前颓废。那段时间里，我一直质疑——是否应该固执地设定一个目标学校，梦想对我来说，更多是像压力而非动力。 还好，之后就是开学。开学前，教育部忽然通知说高考延迟一个月，这给我吃了一颗定心丸，「一个月时间足够追赶了，对吧。」那时我这么想。 事实告诉我，追赶不需要一个月，只需要五天就够了。 开学考试算是一场彻底的失败，尽管我做好了心理准备，但在拿到那很难看的成绩后依然非常难受。很有趣的是，这次考试的成绩比高三上最差的成绩还要差，但是也比高考好。嘛，这都是后话了。那次失败离下一次考试只有五天，不管是能力还是状态，我都只有五天时间来调整，我屏蔽了所有的，有关后果的思考。我做好了二诊彻底失败的准备，我也有充分的失败的借口。五天过去，二诊考完，出成绩时我发现，我的二诊又成功了，甚至比一诊达到的高度还要高。我享受着这个高度带来的正反馈调节。 二诊后的三诊，我真正意义上的做到了。当一个朋友跑来对我说：你他妈居然那么高？我意识到我真的把所有人都踩在了脚下，我真的走到了那个以往的自己根本不可想象的高度。第一名，这个梦一般的词汇在高考前最后一个月来到了我身旁，后来的几次模拟，我又拿了一次第一名，证明了那时的自己的实力，并且稳居 30 名以前。高考前我也自信满满，「我的理综，不可能翻车！什么叫做 flag 我不懂。」直到现在我都认为，那并不是毫无来头的傲慢，而是我本应该拥有的最健康的自信。 Chaper Ⅱ 也以一个足够令人满意的阶段作结，可接下来的故事将抹去我所有的傲慢。 BAD END?这个 BAD END 来的毫无根据，就如同我整个高三的提升一样。直到高考出成绩之前，或者说看到成绩之后，在拿到排名表之前，我都以为自己并没有太大的失误。我本希望自己能最平静地迎来结局，然后快快乐乐地坐上火车走向人生的下一站。 晚自习的课间，我时常走到教学楼的一角去。离学校不远处是火车东站，时常有列车从那里出发，驶向远方。我曾无数次幻想自己乘坐一辆列车去北京上大学。渐渐的，列车划破空气的声音，就和我的梦想绑定起来了，每当有列车呼啸而过时，那噪音成为了我的慰问品，虽然吵闹，我却不愿意带上耳塞。它总能提醒我不要忘记，我还有一个属于远方的梦，于是我又拿起笔，一边扯着头发，一边望着面前勾勾画画。 而，我曾拥有的过的梦都化为了吹向远方的风，我无力拥有无力抓住。看到史无前例最低的排名时我愣住了，然后笑了，然后，高三的记忆似乎被染成了黑色，为什么似乎人人都能实现自己的梦想，为什么只有我面临的是不断的失败？我根本无力反省，如果说能反省出来个什么，那我只能说是命运。这就是属于这个人的 BAD END，意料之外，也在我认为的情理之外。 最终的转折与这段故事的 ending如同许多精彩的剧本一样，在一段故事在结尾前给予主角最深的绝望，然后之前的，许许多多的并未被注意到的伏笔一下汇聚成全新的路，带领主角走向前方。 越想越巧，甚至觉得这不可能是一个巧合。 或者说，我是幸运的。 第一个伏笔是18 年年末的竞赛。这或许也是铺垫中最具重量的一者。那时，谁也不会想到，小小竞赛会在最后的升学上发挥这么大的作用。我并未抱有任何功利心去参加信息学竞赛，而 19 年教育部大笔一挥，取消自主招生时，无论是抱有功利心，想通过竞赛去清北的OIer，还是我这种对于其升学效益无所谓的OIer，竞赛奖状都只是一张无关痛痒的奖状了。（严格来说，对于绝大部分此类人） 在「看似」堵死了竞赛的希望之后，第二个伏笔出现了。那是 19 年我连续参加的国科大，上科大，南科大夏令营。最初我只是对新型大学有点兴趣，而且想出门溜达溜达，就顺势参加了这三个夏令营。 第三个伏笔是我的零诊一诊二诊成绩。（在提交上科大申请的时候并没有考三诊）。虽然这三次诊断性考试的结果都挺好看，当时我想的却是「诊断性考试除了给点信心，到底有什么用？反正这个分数又不会计入高考」。 班主任时常说，高考考察的并不仅仅是你的文化课水平，而是——这三年里，你到底学到了多少成长了多少。 高考结束之后，我眼睁睁看着自己的原本广阔的路被压缩。从一开始的，由分数铺陈的路被一瞬间颠覆，我原本梦想的南大，北邮，完全遥不可及。去南科大的希望也因为机试发挥一般而最终被抹去。我抹着眼泪，坐在地上哭泣。母亲在高考刚结束的时候，一次散步中给我说。「在今年的高考形式下，你要做好充分的准备，这或许是你整个高三最差的一次，但是你依然得做出选择。」我在和朋友闲聊时提到这句话，「我妈这不是在给我浇冷水么？」 但是，真当自己被迫走入这个死胡同时，我偶然抬头发现，似乎还有一个通往更高处的梯子——上科大给予我的具有极大分量的加分。 这个所谓「极大分量」，照应了我做出的所有准备。第一轮简历筛选，我认识的人绝大多数都没通过，第二轮，面试筛选。这我不清楚，但是我只记得几个送分题我回答的比较好，比如「选南科大还是上科大啊？」「选西交还是上科大啊？」。当然，回答是 YES，但是光一个 YES 的回答显然是不够的，给出判断后还需要给出 Why。母亲所提醒我的，充分的准备，这时候就起效了。结果出来后，我甚至不敢相信自己拿到了 B档加分（20000 人中选 2000，2000 人中选 500）——上科大太给我面子了吧？ 面子不是白给的。如果没有竞赛的经历，我或许根本没法通过初审。如果没有参加多个新型高校夏令营，我或许根本没法拿到 15 的加分，因为参加夏令营代表了我对这所学校存在极大的兴趣（事实如此）。如果没有诊断性考试的优秀成绩，或许上科大会认为我是一个不太会学习的学生。因为，15分，它给的真的太多了，以至于能够照亮死胡同里的我，让我走向前方。 我从来就不是一个纯粹的功利主义者，我并不想卷入广大学生的 GPA 战争中，或许上科大真的看到了我对 OI 的初衷，也看到了我为了什么而努力。「卷」似乎真的是一个难以突破的东西，所以胜者会得到「突围者」的称号。// 这是我之后添加的，或许与上文没什么关系吧。 After Story现在看来，高三的所有成功不过是梦一场，没有小说般的因果，却也骤然结束，迎来了一个似乎圆满的结局。不过啊，你看，如果将高三上的状态作为故事的开头，所有的故事，都是以困境开始，以顺境结束。这么说，这个在 events 中处于奇数位置的高考，会不会只是一个开头而非结尾？我也许可以任性到认为高考就是高中生活的 BE，但是灿烂的花火本身就是以漆黑与滚烫作为起点，以璀璨绽放作为终点，而非以一些原料为起点，被装在漆黑的包装里为终点。或许吧，现在的我，只是不知所措地站在一个前所未有的宏大的故事的起点上，这个故事不会以考试来评判我是否胜利，也不会短短半年就划上句号。我似乎一直沉迷于对失败的开头进行计数——中考啊，竞赛啊，高考啊，却忽略掉了曾经的每一个故事都有一个令人开心的 HE 呢。在这个并不可爱的高三后，我或许会迎来一个更加精彩而挑战的未来吧。","categories":[{"name":"Daily","slug":"Daily","permalink":"http://kr2.moe/categories/Daily/"}],"tags":[{"name":"瞎写","slug":"瞎写","permalink":"http://kr2.moe/tags/瞎写/"}],"author":"TraceBack"},{"title":"OI 与其高考数学应用","slug":"OIwithMath","date":"2020-04-25T06:58:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2020/04/25/OIwithMath/","link":"","permalink":"http://kr2.moe/2020/04/25/OIwithMath/","excerpt":"假的标题…","text":"假的标题… Pro 01几位大学生响应国家的创业号召，开发了一款应用软件。为激发大家学习数学的兴趣，他们推出了“解题获取软件激活码”的活动。这款软件的激活码为下面数学问题的答案：已知数列$1, 1, 2, 1, 2, 4, 1, 2, 4, 8, 1, 2, 4, 8, 16, \\cdots$，其中第一项是$2^0$，接下来两项是$2^0, 2^1$，再接下来三项是$2^0, 2^1, 2^2$，依此类推。求满足如下条件的最小整数$N:N &gt; 100$且该数列的前$N$项和为$2$的整数幂。那么该款软件的激活码为（ ） A B C D 440 330 220 110 高考中的新题的解法，往往都可以联系到 OI 上去。我们称此题最终构造的数列为$A$，处理$A$这个整体会不方便，想到每一个子数列为$B$，则$A$为$n$个$B$首尾相接，且最后还会有一段剩余序列$C$，于是有 $$A:\\underbrace{[2^0]}_{B_1}, \\underbrace{[2^0, 2^1]}_{B_2}, \\underbrace{[2^0, 2^1, 2^2]}_{B_3}, \\cdots, \\underbrace{[2^0, 2^1, 2^2, \\cdots,2^{n - 1}]}_{B_n}, C$$ 注意到，若对此数列求和，$S = \\sum_{i = 1}^{n}{\\sum{B_i}} + \\sum{C}$，若求$\\sum{B_i}$，对于高中数学，可以用差比数列求和方式。对于OIer，可以发现$B_i$与二进制的关系，即$\\sum{B_i} = 2^i - 1$，则$\\sum_{i = 1}^{n}{\\sum{B_i}} = 2^{n + 1} - (n + 2)$。此时能够想到，若$S = 2^k, k \\in \\mathbb{N^+}$，则 $$\\sum{C} - (n + 2) = 2^k - 2^{n + 1} \\Rightarrow \\sum{C} = 2^{n + 1}(2^{k - (n + 1)} - 1) + (n + 2)$$ 很显然，若$k &gt; n + 1$，有$\\sum{C} &gt; B_n$，与$C$的定义冲突，故$k = n + 1$，$\\sum{C} = n + 2$，假设$C = B_t$，满足$\\sum{C} = 2^t - 1$ 对于考场做题，对于整体的数列$B$总共占位$(n^2 + n)/2$，分别带入选项，可得$29 \\times 29 + 29 = 870$，剩余为$5$，则$5 + 3 = 2^3$，满足条件，其余检验略（我记得有优化）。欸，有点记不到当初做题时候怎么排除选项的了，先这样吧（结尾水）。 Pro 02定义”规范01数列“${a_n}$如下：${a_n}$共有$2m$项，其中$m$项为$0$，$m$项为$1$，且对于任意$k \\le 2m, a_1, a_2, \\cdots,a_k$中$0$的个数不少于$1$的个数，若$m = 4$，则不同的”规范01数列“共有多少个？ 第一次见这题是在 mgt 博客上，第二次见是小题狂练，mgt 博客给出的方法是 dp，小题狂练给出的方法是枚举。经同桌尝试，纯粹的枚举在考场上基本不可行。是否有一种，容易想到，且容易计算的方法，能够优雅地解决这个选择压轴题？ 首先，对于$a_n$的前缀和数列$S_n$，满足$S_k \\ge 0$，且$S_{2n} = 0$（将数列中的$0$看成$-1$）。对于 OIer 们容易想到$f[i][j]$，最后取$f[n][0]$，但是抽象的$f[i][j]$不适合打草稿——这是初始的想法。当然，对于没有 OI 的文化课选手，其实也能想到该方法（比如我，我个人是先想到该方法再想到 dp 的），详见 16 年 Ⅱ 卷的选择题第五题。本题是 16 年 Ⅲ 卷的选择题，这解法上微妙的巧合，不得不让人兴奋。 首先的首先，需要画一个坐标系。如图： 然后就做完了。 看到$(8, 0)$的点，其对应的值是$14$，此题答案$14$。每一个点$(i, j)$对应的横坐标的意义是，这个数列长度为$i$，而$j$的意义是，此时前缀和为$j$。则$(8, 0)$表示，长度为$8$的数列，其中$0, 1$个数（计算过程中的$0, -1$）相等。每一个点，其值都等于其左上的点与左下点值的和，因为数列长度增长一，要不然前缀和加$1$，要不然$-1$。 当然，还有一个办法，卡特兰数列，画图的方式也和卡特兰数列的计算方式类似。","categories":[{"name":"Math","slug":"Math","permalink":"http://kr2.moe/categories/Math/"}],"tags":[{"name":"Learning","slug":"Learning","permalink":"http://kr2.moe/tags/Learning/"}],"author":"TraceBack"},{"title":"Winter Vacation","slug":"winter-vacation","date":"2020-02-04T07:54:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2020/02/04/winter-vacation/","link":"","permalink":"http://kr2.moe/2020/02/04/winter-vacation/","excerpt":"寒假编译的$\\LaTeX$文档，就当一个练习吧","text":"寒假编译的$\\LaTeX$文档，就当一个练习吧","categories":[],"tags":[{"name":"Learning","slug":"Learning","permalink":"http://kr2.moe/tags/Learning/"}],"author":"TraceBack"},{"title":"004","slug":"004","date":"2019-12-31T15:20:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2019/12/31/004/","link":"","permalink":"http://kr2.moe/2019/12/31/004/","excerpt":"","text":"2019/12/31 杂记好了，新年贺图做完了，本来想动态起来的，结果没水平，只好水了张静态的。 提起我 2020 年的主题，自然是高考。2020 将被分为两个部分，第一个 20，是「我的高考」，第二个 20，是「我的大学」。如果将竞赛看作我的第一次青春，这就是第二次青春的起点与终点与再出发。这一年会经历很多事——虽然每一年都是这样的，那就请让我期待吧，期待自己的改变，并期待世界的改变。","categories":[{"name":"Design","slug":"Design","permalink":"http://kr2.moe/categories/Design/"}],"tags":[],"author":"TraceBack"},{"title":"003","slug":"003","date":"2019-11-24T15:22:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2019/11/24/003/","link":"","permalink":"http://kr2.moe/2019/11/24/003/","excerpt":"","text":"","categories":[{"name":"Design","slug":"Design","permalink":"http://kr2.moe/categories/Design/"}],"tags":[],"author":"TraceBack"},{"title":"送给自以为是的大人","slug":"tenkinoko","date":"2019-11-08T16:02:03.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2019/11/08/tenkinoko/","link":"","permalink":"http://kr2.moe/2019/11/08/tenkinoko/","excerpt":"——世界为什么会回归原有的样子","text":"——世界为什么会回归原有的样子 这可能是我第一次在看完电影之后立马写简评。显然，这样会引出不少 emotional 的结论，不过，天气之子的内核在兴奋过去后可能就会淡化了吧。 本质上是杂谈，所以就别纠结篇章结构了。 果然，ioa 能对上电波的作品我大多都能对上。（笑） 天气之子是做给特定时间段的特定的人们看的。包括我。我可能在曾经的博客中提到过，我受 flcl 影响不小。可惜我的那段故事的结局并不是 HE，我一直很后悔那时候做出了所谓「现实」的「抉择」。 LR 说，天气之子显然是商业片。我倒要反弹琵琶，这是诚哥向小众审美小众视角迈出的一步。虽然这步不一定成功，或者说并不一定优秀，但是至少观众们都能感受到。 看完电影后的第一感觉就是，「真的好叛逆啊。」叛逆到甚至有点扯淡，离家出走——到结局都没有仔细交代离家出走的原因，枪，哇，居然还开枪，躲逃警察的追捕，哇，还带打人的么，这结局是什么啊，居然还带淹了世界的（这篇简评我可能不会涉及这部份剧情表达的中心）。 显然的，「叛逆」本身就会打乱大部分观众的电波。我在看到一半时也吐槽，扯淡，扯淡。坐在旁边的陌生的大概是高中生的女孩看完也在嚷嚷，怎么这么扯的啊。旁边的自以为是的大人也这么说——她是那个陌生女孩的母亲，估计吧。诚哥考虑到了这点，如果他真想做出不折不扣的商业片，他会像你的名字那样，避免过于激进的剧情。 可是，还是要恰饭的。诚哥恰饭的本钱就是画面。这么说似乎也不准确。诚哥是以画面为食活下去的。从对生活的细致观察，诚哥的画面中处处表现着世界的温柔。从锲而不舍地画雨滴落下，再在水中溅起，每一帧都是匠人的追求。 回到之前所谓「激进」的话题。诚哥这部作品里有 flcl 的影子。比如「骑摩托的大姐姐」，flcl 本身就是日系作品中青春的代名词，当骑摩托的大姐姐出现时，诚哥想要表现的核心（之一）已经明确了。青春的内核在本作中的体现是什么？叛逆，泪水，恋爱，欢笑。那些自以为是的大人们，与在称为大人的途中自以为是的年轻人们啊，那些叫嚷着「不要自负」的大人啊。 新海诚还是那个长不大的孩子，在讲述着一些长不大的孩子的故事。 ///后面是乱写了 激进的必然性，与青春 骑摩托的帅气大姐姐 没有丢掉的手铐 被大水淹没的东京 他作品中的人总是凭一己之力改变着世界 那个混混哥也有妻子和孩子 圭介大叔为了躲避警察抛下了帆高 而又为了帆高打倒了警察 大人们或许还是孩子 世界为什么会回归原有的样子 睡了。 这篇肯定会改，但不是今天。","categories":[],"tags":[],"author":"TraceBack"},{"title":"001","slug":"001","date":"2019-10-20T03:53:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2019/10/20/001/","link":"","permalink":"http://kr2.moe/2019/10/20/001/","excerpt":"","text":"","categories":[{"name":"Design","slug":"Design","permalink":"http://kr2.moe/categories/Design/"}],"tags":[],"author":"TraceBack"},{"title":"今日的改动","slug":"add-comment-system","date":"2019-10-12T16:04:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2019/10/12/add-comment-system/","link":"","permalink":"http://kr2.moe/2019/10/12/add-comment-system/","excerpt":"添加了评论系统。","text":"添加了评论系统。 貌似还有一些 bug，不过我先懒得管了。已经将近一年没摸过 CSS 和 HTML 了，还能改改前端也是不容易。先说起因吧。起因就是考试考的太差，跑去吃包子，吃完包子路上看到优衣库，想着自己缺🕊衬衫，逛了半天结果买了条浅蓝色的衬衫，不过因为我腿短看起来一般般。回家后完全无心学习。于是就开始搞博客。 Valine 的设计风格还是很舒适的，添加起来也比较简单。搞好 LeanCloud，然后加一发 appId 和 appKey 就好。然后就出问题了，头像部分没有对齐。看了看 F12，这个 theme 自带的 CSS 规定了 img 的对齐，于是 Valine 的头像对齐就歪了。说来老早之前我添加 gitment 的时候也出现了这个问题。然后加句 :not(img.vimg)，就解决了。 q姐提到说 Valine 国内版本需要备案，于是最好用国外版，需要注意。 之后又听说 Valine 出了阅读量统计功能，窝又加上了。一开始 id 项我用的 post.title，结果可能是编码的缘故（？），一直 404。改成 url_for(post.path) 之后就好了哎。趁机也熟悉了一下 hexo 的渲染机制。 &lt;span id=&quot;&lt;%- url_for(post.path) %&gt;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;文章阅读量统计&quot;&gt; &lt;em class=&quot;post-meta-item-text&quot;&gt; 阅读量 &lt;/em&gt; &lt;i class=&quot;leancloud-visitors-count&quot;&gt;0&lt;/i&gt; &lt;/span&gt; 后来想着添加字数统计功能，查了一圈，只查到 hexo-wordcount，我也懒，就干脆用现成的。结果一 npm，整个 node_modules 莫名其妙挂了，各种报错，然后又只能重新 npm install。想了想，添加在了 meta 部分，但是分隔符没做好？折腾 CSS 失败。也总算折腾结束了。 上周瞎构思了一下无后端博客系统。我记得冰河姐用 github api v3 做过一个？高考结束了我也开个坑吧。 代码块渲染貌似还有问题。暂时不解决了。 嘛，晚安。","categories":[{"name":"CS","slug":"CS","permalink":"http://kr2.moe/categories/CS/"}],"tags":[],"author":"TraceBack"},{"title":"有感而发","slug":"Feeling20191003","date":"2019-10-03T14:43:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2019/10/03/Feeling20191003/","link":"","permalink":"http://kr2.moe/2019/10/03/Feeling20191003/","excerpt":"有关《Dimension ~w~》","text":"有关《Dimension ~w~》 我一直是这么想的—— 无论看多少作品，我总脱离不了一些所谓鄙视链低端的低级趣味，所谓被「人设」吸引。 现在想想，我喜欢的作品中，多少是因为我对某一名角色产生了感情，或男主帅气，或女主可爱，嗯… 这种偏爱会产生带入感，而这带入感终究会转化为那股怅然若失的感情，而怅然若失是阻碍我理性评价的最大因素之一。 我果然还是感性的，很少被剧情本身打动——剧情对我来说终究乏力，反而去注重作品中人与人之间的感情，不断地回味，不断地回味，最终产生了对作品的感情，然后，明明是「不到 8 分」的作品我偏要去打个 9 分。 ——恩。 ——然而这到底是人设的功劳还是剧情的功劳？当然，都有。不过这个回答不能让我满意。我不断地思考这个问题。 刚刚摸鱼看完 Dimension ~W~，又是那种怅然若失的感觉。「可能是因为发糖不够么」 其实一开始就是冲着女主去的，班上 lzy 在放，于是我就跟着他们看，「啊，女主真可爱，剧情也还行，好吧我去看吧。」然后就莫名奇妙被安利了。 多少作品是这样？莫名奇妙被安利。记得当初玩 ISLAND 只是在微博上看到了动画化的消息，于是就去玩了，最终收获了意想不到的惊喜。向日葵的教会与长长的暑假？也是看到别人玩，我就跟着去了。NOT LIVES？貌似只是看见 bgm 列表里有人在看，于是我就去看了，然后还蛮对电波。反而，许多直接被安利的作品，我反而对不上电波。不仅仅是作品的原因吧。为什么别人的安利基本没成功过？为什么我刻意去 bgm 列表寻找的作品总是不够让人满意？ 所谓「可遇而不可求」，tty 如此总结。这个问题就留给我继续思考吧。 顺带一题，Dimension W 真好看。如果要理性评价，这部作品不够优秀，但是我看的很爽，那就够了。","categories":[{"name":"Daily","slug":"Daily","permalink":"http://kr2.moe/categories/Daily/"}],"tags":[{"name":"瞎写","slug":"瞎写","permalink":"http://kr2.moe/tags/瞎写/"}],"author":"TraceBack"},{"title":"restart","slug":"restart","date":"2019-09-21T16:14:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2019/09/21/restart/","link":"","permalink":"http://kr2.moe/2019/09/21/restart/","excerpt":"","text":"因为高三了，没时间折腾，我的 VPS 需要关闭一年，那期间 daily blog 寄存在 mgt 或 lr 的 server 上。而这个技术博客，我花了一个晚上的时间部署到了 netlify 上。算是 restart 吧？ 顺带还折腾了 mathjax，「数论」那篇的公式渲染依然有问题。本以为是 mathjax v3 的锅，结果只是博文格式的一些问题。之后国庆再来解决吧。 我删除了基本所有的博文，之后大概率会加回来，不过现在就让博客干净一点，因为那些博文质量实在不高，基本都是 OI 期间水的。 下周上八天课。啊啊啊啊啊啊 闲扯就到这里。 TraceBack. 2019/09/22","categories":[{"name":"Daily","slug":"Daily","permalink":"http://kr2.moe/categories/Daily/"}],"tags":[{"name":"瞎写","slug":"瞎写","permalink":"http://kr2.moe/tags/瞎写/"}],"author":"TraceBack"},{"title":"五彩斑斓的 OI","slug":"colorful_oi","date":"2019-07-15T02:31:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2019/07/15/colorful_oi/","link":"","permalink":"http://kr2.moe/2019/07/15/colorful_oi/","excerpt":"仅此献给那段时光。","text":"仅此献给那段时光。 听 mgt 说，火车上特别适合写些东西，然而我又没什么可以写的，想来想去，还是补完去年十二月就停笔的 OI 记吧。 事后再回忆，很多事情往往会变得更精彩。对于 OI 也同样，自从去年十二月被坑掉 WC 名额，我就一直在逃避有关 OI 的话题。我在 OI 方面是一个失败者，在高潮还未开始时就已戛然停止。看着 HH 和 swk 参加 NOI，心里其实蛮不是滋味。然而，是时候写一篇 OI 记了，已经快一年了，我有写一篇 OI 记的必要了，如果事后留下的仅仅是精彩的回忆，那 OI 的滋味岂不少了一份丰富。 之前我是写过一段有关 OI 期间的回忆的，但是由于时间有些久远，更重要的是，我在写那篇文章时，OI 期间最精彩的日子还没到来。 仅此献给我的 OI 时光。 距离上次进入 OI 教室也只有一周的时间，但是那些人已经开始陌生起来。他们开始进行省选培训，而我仅仅是在补课期间进去自习而已，不仅仅是羡慕他们能再翘掉半年的文化课时间，更是对自己 OI 生涯短暂的扼腕叹息。 我在 USAC 游记中也提到过，我 OI 生涯最大的遗憾就是，没能出省进行大型的比赛，没能在 APIO 和 HH、ioa、青蛙子、q姐面基。因为身在强校，我一直窝在学校里享受优质的教学资源，于是，每天早晨开始的考试，下午的评奖，晚上短短的摸鱼时间变成了我的日常，从开始集训到集训结束，虽然我吃的很多，体重依然减了 10 斤以上。 杂记我给雷哥，CBR打了招呼，然后坐在自己的座位上。我的座位在最后一排，从左向右数第四个，当然，我不是因为想要摸鱼才选择最后一排的，只是因为觉得那个位置很清净，还不用承受冷到爆炸的空调的洗礼。 教室的里的空调一直是一个传说，去年暑假，哪怕是最热的时候，教室里的温度也不超过 25 度，所以我进教室通常会披一件皮肤衣。 谈到摸鱼，有段时间，每天晚上我会给自己半个小时到一个小时看漫画，有一次被老师看到，吓得差点从座位上跳起来。还有一次，L 同学去吃饭了，忘记关他的摸鱼界面，我给他拍下来发给他，说我不帮他关，让他自己回教室关。教室背后的窗帘永远是拉上的，因为玻璃反光，那些摸鱼的同学不仅脸上会反射着奇妙颜色的光，而当 W 老师进教室时，背后的玻璃也能把他们出卖。 整个教室，有不少人的电脑运行内存比别人多了一倍以上，而在那些特殊的电脑里，我的电脑又是最特殊的之一。现在想来都是运气好。大概是在一年前，老师给所有人的电脑换上了 win 7，因为一开始的 xp 实在是难用。换上的那一天，我在电脑上装上了网易云，VSCode 还有一些常用的软件。第二天来的时候，忽然发现我装上的东西都没有被删掉，因为电脑是安装了还原卡的。后来问 W 老师，老师说，第一次重启时不会启动还原卡。可能是因为那天塞了过多需要开机启动的东西，我的电脑成了班上开机最慢，每次早晨到校，我会按开机，然后去厕所蹲一会儿，回来后差不多该开机结束了。 xp 的电脑曾经困扰了我很久，因为 xp 实在是太难用了… 因为 xp 系统的原因，我用了大半年的 sublime text，直到装上 win 7，我才享受上 VSCode 和 Clion，Clion 的代码背景着实好看，有一段时间我用发热巫女的一张专辑背景做代码背景，结果 W 老师不满意了，于是我就换回了 VSCode，用的 EvaTheme，mgt 推荐的，着实好看，还有 Fira Code。关于编译环境，我因为编译环境问题（DevCpp GDB 支持太差），不到万不得已不用 gdb 调试，一直用 luogu IDE 进行输出调试。每次写完代码，都扔到 luogu IDE 上运行。 闲杂的事情就谈到这里，如果还有想起什么，之后再补充吧。 有关去年暑假开始前的 OI 生活，我并没有什么印象。只记得在 NOIP 2017 中拿了 40 分，18 年年初的所有校内比赛基本都爆零，在 SCOI 2018 中拿了 40 分——当时我连树状数组都不会打。三月高高兴兴去电子科大参加比赛，本以为能基本 AK，结果爆零。现在想来也应该，那时的我基本什么都不会，所有的进步都是在 18 年 7 月放假之后开始的。 其实那段故事也是一个教训，是操之过急的后果。因为选手水平不一，我早早地跟着其他的选手学了很多省选知识点，包括 LCT，FFT，网络流，DP 优化等等，然而联赛知识点都不熟悉，何谈省选？代码能力不足，思维能力不足，仅仅学会无数的知识点，却不会使用。 四月，我开始进行专题学习。不知道出于什么原因，我对线段树和 DP 莫名恐惧，可能是因为所有的 DP 题都做不出来，导致我直到联赛前都害怕 DP 题（其实现在也有点）。也可能是因为曾经被线段树难题虐爆，我也迟迟没敢学习线段树，现在想来其实很可笑。我组织大约三十道题，包括 wuvin 处传下来的线段树题，一道一道开始做。在线段树的学习中，我发现自己善于总结，从几十道线段树题中抽离出数据结构题的套路以及本质，也总结了不少主席树，树套树的题（那时我还没有意识到我应该专注于联赛）。五月，我开始做 DP 的专题。幸运的是，最终联赛我并没有翻车在动态规划的题目上（D1T2）。 六月七月，学校开始集训。 自此，“OI 与我”的故事已经结束，而 intro 则是那场考试，后来的日子，我将其命名为“五彩斑斓的 OI”。 五彩斑斓的 OI不论是我初中的文化课的技术爆炸，还是高中物理的学习的提升，都源于某一次考试。初二下时有一次，我考了年级 20 名，自那次之后，我的成绩便突飞猛进，高中物理学习也是如此。有一次周考，我莫名其妙考了满分，从那次开始，我的物理水平一路飙升。 mgt 的那句话我很赞同，努力学习，并且接受反馈是一件很幸福的事情，而成绩的步进是一种良性循环，从考好，到高兴，到虚荣心驱动自己再次想要考好。虽然我并不乐意承认，偶然的一次考好是我进步的直接原因，但是这的确是我在”看山还是山“时期的回忆吧。 但是，并不是每个人都有好运气，也并不是每个人都有一次偶然考好的机会。成绩的测量是客观的，尽管有其不准确性。从成功的原因中抽离出核心的话，我认为是”自信“吧。许多人的成功是不可复制的，但我认为，自信引导的成功并非不可复制，在我身上，已经被 ctrl + v 三次了。 六月一次，似乎是因为难得的早睡，起床后的状态特别好，早早地来到学校和 JZO，LPA 打了招呼，趴在桌子上睡了一个小时。那天想必是天晴吧，不然我也不会有如此好的心情。就连老师过来宣布”今天要考试“都似乎不算什么了。老师把成绩单放在网上时，我颤抖地点开，却发现 XZK 的名字位于第二行，第一行是万年满分的 std 同学。那次考试我拿了 240 分，是我第一次上 100 分，是我第一次上 200 分，也是我第一次拿全班第一。与往常不同，我没有在意我是否能完完全全地做起每一道题，而是去在于我能否拿更高的分，果然，每道题都没有拿全分，但是每道题都有 80 分。 全班第一，全班第一，这个名词现在听起来其实很残酷，也很可笑。 为何可笑？其实我当初并不是全班第一，因为班级分为联赛班和省选班，省选班的同学都在楼上自习，我仅仅是联赛班第一而已。当 W 老师在班上问我，你是否要参加省选班时，我选择了联赛班。也是那次选择，代表我降级了梦想。如果在那时选择省选，就代表我要放弃之后的文化课学习，冒极高的风险，再停课大半年。我本认为，面对青春年华无需考虑”风险“二字，仅需委心任去留，但我终归面对了现实，那个曾经仰望星空的孩子也低下了头，为自己以往的颓废、错误的学习方法道歉。我至今无法接受我当初的选择，但是，如果如今的我再次面临相同的选择，我依然会选择面对现实，人往往会面对此类冲突，我让步了。 为何残酷？在最后，联赛班的同学一起补文化课时，我了解到，联赛班最终只有四个人拿到了一等奖。我，JZO， 还有两个我非常反感的同学。其中一个，每天电脑开机便是游戏，集训期间每天的游戏时间超过六个小时，而每天除考试外基本不会做题。另外一个，与前者同流合污，不谈他不善交际的问题，脑子里随时缺了一根筋，话里带刺，每次考试只要题简单，并且容易错，他的题目就会出现”文件错误“，我可以带着恶意猜测，他是怕做不对题被骂才故意改错的文件名么？不仅如此，他也满口不离游戏，每次玩游戏被逮的都是他。不怕得罪人，我可以愤慨地说，可怜那些努力却没能拿到一等的同学。但 OI 确实很大程度上是一种智力竞赛，人生无常。但是 OI 终归不是人生，以智商在 OI 中取胜，不代表能在所有的竞争中胜出，漫漫长路上，人格与人性才是成功的决定性因素。OI 中失利的同学们，请看向前方。 故事继续。 让我印象深刻的有一次下雨，碰巧，父亲出差，没法送我去学校，我只能和母亲两人坐地铁去学校。母亲也在市中心上班，离学校很近。出发时雨还不大，直到我下地铁，走到地铁口，我才发现不对劲。雨水哗啦哗啦从楼梯上淌下来，排水道里滴答滴答的雨滴声和流水声混杂在一起，有不少没带伞的年轻人在门口等待着雨变小。我带了一把大伞，母亲则是因为怕重随身带着一把太阳伞。在老天爷发威时，太阳伞当然不管用。没等走五步，母亲的伞已经翻着断了，我只能和她互换。那太阳伞也太可怜了，在大风中毫无作用，我将伞贴在身上倒着御风而行，周围全是湿淋淋的上班路中的年轻人们，被大风大雨吹打地毫无形象可言。也不知道自己是怎么到学校的，反正当我踏进教室时，浑身都在滴水，出发时被我寄以厚望的篮球鞋也里里外外湿透了，要知道，这鞋子常在雨中走，却从未湿过袜子。托坐在最后一排的福，我那天整天是脱了鞋子踩在地上考的试，尽管旁边的学长看到我脱鞋，尴尬地对我笑了笑。顺带一提，那天的考试也算顺利。 再之后呢？时长一个月的集训也结束了，我回到家。坚持着每天做题。 再之后就是电子科大的集训。那段时间承载着我 OI 期间最美好的回忆，有泪水，也有奋斗。最幸福的不过是每天放学后买一杯奶茶，回到酒店里打 OSU，然后出去吃顿香香的黄焖鸡，接着回酒店写代码。酒店里看不到电子科大。夏天是成都的雨季，今年也一样。那段时光被我放在了“NULL”中，有缘的读者应该能看到吧。18 年的夏天是我的 Summer Pocket，是最珍贵的宝物，而我现在也已经写尽了我脑中的那段时光，无法在思绪中剥离出更多的细节和故事。离开“鸟白岛”时，我并没有意识到自己的不舍，转眼就是金秋九月。 回到文化课的班上，又要和班主任斗智斗勇了。第一次斗智斗勇是四月，省选前，班主任不允许我停课，而我非要停课，经过一番对峙，还算达成了和解，他最终允许我带电脑到学校去学习，并且允许我去机房。他不同意我停课，很大程度因为他班带的班上很少有竞赛一等奖的学生，他也不相信我能拿到竞赛一等奖。任何学生都无法和他讲理，他认为自己是绝对正确的，就算你能写出陈情表都没法说服他，唯一能动摇他的，就是利益，和极高的成功的可能性。但是这里我要提一句，这里所指的利益，不是他的利益，而是我的利益，他说到底是一个负责任的老师，只是负责任的方式不太令人赞同罢了。我截图下我所有的成绩表，挑选其中考的比较好的打印给他看，不断陈述自己搞竞赛搞好的可能性之高，并且描述竞赛搞好后有多少优惠，经过一番辩驳后，他最终同意我在国庆直到联赛停课。第一个月的文化课学习还算顺利。十月，停课正式开始。 停课生活并没有什么很精彩的故事，也和暑假的集训期间相同，到校，睡觉，考试，评奖，考得好就继续刷题，考的差就开始颓废。晚自习看看漫画，看看轻小说，十点回家后听听歌，十一点睡觉。这便是我停课期间的日常。 但是如果仅仅描述就很无趣。 就如同我 OI 的排名是全国 1k 多一样，数字有多大，就含有多少故事，多少泪水。如果学校仅仅是拿数字出去宣传，就淡化了这个数字的意义，教育学生变成了++i，青春被抽象为了数字 1。数字是 OI 中努力的附属品，而不是 OI 的一切，分数也同样。384 不算高分，失误也不少，但是 384 等于我的图论总结，我的 DP 总结，等等等，还有我的 OI 人生之和，NOIP 考试过程中的激活的每一个神经元都是我 OI 集训期间的一段时光，都是我的青春。那参考的 OI 人数，每一个 1 都对应一个人，对应一个颓废的人，对应一个聪明的人，对应一个努力的人。OI 不仅仅是我的青春，是全中国，全世界千千万万 OIer 的青春，OI 如此有魅力，也是因为此吧。停课期间的每个“day x 总结”也一样，“最终集训”文件夹中的上百个文件，每个文件都对应我的一段时光，对应着我的努力和泪水，在此角度下，文件也不再仅是对硬盘中二进制数据的抽象。 再次踏入 UESTC 集训期间的楼时，已经是三个月后了，踌躇满志地打开 IDE，面临最终的挑战，要说紧张也难免，但是激动更胜一筹。那天晚上，我看完了 PA 三部曲中的 Tari Tari。 迈出 UESTC 校门的时候象征着我 OI 时期的终结，并没有多少波澜起伏，就这么平静地结束了。在集训期间我少多次恐惧那一刻，但是真到那时，那份恐惧也涣然冰释了。和同学们最后吃了一次饭，便挥手道别。 OI 再见。 人 &amp; 人这段很难写。 我之前描述的都是基本完全从我个人角度出发的故事，是独奏，接下来就是合奏了吧。 OI 期间最精彩的，便是我认识的那些人了。 这份后劲至今还留存着，我在退役后大半年又因为 OI 认识了 ioa 姐，一个很有趣的人。他和我喜欢的作品也类似，爱好也类似，这是缘分，他们是 OI 留给我的礼物，他也是 HH 留给我的礼物吧… 如果你在现在询问我，我当初选择 OI 后悔么？我定会做出与广大 OIer 相同的回答——不后悔，这不是废话么。不光是感谢 OI 给予我的时间，更是感谢 OI 给予我的那些朋友。 所谓“网友”的关系，也因为 OI 变得不同。 17 年 8 月，中考失利，我出远门旅行。当时我还是个东方众，于是就因为同喜欢东方，并且同学习 OI 认识了 LR 和 mgt。我正巧发现他俩也认识，就把他们拉进了一个群里，当时群里就我们三个人，每天一起聊天，刷题。 但是说起来，我最早认识的其实是青蛙子吧，因为我记得我和他谈过“马上就要体考”的话题。那个小群转眼间变成了我的精神寄托，开学后，我一拿到手机，第一件事就是打开 TIM，和他们聊上两句。渐渐转向十一月，OIer 们毕业的日子。mgt 拿了一等就退役了，我觉得很可惜。LR 则失利。只拿了一个二等奖。我三等奖都没拿到，想着反正才学习了几个月，也没有感受到压力。 某一个周六集训的早上，我在 github 关注中发现了一个奇怪的 id，“q234rty”，$q \\uparrow 2 \\rightarrow 3 \\rightarrow \\ 4 \\downarrow r \\rightarrow t \\rightarrow y$，居然是键盘上连着的一串，我想，这个人有点个性。于是点进他的 github 主页，也没怎么在意，就继续做题学习了。直到后面有一天，我再次点开了他的 github 主页，并且找到了他的博客，一看，这人怎么这么强啊？！拿了那么多牌？还参加了 NOI？分数这么高？我才发现我的 github 关注中居然有如此的神仙，正巧，那时找到了他的 qq，我就加了他，我那时的 qq id 和 github id不同，他居然认出了我。之后，我一直背着群里的各位叫他 q 姐，并且问他 OI 学习的问题。后来认识的就是 HH 了吧。我不太记得请我是怎么认识 HH 的，可能是看到他在我的一篇博客下的评论吧，我也是这么认识 ioa 的。刚认识他时，他才学 OI 不久，很多代码都调不来。没想到今天都已经参加 NOI 了，我还是颇为感慨。再后来就是纸夜姐，jjj，纸夜姐、jjj我都是在网易云上认识的，我也记不得为啥我当初要拉他们到群里去，总觉得这是天意，总之结果是，我们都相处的很不错。 这里我本想写很多我们之间的事，想想最终还是决定保留在心底，所以”人 &amp; 人”篇会显得有些不完整。 时过境迁，LR 和 mgt 都已成了大学生，我，HH 和 ioa 都成了高三学生，群里也基本不会聊算法了。这个小群已陪伴了我快两年。 在我写这篇文章时，HH 已经绝笔了吧，我为曾有这样一个朋友而自傲，同时我也恨他。 不知道你们看到这段会怎么想。 总之，谢谢。 后记写了三个多小时，总算把这份长久的遗憾给弥补了，虽然有许多不满意的地方。 现在是 2019/7/15 10:45，火车正行驶在陕西境内。离北京还很远，希望这次旅行能够顺利吧。","categories":[{"name":"Daily","slug":"Daily","permalink":"http://kr2.moe/categories/Daily/"}],"tags":[{"name":"Memories","slug":"Memories","permalink":"http://kr2.moe/tags/Memories/"}],"author":"TraceBack"},{"title":"Math Theory","slug":"math_theory","date":"2018-07-30T04:40:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2018/07/30/math_theory/","link":"","permalink":"http://kr2.moe/2018/07/30/math_theory/","excerpt":"数论这真的是一篇很长的数论笔记。有不少问题。 数论全笔记","text":"数论这真的是一篇很长的数论笔记。有不少问题。 数论全笔记 基础知识 整除 素数判定 线性筛 互质 约数 调和级数 余数 最大公约数和最小公倍数 欧拉函数 唯一分解定理每个数，都可以唯一被分解成$p_1^{c_1}p_2^{c_2}…p_n^{c_n}$的形式，其中$p_i$是素数。 互质$a$, $b$互质，即没有公共的质因子。即在唯一分解后，所有的$p_i$不相同。 整除通常有两种写法…这份笔记中，所有的都依照后面一种。 若$a ; mod ; b = 0$，则$a$能被$b$整除，或$b$能整除$a$，写作$a | b$ 若$b = ka$，记为$b$被$a$整除，$a$整除于$b$。写作$a | b$。 绕一绕的话…$n = km$，读作$m$整除$n$，$n$被$m$整除，$m | n$，$|$的前后顺序依照$x$整除$y$的形式…绕一绕…过一会儿就绕好了~总之记住，小的放前面，大的放后面。 整除的性质是一切证明的关键，这里给出： $a | b, a | c$，则有$a | (b \\pm c)$。 素数判定若一个数$N$是合数，一定存在$T \\leq \\sqrt{n}$，且$T$能整除$N$。 反证法，假设命题不成立，那么一定存在$T &gt; \\sqrt{n}$且$T | N$。那么一定存在$\\frac{N}{T} \\leq \\sqrt{n}$且$\\frac{N}{T} | N$。则命题成立~ 代码为试除法 inline bool prime(ll val) { for (int i = 2; i &lt;= sqrt(val); ++i) if(val % i == 0) return false; return true; } 线性筛普通筛法略过了，我们讲讲线性筛。 线性筛$O(n)$的原理是，使每个数只被自己最小的质因子筛一次。 都知道$a \\in N$，$b$是质数，那么$a \\cdot b$一定不是质数。我们令每个合数只被自己最小的质因子$p$筛出来，那么每个合数只会被筛一次.我们对于每一个数$a$，用$a$去乘上$\\leq a$的所有质数。接下来给出，到每个数的时候，它一定被筛过的证明。 这里是我万年理解不到的…别的教程也不提这个…so郁闷,请把这一段认真看完…我尽量保证了语言没问题。 我们的筛法是，标记某个小于其本身质数 $\\times$ 某个小于其本身的合数。那么，假设，在进行那个“小于其本身的素数”的处理的时候，我们枚举了所有小于其本身的合数，而那时的$break$规则是$prm[j] * val &gt; n$，这个数一定是$\\leq n$的，所以其一定被筛过。这种反向思考很赞，但是别人为啥都不提这一点呢。但是啊，普通筛的时候，这么看吧！假如说当前的数可以被分解成$p_1^{c_1}…$，那么它会被所有的$p$筛一次，而某个数的素因子的个数是$\\log{n}$级别的，那么复杂度$n\\log{n}$。线性筛保证每个数一定只会被其最小的质因子筛过一次，根据上面的描述，已经足够了，所以线性筛的复杂度是$O(n)$。 代码如下 inline void prime() { for (int i = 2; i &lt;= n; ++i) { if(!vis[i]) prm[++cnt] = i; for (int j = 1; j &lt;= cnt; ++j) { if(i * prm[j] &gt; n) break; vis[i * prm[j]] = 1; if(i % prm[j] == 0) break; } } } 代码的顺序和刚才思维的顺序略有不同，而这正好是线性筛的妙处啊！ 尝试一下，并不好实现的思维题 「ep1」 质因数分解$N!$。这样看~ 利用线性筛的思路，我们每个合数只被其最小质因子筛一次。 我们知道一个数的质因数分解形式后，用这个数乘上一个质数，能够知道计算结果的质因数分解形式。我们对结果的形式累乘，就是答案~不优化的话，时间复杂度和空间复杂度都是$O(n\\log{n})$，实现也会很复杂。仅练习思维。 「ep2」 求$[L, R]$的质数个数。$L, R \\leq 2^{31}, R - L \\leq 10^{6}$。可以筛$R - L$的，那么我们先把$[2, \\sqrt{R}]$之间的数筛出来，这里的数一定可以组合出$[L, R]$的所有数。然后对于所有质数，我们进行$[L, R]$的标记。$vis[i \\times p] = 1, i \\in [\\frac{L}{p}, \\frac{R}{p}]$。 调和级数并不能给出详细的解答，总之记住公式，$\\sum_{i = 1}^{n}{\\frac{n}{i}} = n\\ln{(n+1)} + nr$。$r$为欧拉常数，约等于$0.5772156649$，所以遇到形如$\\sum_{i = 1}^{n}{\\frac{n}{i}}$的算式，在时间复杂度中通常记作$n\\log{n}$，或$n\\ln{n}$。我习惯前者。调和级数通常用作时间复杂度的证明。 约数下面介绍一点约数常用定理。 定义$N$。 约数的定义为$d | N$，d为约数。 可以简单发现，$p_i$是$N$的约数，也就是说，$p_1^{c_1}p_2^{c_2}…p_n^{c_n}$的子集都是其一个约数。 假设$N$进行唯一分解后的数是$p_1^{c_1}p_2^{c_2}…p_n^{c_n}$。 $N$的正约数的个数 $=\\prod_{i = 1}^{m}{(c_i + 1)}$。乘法原理 $N$的正约数和为$\\prod_{i = 1}^{m}{(\\sum_{j = 0}^{c_i}{(p_i)}^j)}$。手玩~ $N$的正整数约数集合是试除法，这里不再赘述…还有一个求法。 对于数字$d$，$d$一定是$d \\cdot k$的约数。这样筛下来，复杂度是$O(\\sum_{i = 1}^{n}{\\frac{n}{i}})$。利用调和级数，$O(n\\log{n})$。比$O(n\\sqrt{n})$要好得多。 余数$a ; mod ; b = c$，称$c$是$a$除以$b$的余数。余数的定义式如下 $a ; mod ; b = a - \\lfloor \\frac{a}{b} \\rfloor \\cdot b$看一个例题：$BZOJ1257$。 「ep3」求$\\sum_{i = 1}^{n}{k ; mod ; i}$。转化题目，求$\\sum_{i = 1}^{n}{(k - \\lfloor \\frac{k}{i} \\rfloor \\cdot i)} \\Rightarrow k \\times n -\\sum_{i = 1}^{n}{(\\lfloor \\frac{k}{i} \\rfloor \\cdot i)}$。由于复杂度的问题，我们从$\\frac{k}{i}$入手，因为会有一段区间，使得其不变。我们设$\\lfloor\\frac{k}{i}\\rfloor = x$。这段区间的值是$\\frac{(i_{first} + i_{end}) \\times (end - first + 1)}{2} \\times x$。所以问题来了，我们需要快速获取什么区间内，$\\lfloor\\frac{k}{i}\\rfloor$不变。结论如下，我也不知道怎么推的。$i \\in [x, \\lfloor \\frac{k}{\\lfloor \\frac{k}{x} \\rfloor} \\rfloor]$时，$\\lfloor\\frac{k}{i}\\rfloor$不变。$x$是上一个的右端点 + 1，即这次的左端点，这是数论分块的经典写法。具体请见代码，lyd的代码如下： #define ll long long #define R register #include &lt;bits/stdc++.h&gt; using namespace std; ll n, k, ans; int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k); ans = n * k; for (int l = 1, r; l &lt;= n; l = r + 1) { r = k / l ? min(k / (k / l), n) : n; ans -= (k / l) * (l + r) * (r - l + 1) / 2; } printf(&quot;%lld&quot;, ans); } 「ep4」求$\\sum_{i = 1}^{n}{\\sum_{d | i}{d^2}} ; mod ; p$，$n \\leq 10^{12}, p \\leq 10^9$首先，$\\sum{i ^ 2} = \\frac{n(n + 1)(2n + 1)}{6}$，是公式，至于怎么用，下面通过这道题来解释。 首先注意到，枚举$i$是不现实的。$10^{12}$不可能。我们转换思维，枚举$d$。 对于$d \\leq n$，$d$的倍数的个数为$\\lfloor \\frac{n}{d} \\rfloor$，每次的贡献是$\\lfloor \\frac{n}{d} \\rfloor \\cdot d^2$,对整体进行数论分块，对于$\\sum_{i \\in [L, R]}{i^2} = \\frac{R(R + 1)(2R + 1)}{6} - \\frac{(L - 1)(L)(2L - 1)}{6}$，我们对于$\\lfloor \\frac{n}{d} \\rfloor$相同的整体进行计算，然后套数论分块模板~ // by kririae #define ll long long #include &lt;bits/stdc++.h&gt; using namespace std; ll n, mod, ans; inline ll fast_pow(ll a, ll p) { ll ans = 1; a %= mod; for (; p; p &gt;&gt;= 1) { if(p &amp; 1) ans = (a * ans) % mod; a = (a * a) % mod; } return ans; } inline ll inv(ll a, ll p) { return fast_pow(a, p - 2); } inline ll calc(ll val) { static ll _inv = inv(6, mod); val %= mod; return (((((val * (val + 1)) % mod) * ((val &lt;&lt; 1) + 1)) % mod) * _inv) % mod; } int main() { scanf(&quot;%lld%lld&quot;, &amp;n, &amp;mod); for (ll l = 1, r; l &lt;= n; l = r + 1) { r = (n / l) ? min(n / (n / l), n) : n; ans = (ans + (n / l) * ((calc(r) - calc(l - 1) + mod) % mod)) % mod; } printf(&quot;%lld&quot;, ans); } 复杂度是$O(\\sqrt{n})$。 简单总结下这道题过程中出现的问题… calc(r) - calc(l - 1)出现了负数。 逆元求太多次，忘了加static。 注意mod的问题。 逆元的问题我会在后面提到。 最大公约数和最小公倍数定义：若存在$d$，$d | a$且$d | b$，$d$中最大的一个就是$gcd(a, b)$，$(a, b)$的最大公约数。若存在$a | m$且$b | m$。$m$取值最小的一个被称作$lcm(a, b)$，$(a, b)$的最小公倍数。 特别的，给出另一种$gcd$的理解方式。将$a, b$进行质因数分解，这俩重叠的部分就是$gcd(a, b)$。下面的证明将会用到。这种理解方式会被用到大量的证明中去。 最大公约数性质如下，$gcd(a, b) = gcd(b, a)$，$gcd(a, 0) = a$，$gcd(a, 1) = 1$, $gcd(ak, bk) = k \\cdot gcd(a, b)$，$gcd(a + kb, b) = gcd(a, b)$，若$gcd(a, b) = 1$, $gcd(ab, k) = gcd(a, k) \\cdot gcd(b, k)$。 给出最后一条的证明，这里会用到$gcd$的另一种理解方式~。 证明：$k = \\prod{k_i^{f_i}}$,$a = \\prod a_i^{q_i}$,$b = \\prod b_i^{s_i}$ ,则根据定义：$gcd(a, k) = \\prod a_i^{min(q_i, f_i)}$ ，$gcd(b, k) = \\prod b_i^{min(s_i, f_i)}$ ，又$a$, $b$互质，所以不存在$a_i = b_i$,则$ab = \\prod a_i^{q_i} \\cdot \\prod b_i^{s_i}$，从而$gcd(ab, k) = \\prod a_i^{min(q_i, f_i)} \\cdot \\prod b_i^{min(s_i, f_i)} =gcd(a, k) \\cdot gcd(b, k)$。$Q.E.D$ 倒数第二条的证明我将在更相减损术处提到。 有定理，$gcd(a, b) \\times lcm(a, b) = a \\cdot b$。令$d = gcd(a, b)$，$x = \\frac{a}{d}, y = \\frac{b}{d}$。则$gcd(x, y) = 1, lcm(x, y) = x \\cdot y$。则$lcm(x, y) \\cdot d = \\frac{a \\cdot b}{d}$。 更相损减术，定理如下，$gcd(a, b) = gcd(b, a - b) = gcd(a, a - b)$。欧几里得算法，$gcd(a, b) = gcd(b, a ; mod ; b)$。由于更相损减术是欧几里得算法的特例，这里给出欧几里得算法的证明。若$a &lt; b$，易得$gcd(a, b) = gcd(b, a)$。若$a \\geq b$，不妨设$gcd(b, a ; mod ; b) = gcd(a - nb, b)$，$n$为任意整数。设$a = nb + k$，根据定义，有$k = a ; mod ; b$。对于公约数$d$，有$d | a$，$d | nb$。则$d | (a - nb)$。$d | k$，所以$d | b, d | a ; mod ; b$.，公约数集合相同，所以最大公约数相同。备注一句，因为$d$对于所有公约数都成立，所以说公约数集合成立，这是证明中的常见手段。 代码如下： int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } 「ep5」给出$a_0, b_0, a_1, b_1$，求满足$gcd(x, a_0) = a_1, lcm(x, b_0) = b_1$的$x$的个数，$a, b \\leq 10^9 $朴素算法如下，我们知道，$x | b_1, b0 | b1$，$a_1 | x, a0 | a_1$,某个数的约数个数大约$2 \\sqrt{n}$，我们枚举$b_1$的约数$x$，然后$check$是否满足$gcd(x, a_0) = a_1, lcm(x, b_0) = b_1$。具体来说，我们用搜索算法组合出$b_1$所有的约数，然后判断条件是否满足，可过，代码懒得给了qwq颓颓颓 机智的算法先咕咕咕着… 欧拉函数之前提到过，对于$gcd(a, b) = 1$的情况，我们称$a, b$互质，互质的另一种解释方法是：$a = \\prod{a_i^{q_i}}$，$b = \\prod{b_i^{e_i}}$，所有的$a_i != b_i$。也就是${a} \\cap {b} = \\emptyset$。对于三个及更多，互质称作“两两互质”，即所有的数没有公共质因子。 欧拉函数，定义为$[1, n]$中和$n$互质的数的个数，记作$\\varphi(n)$。 $\\varphi(n)$有以下公式： $$\\varphi(n) = n \\cdot \\prod_{(prime;p) | n}{(1 - \\frac{1}{p})}$$ 证明： 设$p$为$n$的质因子，则$p | n$，而$kp \\leq n$的所有$kp$都不与$n$互质。而$kp$有$\\lfloor \\frac{n}{p} \\rfloor$个，而$q$为$n$质因子，$kq$有$\\lfloor \\frac{n}{q} \\rfloor$个，而$pq$的倍数又被重复计算，所以$n$中含有$\\lfloor \\frac{n}{pq}\\rfloor$个重复计算的，需要剔除。$[1, n]$中不含$p, q$为质因子的数的个数是$n - \\frac{n}{p} - \\frac{n}{q} + \\frac{n}{pq} = n(1 - \\frac{1}{p})(1 - \\frac{1}{q})$。同理可得。代码如下：注意精度问题，需要特殊处理。 inline int phi(int n) { int ans = n; for (int i = 2; i &lt;= sqrt(n); ++i) if(n % i == 0) { ans = (ans - ans / i); while(n % i == 0) n /= i; } if(n &gt; 1) ans = ans - ans / n; return ans; } $\\varphi$函数的性质有： $[1, n]$的数中和$n$互质的数的和是$\\frac{n \\cdot \\varphi(n)}{2}$。就是$gcd(a, n) = 1$，$a$的和。由九章算术，$gcd(n, a) = gcd(n, n - a)$。所以我们要求出$(n, n - a)$的平均数，手玩可得，平均数为$\\frac{n}{2}$。 若$a, b$互质，则$\\varphi(ab) = \\varphi(a) \\cdot \\varphi(b)$。这是积性函数的性质，积性函数我将会在后面进行讨论。设$a = \\prod{a_i^{c_i}}$,$b = \\prod{b_i^{d_i}}$。则$\\varphi(a) = a \\cdot \\prod_{i \\in {a_i}}{(1 - \\frac{1}{i})}$，$\\varphi(b) = b \\cdot \\prod_{i \\in {b_i}}{(1 - \\frac{1}{i})}$。又${a_i} \\cap {b_i} = \\emptyset$，则$\\varphi(a) \\cdot \\varphi(b) = ab \\cdot \\prod_{i \\in {a_i}}{(1 - \\frac{1}{i})} \\cdot \\prod_{i \\in {b_i}}{(1 - \\frac{1}{i})}$，且$\\varphi(ab) = ab \\cdot \\prod_{i \\in ({a_i} \\cup {b_i})}{(1 - \\frac{1}{i})}$，得证。写公式好累。通过这个性质，可以$O(n)$预处理$\\varphi$值。这个先不忙。 $n$为质数时，$\\varphi(n) = n - 1$。这个没必要解释吧QwQ $\\sum_{d | n}{\\varphi(d)} = n$。这条的证明已经折磨了我一个小时了…可以用狄利克雷卷积来证明。有一个初等证明，但还是不简单。对逻辑要求极高。证明：首先，对于分母为$b$，分子为$a$，$a &lt; b$的既约分数，假如说固定$b$的取值，那么$a$的取值有$\\varphi(b)$种。关于这道题，我们考虑所有的$\\frac{i}{n}, i \\in [1, n]$，将其约分，对于约分后的分数$\\frac{a}{b}$，一定有$gcd(a, b) = 1, b | n, a | i$且$a &lt; b$。假定一个$d | n$，那么在之前的分数集合中，以$d$为分母的既约分数个数就有$\\varphi(d)$个。而$|$分数集合$| = n$，所以$\\sum_{d | n}{\\varphi(d) = n}$$Q.E.D.$举个例子来演示一下吧对于$6$，我们构造出了$\\frac{1}{6}, \\frac{1}{3}, \\frac{1}{2}, \\frac{2}{3},\\frac{5}{6}, \\frac{1}{1}$。这其中，以$1 | 6$为分母的有$\\varphi(1)$个，也就是$\\frac{1}{1}$。以$2 | 6$为分母的有$\\varphi(2)$个，也就是$\\frac{1}{2}$。以此类推，我们可以发现，分母$d$的取值只有$d | n$，而$\\varphi(i)$的和正是前面分数集合的大小。真是妙极了 $n = \\prod{p_i^{c_i}}$，则$f(n) = \\prod{f(p_i^{c_i})}$。首先，易得，$gcd(p_i^{c_i}, p_j^{c_j}) = 1$，满足积性函数，则易证。 若$p | n$，则有$\\varphi(p \\cdot n) = \\varphi(n) \\cdot p$ 反之，$\\varphi(p \\cdot n) = \\varphi(n) \\cdot (p - 1)$。因为$p$是质数，且$p \\nmid n$(?)，所以$gcd(p, n) = 1$。有$\\varphi(p) = p - 1$，由积性函数性质可证明。对于$p | n$，带入定义式，$\\varphi(n) = n \\cdot \\prod_{(prime;p) | n}{(1 - \\frac{1}{p})}$，因为$p | n$，所以直接在前面的$n \\cdot p$，得证。（好方法啊 欧拉函数拓展$O(n)$递推证明参见刚才的最后俩条 inline void phi(int n) { for (int i = 2; i &lt;= n; ++i) { if(!vis[i]) prm[++cnt] = i; for (int j = 1; j &lt;= cnt; ++j) { if(i * prm[j] &gt; n) break; vis[i * prm[j]] = 1; if(i % prm[j] == 0) { phi[i * prm[j]] = phi[i] * prm[j]; break; } else phi[i * prm[j]] = phi[i] * (prm[j] - 1); } } } 狄利克雷卷积和莫比乌斯反演初步$Dirichlet$定义如下：$qwq(n) = \\sum_{d | n}{f(n)g(\\frac{n}{d})}$ 。简化记为$qwq(n) = f(n) * g(n)$。我只会这点（逃 同余同余的定义如下，$a ; mod ; m = b ; mod ; m$，则称$a, b$同余，写作$a \\equiv b ; (mod ; m)$ ，a \\equiv v \\ (mod \\ m). 对于$i \\in [0, m - 1], {a + km}$，$i ; mod ; m = a$。这是$; mod ; m$下的同余类。模数$x$的同余类有$x - 1$个，构成完全剩余系。 $[1, m]$中$gcd(i, m)$，$i$组成的集合叫做简化剩余系$S$。设$a \\in S, b \\in S$，由欧几里得算法可得$gcd(a \\cdot b, m) = 1 \\Rightarrow gcd(a \\cdot b ; mod ; m, m) = 1$。则$a \\cdot b \\ mod \\ m \\in S$。 欧拉定理欧拉定理的定义如下：如果$gcd(a, n) = 1$，则$a^{\\varphi(n)} \\equiv 1 \\ (mod \\ n)$。我并不会证明。欧拉定理可以推导出费马小定理。费马小定理如下：若$p$是质数，则$a^p \\equiv a \\ (mod \\ p)$。我也不会证。 欧拉定理有重要推论，$a^b \\equiv a^{b \\ mod \\ \\varphi(n)} \\ (mod \\ n)$。若$a, n$互质。 关于欧拉定理的本质这里又要提到一个别人不常提到的东西了。这样测试：$a^{i} \\ mod \\ p$。循环节的长度一定是$\\varphi(p)$。但不一定是最小的。$5^i \\ mod \\ 13$的循环节是$5 \\ 12 \\ 8 \\ 1$，长度为$4$，$\\varphi(13) = 12$。$4 |12$。然后，之后会在拓欧降幂处提到。 「ep6」求$a^{b^{b^{b…}}} \\ mod \\ (10^{9} + 7)$，$b$有$n$个。$a, b \\leq 10^{16}$。首先需要知道，后面挂着的那一坨该怎么处理。我们看$b^b$的本质是什么？$b^b = \\underbrace{b \\times b \\times \\cdot\\cdot\\cdot \\times b}_{b}$。转化为$a^{a^{b - 1}} \\ mod \\ (10^9 + 7)$。根据费马小定理$a^{p - 1} \\equiv 1 \\ (mod \\ p)$。所以$a^{a^{b - 1}} \\equiv a^{(a^{b - 1}) \\ mod \\ (p - 1)} \\ (mod \\ p)$。不懂这一步的话可以考虑$1$哪去了。然后用快速幂解决。 拓(扩)展欧几里得算法拓欧的定理如下$ax + by = gcd(a, b)$。而我们就是要解这个不定方程。 问题来了，如何解?根据欧几里得算法，有$ax + by = bx’ + (a \\ mod \\ b)y’ = gcd(a, b) = gcd(b, a \\ mod \\ b)$。而根据之前提到过的模数的定义，$a \\ mod \\ b = a - \\lfloor \\frac{a}{b} \\rfloor \\cdot b$，得出$ax + by = bx’ + (a - \\lfloor \\frac{a}{b} \\rfloor \\cdot b)y’$。化简得到$ax + by = ay’ - b \\cdot (x’ - \\lfloor \\frac{a}{b} \\rfloor \\cdot y’)$。我们令$x = y’, y = x’ - \\lfloor \\frac{a}{b} \\rfloor \\cdot y’$。当$b = 0$时，$x = 1, y = 0$。因为$ax = gcd(a, 0) = 1$。 $$代码如下 inline void exgcd(int &amp;x, int &amp;y, int a, int b) { if(b == 0) return x = 1, y = 0, void(); else return exgcd(y, x, b, a % b), y -= (a / b) * x; } 注意，由$bezout$定理可得，$exgcd$必定有整数解。简单解释一下代码，由于写成递归形式，某一层和上一层的$x, y$是反过来的。就有$y -= (a / b)*x$，对应原本的算式是$y = x’ - \\lfloor \\frac{a}{b} \\rfloor \\cdot y’$。 「ep7」BZOJ1407 Savage推完公式后…出了各种各样的问题…干脆面向题解。 公式如下：$c_i + xp_i \\equiv (c_j + xp_j) \\pmod{M}$.如果存在解，那么可以有两个同一时刻在同一位置。转换为$x(p_i - p_j) - km = c_i - c_j$。首先判定有无整数解，如果有的话，$x \\leq min(l[i], l[j])$。因为在死亡之后碰面不做数~ 代码如下 // by kririae #include &lt;bits/stdc++.h&gt; using namespace std; inline void exgcd(int &amp;x, int &amp;y, int a, int b) { if(b) exgcd(y, x, b, a % b), y -= (a / b) * x; else x = 1, y = 0; } inline int gcd(int a, int b) { return b ? gcd(b, a % b) : a; } int n, c[20], p[20], l[20]; inline bool judge(int M) { for (int i = 1; i &lt;= n; ++i) for (int j = i + 1; j &lt;= n; ++j) { int a = p[i] - p[j], b = c[j] - c[i]; a = (a % M + M) % M; int g = gcd(a, M); if(b % g == 0) { // 有解 int x = 0, y = 0; exgcd(x, y, a, M); x = ((x * (b / g)) % (M / g) + (M / g)) % (M / g); if(x &lt;= min(l[i], l[j])) return false; } } return true; } int main() { scanf(&quot;%d&quot;, &amp;n); int mx = 0; for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d%d&quot;, &amp;c[i], &amp;p[i], &amp;l[i]), mx = max(mx, c[i]); for (int M = mx; M &lt;= 1e6; ++M) if(judge(M)) return printf(&quot;%d&quot;, M), 0; } 乘法逆元多数时候用于处理除法带$mod$的情况，$\\frac{a}{b} \\equiv a \\cdot \\mathrm{inv}(b) \\pmod{m}$。$\\mathrm{inv}(b)$就是$b$的逆元。逆元存在的前提是：…先不说这个，我们用丢番图方程的整数解来证明。上式可以化为$a \\equiv ab \\cdot \\mathrm{inv}(b) \\pmod{m}$。再次化简得到$b \\cdot \\mathrm{inv}(b) \\equiv 1 \\pmod{m}$。$b \\cdot \\mathrm{inv}(b) - km = 1$。此方程当且仅当$gcd(b, m) = 1$时有解，进而推导$b$在$mod \\ p$意义下的乘法逆元当且仅当$gcd(b, m) = 1$时存在。第一种方法，对于逆元存在的时候，可以求$exgcd$。从而得出逆元。 还有一种解法，当$p$为质数时，利用费马小定理：$b^p \\equiv b \\pmod{m}$。$b \\cdot b^{p - 2} \\equiv \\pmod{m}$。所以$b^{p - 2}$是$b$在模$p$意义下的乘法逆元。代码分别是exgcd(x, y, a, p), return (x % p + p) % p。return fpow(a, p - 2, p)。 但是，还有一种球法！$inv[1] = 1, inv[i] = (p - \\lfloor\\frac{p}{i}\\rfloor) \\cdot inv[p \\ mod \\ i] \\ mod \\ p$。 写成代码是这样 for (int i = 2; i &lt;= n; ++i) inv[i] = (p - p / i) * inv[p % i] % p; 前两种复杂度是$O(log{n})$,最后一种是$O(n)$，不常用。 顺带一提，$inv(b, p) = inv(b \\ mod \\ p, p)$，不然用个锤。因为定义，$ax \\equiv 1 \\pmod{m}$。$ax \\ mod \\ m = a \\ mod \\ m \\cdot x \\ mod \\ m$。 线性同余方程给定$ax \\equiv b \\pmod{m}$。可以得到$ax + my = b$，有解当且仅当$gcd(a, m) | b$。方程的所有解是$\\ mod \\ \\frac{m}{gcd(a, m)}$和$x$同余的整数。 中国单身狗定理有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？ 中国单身狗定理要求以下方程组的解 $$\\begin{equation}\\left{ \\begin{array}{lr} x \\equiv a_1 \\pmod{m_1} \\ x \\equiv a_2 \\pmod{m_2} \\ \\cdots \\ x \\equiv a_n \\pmod{m_n} \\end{array} \\right.\\end{equation}$$ 其中，$gcd(m_1, m_2, \\cdots, m_n) = 1$。我被这玩意儿折腾半个月了，这里重新来认真搞一搞。 令$M = \\prod{m_i}$，$M_i = \\frac{M}{m_i}$。令$t_i$是$M_it_i \\equiv 1 \\pmod{m_i}$的一个解，（也就是$M_i$关于模$m_i$意义下的一个逆元。则$x$的唯一一组解是$x = (\\sum_{i = 1}^{n}{a_it_iM_i}) \\ mod \\ M$。 证明：因为$gcd(m_i, m_j) = 1$，所以$gcd(m_i, M_i) = 1$。所以，存在$t_i$，是$M_i$在$\\ mod \\ m_i$意义下的乘法逆元。即$t_iM_i \\equiv 1 \\pmod{m_i}$，可以得到$a_it_iM_i \\equiv a_i \\pmod{m_i}$，又$m_j | M_i$，所以$a_it_iM_i \\equiv 0 \\pmod{m_j}$。构造$x = \\sum{a_it_iM_i}$，所以满足$x = a_it_iM_i + 0 \\equiv a_i \\pmod{m_i}$。$Q.E.D.$ $EXCRT$ 中国EX单身狗定理（大雾相比$CRT$，$EXCRT$有个区别，$m_i, m_j$不一定互质。重新看方程： $$\\begin{equation}\\left{ \\begin{array}{lr} x \\equiv a_1 \\pmod{m_1} \\ x \\equiv a_2 \\pmod{m_2} \\ \\cdots \\ x \\equiv a_n \\pmod{m_n} \\end{array} \\right.\\end{equation}$$ 既然无法一次合并，那就考虑两两合并。 我们考虑前俩方程：$x \\equiv a_1 \\pmod{m_1}, x \\equiv a_2 \\pmod{m_2}$。转换成以下形式，$x = a_1 + k_1m_1, x = a_2 + k_2m_2$，减一下变成$k_1m_1 - k_2m_2 = a_2 - a_1$，根据某打起来太麻烦的定理，这里存在整数解的前提是$gcd(m_1, m_2) | a_2 - a_2$。然后解啊！用扩欧解出特解$k_1, k_2$。令$g = gcd(m_1, m_2), k_1’, k_2’$为俩特解，则$k_1 = \\frac{m_2}{g}t + k_1’, k_2 = \\frac{m_1}{g}t + k_2’$，带回原式：令$x_0 = a_1 + m_1k_1’$，$x \\equiv x_0 \\pmod{lcm(m_1, m_2)}$。 代码如下 // by kririae // 题解ver #define ll long long #include &lt;bits/stdc++.h&gt; using namespace std; inline void exgcd(ll &amp;x, ll &amp;y, ll &amp;g, ll a, ll b) { if(b) exgcd(y, x, g, b, a % b), y -= (a / b) * x; else x = 1, y = 0, g = a; } inline ll EXCRT(ll *_a, ll *_m, ll n) { ll a = _a[1], m = _m[1], g, x, y, mod; for (int i = 2; i &lt;= n; ++i) { exgcd(x, y, g, m, _m[i]); if((_a[i] - a) % g) return -1; x *= (_a[i] - a) / g, mod = _m[i] / g, x = (x % mod + mod) % mod; a = m * x + a, m = m / g * _m[i], a %= m; } return (a % m + m) % m; } const int maxn = 1e5 + 5; ll n, m[maxn], a[maxn]; int main() { cin.tie(0); ios::sync_with_stdio(false); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; m[i] &gt;&gt; a[i]; cout &lt;&lt; EXCRT(a, m, n) &lt;&lt; endl; } BSGS问题如下： 求解方程，$a^x \\equiv b \\pmod {p}$。其中$gcd(a, p) = 1$。 考场写不来BSGS咋办！暴力啊！ 由费马小定理可得，$a^{p - 1} = 1$，所以只用从枚举$[0, p - 1]$。 然后考虑，如何优化爆搜。这时候就要拉出我们可爱的分块妹子。 设$x = i \\cdot t - j$，其中$t = \\sqrt{p}$。$j \\in [0, t - 1]$。分块成功~方程转化为$a^{it - j} \\equiv b \\pmod{p}$。也就是$a^{it} = b \\cdot a^j \\pmod{p}$。注意$t$是定值，然后枚举$b \\cdot a^j$，插入$hash$方便查询。再枚举$a^{it}$，到$hash$表去查询。代码如下：（SDOI2011 计算器） // by kririae #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; inline void exgcd(ll &amp;x, ll &amp;y, ll &amp;g, ll a, ll b) { if(b) exgcd(y, x, g, b, a % b), y -= (a / b) * x; else x = 1, y = 0, g = a; } inline ll fpow(ll a, ll p, ll mod) { ll ans = 1; for (; p; p &gt;&gt;= 1) { if(p &amp; 1) (ans *= a) %= mod; (a *= a) %= mod; } return ans; } inline ll BSGS(ll a, ll b, ll p) { static map&lt;ll, ll&gt; fd; fd.clear(); int t = sqrt(p) + 1; b %= p; for (int j = 0; j &lt; t; ++j) fd[(b * fpow(a, j, p)) % p] = j; if((a = fpow(a, t, p)) == 0) return b == 0 ? 1 : -1; for (int i = 0; i &lt;= t; ++i) { ll val = fpow(a, i, p); int j = fd.find(val) == fd.end() ? -1 : fd[val]; if(j &gt;= 0 &amp; i * t - j &gt;= 0) return i * t - j; } return -1; } ll t, k, a, b, p, g, x, y; int main() { scanf(&quot;%lld%lld&quot;, &amp;t, &amp;k); switch(k) { case 1: while(t--) { scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;p); printf(&quot;%lld\\n&quot;, fpow(a, b, p)); } break; case 2: while(t--) { scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;p); exgcd(x, y, g, a, p); if(b % g) puts(&quot;Orz, I cannot find x!&quot;); else printf(&quot;%lld\\n&quot;, ((x * (b / g)) % p + p) % p); } break; case 3: while(t--) { scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;p); ll ans = BSGS(a, b, p); if(ans == -1) puts(&quot;Orz, I cannot find x!&quot;); else printf(&quot;%lld\\n&quot;, ans); } break; } } 线性基线性无关。 基的概念。 寻找线性基。 求出的线性基需要和原集合的选线性组合完全一致。 求线性基方法如下： 对于我新加入的某个数，我对它进行二进制的扫描，从高到低位。如果当前位$i$已经有一个线性基$a[i]$，那么我们可以认为，当前数如果要表示，一定选取了那个基，所以我们剔除基的影响，也就是$s[i] \\ xor \\ a[i]$。最后所得的$a[i]$就是所有的线性基。 #include &lt;bits/stdc++.h&gt; #define ll long long using namespace std; const int N = 1e5; ll n, mx, t, ans, s[N], a[N]; int main() { scanf(&quot;%lld&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%lld&quot;, &amp;s[i]); for (int i = 1; i &lt;= n; ++i) for (int j = 51; j &gt;= 0; --j) if(s[i] &amp; (1ll &lt;&lt; j)) { if(a[j] == 0) { a[j] = s[i]; break; } s[i] ^= a[j]; } for (int i = 51; i &gt;= 0; --i) ans = max(ans, ans ^ a[i]); printf(&quot;%lld&quot;, ans); } SCOI2016 幸运数字给出一棵树，每个结点都有一个值$a[i]$，求$i \\rightarrow j$路径上的异或最大值。$n \\leq 20000$ 倍增上跑线性基。对于每个点$f[i][j]$，存一个$vector$，表示从$i$向上$2^j$的线性基有哪些…每次用$merge$进行暴力合并。最后查询的时候，找到$lca(i, j)$，然后对于$i \\rightarrow lca(i, j)$，$j \\rightarrow lca(i, j)$的线性基进行合并。复杂度$O(n\\log^3{n})$。 再次跪拜q234rty神犇，没有他窝就A不了这道题。因为。 for (int i = 0; i &lt;= 60; ++i) if(b[i]) insert(b[i], a); 开始没加if。 第一种是树剖ver，复杂度$O(nlog^4n)$，不开O2跑不过。 #include &lt;bits/stdc++.h&gt; #define ll long long #define ls t[k].son[0] #define rs t[k].son[1] using namespace std; namespace BZOJ4568 { inline char gc() { static char buf[1 &lt;&lt; 18], *fs, *ft; return (fs == ft &amp;&amp; (ft = (fs = buf) + fread(buf, 1, 1 &lt;&lt; 18, stdin)), fs == ft) ? EOF : *fs++; } inline ll read() { register ll k = 0, f = 1; register char c = gc(); for (; !isdigit(c); c = gc()) if (c == &#39;-&#39;) f = -1; for (; isdigit(c); c = gc()) k = (k &lt;&lt; 3) + (k &lt;&lt; 1) + (c - &#39;0&#39;); return k * f; } const int N = 20005; struct Node { int l, r, son[2]; ll b[65]; } t[N &lt;&lt; 2]; int root, tcnt; ll g[N], w[N]; int n, q, head[N], ver[N &lt;&lt; 1], nxt[N &lt;&lt; 1], tot; int siz[N], son[N], fa[N], dep[N], id[N], top[N], cnt; inline void addedge(int u, int v) { ver[tot] = v; nxt[tot] = head[u]; head[u] = tot++; } inline void dfs1(int x) { siz[x] = 1, son[x] = 0; for (int i = head[x], to; ~i; i = nxt[i]) { if((to = ver[i]) == fa[x]) continue; fa[to] = x, dep[to] = dep[x] + 1; dfs1(to); if(siz[to] &gt; siz[son[x]]) son[x] = to; siz[x] += siz[to]; } } inline void dfs2(int x, int topf) { id[x] = ++cnt, w[cnt] = g[x], top[x] = topf; if(!son[x]) return; dfs2(son[x], topf); for (int i = head[x], to; ~i; i = nxt[i]) { if((to = ver[i]) == fa[x] || to == son[x]) continue; dfs2(to, to); } } inline void insert(ll x, ll *a) { for (int j = 60; j &gt;= 0; --j) if(x &amp; (1ll &lt;&lt; j)) { if(a[j] == 0) return a[j] = x, void(); x ^= a[j]; } } inline void merge(ll *a, ll *b) { for (int i = 0; i &lt;= 60; ++i) if(b[i]) insert(b[i], a); } inline ll gmax(ll *a, ll ans = 0) { for (int i = 60; i &gt;= 0; --i) ans = max(ans, ans ^ a[i]); return ans; } inline void pushup(int k) { merge(t[k].b, t[ls].b), merge(t[k].b, t[rs].b); } inline void build(int &amp;k, int l, int r) { k = ++tcnt, t[k].l = l, t[k].r = r; if(l == r) return insert(w[l], t[k].b), void(); int mid = l + r &gt;&gt; 1; build(ls, l, mid), build(rs, mid + 1, r); pushup(k); } inline void query(int k, int l, int r, ll *ans) { if(t[k].l == l &amp;&amp; t[k].r == r) return merge(ans, t[k].b), void(); int mid = t[k].l + t[k].r &gt;&gt; 1; if(r &lt;= mid) query(ls, l, r, ans); else if(l &gt; mid) query(rs, l, r, ans); else query(ls, l, mid, ans), query(rs, mid + 1, r, ans); } inline ll work(int x, int y) { static ll ans[65], tmp[65]; memset(ans, 0, sizeof(ans)); while(top[x] != top[y]) { if(dep[top[x]] &lt; dep[top[y]]) swap(x, y); memset(tmp, 0, sizeof(tmp)); query(root, id[top[x]], id[x], tmp); merge(ans, tmp); x = fa[top[x]]; } if(dep[x] &gt; dep[y]) swap(x, y); memset(tmp, 0, sizeof(tmp)); query(root, id[x], id[y], tmp); merge(ans, tmp); return gmax(ans); } inline void solve() { memset(head, -1, sizeof(head)); n = read(), q = read(); for (int i = 1; i &lt;= n; ++i) g[i] = read(); for (int i = 1, x, y; i &lt; n; ++i) { x = read(), y = read(); addedge(x, y); addedge(y, x); } dfs1(1), dfs2(1, 1), build(root, 1, n); for (int i = 1, x, y; i &lt;= q; ++i) { x = read(), y = read(); printf(&quot;%lld\\n&quot;, work(x, y)); } } } int main() { return BZOJ4568::solve(), 0; } 第二种是倍增ver，不开O2跑得过，复杂度$O(nlog^3n)$ #include &lt;bits/stdc++.h&gt; #define ll long long #define ls t[k].son[0] #define rs t[k].son[1] using namespace std; namespace BZOJ4568 { inline char gc() { static char buf[1 &lt;&lt; 18], *fs, *ft; return (fs == ft &amp;&amp; (ft = (fs = buf) + fread(buf, 1, 1 &lt;&lt; 18, stdin)), fs == ft) ? EOF : *fs++; } inline ll read() { register ll k = 0, f = 1; register char c = gc(); for (; !isdigit(c); c = gc()) if (c == &#39;-&#39;) f = -1; for (; isdigit(c); c = gc()) k = (k &lt;&lt; 3) + (k &lt;&lt; 1) + (c - &#39;0&#39;); return k * f; } const int N = 20005; struct Node { int l, r, son[2]; ll b[65]; } t[N &lt;&lt; 2]; int root, tcnt; ll g[N], f[N][25][65]; int n, q, head[N], ver[N &lt;&lt; 1], nxt[N &lt;&lt; 1], tot; int fa[N][25], dep[N]; inline void addedge(int u, int v) { ver[tot] = v; nxt[tot] = head[u]; head[u] = tot++; } inline void dfs(int x) { for (int i = head[x], to; ~i; i = nxt[i]) { if((to = ver[i]) == fa[x][0]) continue; dep[to] = dep[x] + 1, fa[to][0] = x; dfs(to); } } inline void insert(ll x, ll *a) { for (int j = 60; j &gt;= 0; --j) if(x &amp; (1ll &lt;&lt; j)) { if(a[j] == 0) return a[j] = x, void(); x ^= a[j]; } } inline void merge(ll *a, ll *b) { for (int i = 0; i &lt;= 60; ++i) if(b[i]) insert(b[i], a); } inline ll gmax(ll *a, ll ans = 0) { for (int i = 60; i &gt;= 0; --i) ans = max(ans, ans ^ a[i]); return ans; } inline ll lca(int x, int y) { static ll ans[65]; memset(ans, 0, sizeof(ans)); if(dep[x] &lt; dep[y]) swap(x, y); for (int i = 20; i &gt;= 0; --i) if(dep[fa[x][i]] &gt;= dep[y]) merge(ans, f[x][i]), x = fa[x][i]; if(x == y) return merge(ans, f[x][0]), gmax(ans); for (int i = 20; i &gt;= 0; --i) if(fa[x][i] != fa[y][i]) { merge(ans, f[x][i]), merge(ans, f[y][i]); x = fa[x][i], y = fa[y][i]; } merge(ans, f[x][0]), merge(ans, f[y][0]), merge(ans, f[fa[x][0]][0]); return gmax(ans); } inline void solve() { memset(head, -1, sizeof(head)); n = read(), q = read(); for (int i = 1; i &lt;= n; ++i) insert(g[i] = read(), f[i][0]); for (int i = 1, x, y; i &lt; n; ++i) { x = read(), y = read(); addedge(x, y); addedge(y, x); } dfs(1); for (int t = 1; t &lt;= 20; ++t) for (int i = 1; i &lt;= n; ++i) fa[i][t] = fa[fa[i][t - 1]][t - 1], memcpy(f[i][t], f[i][t - 1], sizeof(f[i][t])), merge(f[i][t], f[fa[i][t - 1]][t - 1]); for (int i = 1, x, y; i &lt;= q; ++i) { x = read(), y = read(); printf(&quot;%lld\\n&quot;, lca(x, y)); } } } int main() { return BZOJ4568::solve(), 0; } BZOJ2844给出集合$S$，将集合$S$的所有子集取出来，对于每一个子集求出其异或和，排序，放到数组$a$中，给出数$k$，求$a$在$a$中第一次出现的下标是？ 对于线性基的组合出来的集合$S_1$，我们把这个$S_1$分成两部分，第一部分是线性基，第二部分是由线性基组合出来的数字。假如$|S_1| = 2^n$，并且线性基有$m$个。对于查询的某一个数$j$，这个数一定可以由后面的$2^{n - m}$种组合再加上唯一的线性基的补全方案来组合。所以对于某一个数$j$，组合方案数和$j$是多少其实是无关的，所以只需要我们知道$j$在线性基的组合中排第几位。 重复一次，子问题就是求$j$是在线性基的所有子集的组合中的第几大。解决方式如下，对于$j$的每一位，假如说当前这一位$i$拥有一个$a[i] != 0$，那么我们可以称这一位是“流动”的。假如说不存在，那么一定选取了一个比它大的线性基。要理解这里还要明确“排序”的意义，假如说我选取了基$a_8$，那么对于第$8$位一定是选取了的。所以对于第$8$位的排序，一定是与流动的二进制位有关，这么看来，在集合$S_1$中的位置也只是由流动的二进制位决定的，对于数字$j$，我们抽离出所有的流动的二进制位，抽离的二进制位表示对应的$a$中的基的选取情况。因为选取更大的基，数字也就更大，所以二进制位的数值就是在$S_1$中的位置，最后套上$2^{n - m}$处理即可。 T3给出$n$个数，把这些数分成两部分，使得这两部分的异或和差最小。$n \\leq $ 数论函数补充以下公式都基于唯一分解定理。假设我们已经分解了$n$。除了莫比乌斯函数，之前的都提到过: $\\varphi(n)$，欧拉函数，$[1, n]$中和$n$互质的数的个数。 $\\sigma(n)$，$n$的正约数之和$\\prod_{i = 1}^{m}{\\sum_{j = 0}^{c_i}{p_i^{j}}}$。 $\\mathrm{d}(n)$，$n$的正约数个数。$\\prod{c_i + 1}$。 这几个的计算原理都很简单，就不给予证明了~。然后，如题，补充的是莫比乌斯函数和莫比乌斯反演，我们直接进入下一个版块。 莫比乌斯反演容斥原理某小学学的东西，$|A \\cup B \\cup C| = |A| + |B| + |C| - |A \\cap B| - |A \\cap C| - |B \\cap C| + |A \\cap B \\cap C|$。其实就是，首先算每个集合的大小，发现算重了旁边的，就减去，结果发现又算少了，又加上，这个思想在欧拉函数的计算上用到过。我们不如换个写法： $$|\\bigcup_{i = 1}^{n}{A_i}| = \\sum_{i = 1}^{n}{|A_i|} - \\sum_{1 \\leq i &lt; j \\leq n}{|A_i \\cap A_j|} + \\sum_{1 \\leq i &lt; j &lt; k \\leq n}{|A_i \\cap A_j \\cap A_k|} - \\cdots - (-1)^{n - 1}|A_1 \\cap A_2 \\cap \\cdots \\cap A_n|$$ 咕咕咕 矩阵乘法定义我不详细解释了，大概来说，是这个样子的：$c_{i, j} = \\sum_{k = 1}^{m}{a_{i, k} * b_{k, j}}$。 矩阵乘法的前提是行列必须对应另一个矩阵的行列。矩阵乘法满足结合律， 分配率，但是不满足交换律。注意，不满足交换律。 举个例子吧，最经典的题 「ep8」求斐波那契数列的第$n$项，$n \\leq 10^{18}$。$f[i] = f[i - 1] +f[i - 2]$。所以，可以构造矩阵如下： $$\\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \\\\end{bmatrix}\\times\\begin{bmatrix} f[n] \\ f[n - 1]\\end{bmatrix}=\\begin{bmatrix} f[n + 1] \\ f[n]\\end{bmatrix}$$ 我也不知道咋证，反正矩阵可以求快速幂。于是 $$\\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \\\\end{bmatrix}^n\\times\\begin{bmatrix} 1 \\ 1\\end{bmatrix}=\\begin{bmatrix} f[n + 1] \\ f[n]\\end{bmatrix}$$ 「ep9」求斐波那契数列前$n$项和，$n \\leq 10^{18}$。其实是差不多的，构造如下： $$\\begin{bmatrix} 1 &amp; 1 &amp; 0 \\ 0 &amp; 1 &amp; 1 \\ 0 &amp; 1 &amp; 0\\end{bmatrix}\\times\\begin{bmatrix} S[n] \\ f[n + 1] \\ f[n]\\end{bmatrix}=\\begin{bmatrix} S[n + 1] \\ f[n + 2] \\ f[n + 1]\\end{bmatrix}$$ 后面会有更多的题涉及矩阵，所以这个基础知识一定要搞好。我们来看一个矩阵 + 概率的题。 矩阵中的图论建模矩阵通常可以和图论中的邻接矩阵联系起来，看到图论的时候不妨往矩阵这里想一想。 「ep10」工作 (by ihopenot)$Ambiguous$是居住在$byte$镇的量子居民，$byte$镇可以看成是$n$个点，$m$条单向边的联通图。每天清晨，$Ambiguous$都会以$P_i$的概率出现在$i$号节点，之后由于工作原因，$Ambiguous$每小时会有一定概率移动。具体而言，$Ambiguous$如果在$i$号节点并且存在一条编号为$j$的边从$i$出发，那么她就有$p_j$的概率走这条边。可以保证从每个节点出发的边概率和不超过$1$，但不保证为$1$，如果$Ambiguous$没有走任何一条边，那么她就会留在当前节点。今天清晨来临之前$Ambiguous$突然想知道，今天工作结束后自己在每个节点的概率是多少。$n \\leq 300, m \\leq 100000, t \\leq 10^{18}$。 这道题算是矩阵优化的基础题目，虽然原题暴力也可过，但是$t \\leq 10^{18}$呢QAQ矩阵这么构造，最开始的矩阵 $$\\begin{bmatrix} P_1 \\ P_2 \\ P_3 \\ \\cdots \\ P_n\\end{bmatrix}$$ 每次转移的矩阵是题中构造的邻接矩阵，对于这个邻接矩阵$pow(t)$之后乘上原矩阵，这个矩阵中的每一个位置表示到达某个点的概率。因为$c_{i, j} = \\sum_{i = 1}^{k}{a_{i, k} \\times b_{k, j}$。所以最后的某个点的点权是 所以入边的概率之和，没问题qwq。 「ep11」给出一个满足对角线均为正数的非负矩阵，判断这个矩阵是否有某一次方为全正数矩阵。$n \\leq 1000$ (by ihopenot)首先一看，莫名其妙…考场上写的矩阵快速幂验算，想苟50，结果只苟到了20…下来听到有人说“不是图论建模么”，我心里一惊，然后反应过来了。哇这道题吹爆！！！首先，我们把$A$矩阵看成一个邻接矩阵，可以发现，转化为01矩阵之后是没有影响的。而矩阵的某一个位置$i, j$表示$i \\rightarrow j$有一条边。矩阵中所有全为正数，表示这个图全连通，而矩阵乘法之后，我们考虑乘法的意义是什么。写写就知道（其实我也是感性理解），乘出来的矩阵表示$i \\rightarrow j$经过$k$条边就几种方案。（？如果$a[i][j] = 0$，代表$i$不能到$j$。也就是$i, j$不处于一个$SCC$。$SCC!$，启发我了…不处于一个$SCC$的点，无论怎么搞都不会处于一个$SCC$，所以，对最开始的图求一个$tarjan$，看全部是否都处于同一个联通快中。 // 贼棒的图论建模 // by kririae #include &lt;bits/stdc++.h&gt; using namespace std; namespace IO { inline char gc() { static char buf[1 &lt;&lt; 18], *fs, *ft; return (fs == ft &amp;&amp; (ft = (fs = buf) + fread(buf, 1, 1 &lt;&lt; 18, stdin)), fs == ft) ? EOF : *fs++; } inline int read() { register int k = 0, f = 1; register char c = gc(); for (; !isdigit(c); c = gc()) if (c == &#39;-&#39;) f = -1; for (; isdigit(c); c = gc()) k = (k &lt;&lt; 3) + (k &lt;&lt; 1) + (c - &#39;0&#39;); return k * f; } } namespace Life { const int maxn = 1005; int n, t, a[maxn][maxn], dfn[maxn], low[maxn], cnt, tot; stack&lt;int&gt; s; bitset&lt;maxn&gt; vis; inline void tarjan(int x) { dfn[x] = low[x] = ++cnt; s.push(x), vis[x] = 1; for (int i = 1; i &lt;= n; ++i) { if(!a[x][i]) continue; if(!dfn[i]) { tarjan(i); low[x] = min(low[x], low[i]); } else if(vis[i]) low[x] = min(low[x], dfn[i]); } if(low[x] == dfn[x]) { int curr; ++tot; do { curr = s.top(); s.pop(); vis[curr] = 0; } while(curr != x); } } inline void solve() { using namespace IO; t = read(); while(t--) { memset(dfn, 0, sizeof(dfn)); memset(low, 0, sizeof(low)); memset(a, 0, sizeof(a)); while(!s.empty()) s.pop(); vis.reset(); cnt = 0; tot = 0; n = read(); int flag = 0; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) a[i][j] = read(); for (int i = 1; i &lt;= n; ++i) if(!dfn[i]) tarjan(i); if(tot == 1) puts(&quot;YES&quot;); else puts(&quot;NO&quot;); } } } int main() { return Life::solve(), 0; } 组合计数加法原理和乘法原理可以简单想想成一张图，如果图是这样的： $1 \\rightarrow 2, 1 \\rightarrow 2, 1 \\rightarrow 2 \\cdots$ 那么$1 \\rightarrow 2$的路径数就是所有边的总和，这就是加法原理。 如果图是这样的 $1 \\rightarrow 2, 1 \\rightarrow 2, 1 \\rightarrow 2 \\cdots$ $2 \\rightarrow 3, 2 \\rightarrow 3, 2 \\rightarrow 3 \\cdots$ $3 \\rightarrow 4, 3 \\rightarrow 4, 3 \\rightarrow 4 \\cdots$ 问$1 \\rightarrow 4$的路径和，就是每个关键点的路径条数的乘积，这就是乘法原理。 排列和组合$\\binom{n}{m} \\Rightarrow \\binom{n}{m}$。 写作$P_n^{m}$，表示从$n$个物品中取出$m$个排成一排，产生的不同的排列的数量为。$P_n^{m} = \\frac{n!}{(n - m)!}$，可以这么推导：第一次选，有$n$个，第二次选，有$n - 1$个，第三次选…以此类推，最后可以选的有$n - m +1$个。 写作$\\binom{n}{m}$，表示从$n$个物品中选取$m$个组成集合，产生的不同的集合的数量为。$\\binom{n}{m} = \\frac{n!}{m!(n - m)!}$。这么考虑，对于一个长度为$m$的序列，排列方式有$P_m^{m} = m!$。总数量除以排列数就是组合数。 组合数的性质 $\\binom{n}{m} = \\binom{n}{n - m}$。$\\binom{n}{m} = \\frac{n!}{(n - m)!}$，$\\binom{n}{n - m} = \\frac{n!}{(n - m)!}$。当然，对于组合数来说，硬核证明是不好的。从$n$个钟选取$m$个，剩下的组成一个补集。补集的取值情况和原集合是一一对应的。 $\\binom{n}{m} = \\binom{n - 1}{m} + \\binom{n - 1}{m - 1}$。硬核证明免了，谁都会带公式。我们考虑第$n$号元素选和不选，如果选了，剩下的情况是$\\binom{n - 1}{m - 1}$，如果不选，剩下的情况是$\\binom{n}{m - 1}$。 $\\sum_{i = 0}{n}{\\binom{n}{i}} = 2^n$。硬核证明也免了，谁都会带公式。公式等同于对$n$个数中选取任意多个数，也就是每个数有取或者不取，也就是$2^n$种情况。 额…之后统一写法… 组合数的求解 利用递推式求解，性质2。复杂度$O(n^2)$。 利用定义求解，复杂度$O(n\\log{n})$。其实可以用逆元递推到$O(n)$。#define ll long long #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 10005;const int mod = 1e9 + 7; int fac[maxn];templateinline void exgcd(T &amp;x, T &amp;y, T a, T b){ if(b) exgcd(y, x, b, a % b), y -= (a / b) * x; else x = 1, y = 0;}templateinline T inv(T a, T x = 0, T y = 0){ // ax \\equiv 1 \\pmod {p} -&gt; ax = pk + 1 -&gt; ax - pk = 1 exgcd(x, y, a, mod); return (x % mod + mod) % mod;} inline void init(){ fac[0] = 1; for (int i = 1; i &lt; maxn; ++i) fac[i] = (1ll * fac[i - 1] * i) % mod;} inline ll C(int n, int m){ return ((((1ll * inv(fac[m]) * fac[n]) % mod) * inv(fac[n - m])) % mod);} int main(){ init(); // code…} #### 二项式定理 $$ (a + b)^n = \\sum_{k = 0}^{n}{\\binom{n}{k}a^kb^{n - k}} $$ 证明我不会。 #### $Lucas$定理 若$p$是质数，则有$\\binom{n}{m} \\equiv \\binom{n \\ mod \\ p}{m \\ mod \\ p} \\cdot \\binom{\\frac{n}{p}}{\\frac{m}{p}}$。证明我也不会，貌似需要生成函数。 ##### 给定$n, g$，求$g^{\\sum_{d | n}{\\binom{n}{d}}} \\mod{99911659}$。 因为$99911659$是质数，$ex$欧拉定理可知，费马小定理也行，$a^b \\equiv a^{b \\mod{\\varphi(n)}} \\mod{n}$，所以$g^{\\sum_{d | n}{\\binom{n}{d}}} \\mod{99911659} = g^{\\sum_{d | n}{\\binom{n}{d}} \\mod{99911658}} \\mod{99911659}$。目前的问题就是快速求$\\sum_{d | n}{\\binom{n}{d}} \\mod{99911658}$。$n \\leq 10^9$，所以$n$的约数个数不超过$2\\sqrt{n}$。也就是说跑的过。那么问题来了，$Lucas$定理的适用范围仅仅是质数，怎么办怎么办（捧读）。分解$9911658 = 2 \\cdot 3 \\cdot 4679 \\cdot 35617$。对于几个分解后的质数，我们带入中国剩余定理，求出正确的$\\binom{n}{d} \\mod{9911658}$。代码如下~ ```cpp #define ll long long #include &lt;bits/stdc++.h&gt; using namespace std; namespace BZOJ1951 { const int mod = 999911658; const int prm[4] = {2, 3, 4679, 35617}; inline ll fpow(ll a, ll p, ll mod) { ll ans = 1; for (; p; p &gt;&gt;= 1) { if(p &amp; 1) ans = (a * ans) % mod; a = (a * a) % mod; } return ans; } int g, n, factor[40000], cnt, fact[40000], a[4]; inline void init() { for (int i = 1; i * i &lt;= n; ++i) if(n % i == 0) { factor[++cnt] = i; if(i != n / i) factor[++cnt] = n / i; } } inline int C(int n, int m, int p) { if(m &gt; n) return 0; return fact[n] * fpow(fact[m] * fact[n - m], p - 2, p) % p; } inline int lucas(int n, int m, int p) { if(m == 0) return 1; return C(n % p, m % p, p) * lucas(n / p, m / p, p) % p; } inline int work(int p) { memset(fact, 0, sizeof(fact)); fact[0] = 1; for (int i = 1; i &lt;= p; ++i) fact[i] = fact[i - 1] * i % p; ll ans = 0; for (int i = 1; i &lt;= cnt; ++i) ans = (ans + lucas(n, factor[i], p)) % p; return ans; } inline int CRT() { ll ans = 0, M = 999911658; for (int i = 0; i &lt; 4; ++i) ans = (ans + (a[i] * (M / prm[i]) % mod) * fpow(M / prm[i], prm[i] - 2, prm[i])) % mod; return ans; } inline void solve() { cin &gt;&gt; n &gt;&gt; g; if(g == 999911659) return puts(&quot;0&quot;), void(); init(); for (int i = 0; i &lt; 4; ++i) a[i] = work(prm[i]); printf(&quot;%lld\\n&quot;, fpow(g, CRT(), 999911659)); } } int main() { return BZOJ1951::solve(), 0; }$Catalan$数列定义如下：$Cat(n) = \\frac{\\binom{2n}{n}}{n +1}$。 有以下问题： $n$个左括号和右括号组成的合法序列的个数。 $[1, n]$形成的合法出栈序列的个数。 在平面直角坐标系上，不越过$x - y = 0$一条直线，每次只能向上或者向右走，的路线的条数。 $Catalan$数列通常采用朴素的组合数求法，也有递推版本的。 组合数学 ver2.0排列与组合。 $\\frac{n!}{(n - m)!}$。$n!$是全排列的数量，$(n - m)!$是除去$m$个以外的排列顺序个数。除一下就好了。 $\\frac{n!}{m!(n - m)!}$。总数除以算重的。圆上的排列问题。$\\frac{n!}{(n - m)!n}$ 。 具体求法。逆元预处理，阶乘预处理。 $\\binom{n}{m} = \\binom{n - 1}{m} + \\binom{n - 1}{m - 1}$的杨辉三角理解方式。 HDU4135 求$\\sum_{i = 1}^{n}{[gcd(i, x) = 1]}$。$n \\leq 10^9$。 对于一个固定的$x$，我们要求$i$的个数。但是我们发现，求互质没法下手，我们尝试用不互质去解决。$gcd(x, i) != 1$的条件，$i$是$x$的某个因数。所以我们枚举$x$的所有质因数$p_i$，满足条件的$p_i \\cdot k \\leq n$就是$x$的个数。但是，会发现，我们算重了很多情况，于是进行容斥。进行一次$dfs$，因为$n \\leq 10^9$的条件下，$p_i$的个数不超过10，对于每一个，容斥$\\frac{n}{i}$，最后用$n$减去该答案。 ??? 给出$n \\times m$的矩阵，$q$个询问，每次询问$(x_1, y_1) \\rightarrow (x_2, y_2)$的路径个数。$n, m \\leq 1000$，$q \\leq 10^5$。 $dp$的解法不用说了，小学难度。 问题是让用组合数。引出隔板法，隔板法是这么一个东西： 将$k$个物品用板子分成$m$份。能够分的情况个数是：$\\binom{k + m - 1}{m - 1}$。 将$k$个物品分成$m$份，需要添加$m - 1$个板子，我们可以把板子看成别的物品，总和也有就$k + m - 1$个物品，从中选出$m - 1$物品，也就有$\\binom{k + m - 1}{m - 1}$种情况。 再转回原题目，首先，假如说是从$(1, 1) \\rightarrow (n, m)$，我们考虑把路径分成横着的$n$份，总共要下降$m$次，也就是说，把$m$次下降分到$n$份中，也就是隔板法的经典问题，答案是$\\binom{n + m - 1}{n - 1}$。（写反了，懒得改，将就看看吧。 HDU6397 给出$n, m, k$，从$[0, n - 1]$中选取$m$个数，使得合为$k$，问方案数，数字可重复。$n, m, k \\leq 10^5$ 首先考虑简化版本的问题，$k \\leq n - 1$。我在$k$个$1$中放隔板，和一定为$k$，个数是$\\binom{k + m - 1}{m - 1}$，那么问题来了，$k &gt; n - 1$咋办。我们将每一个数字表示为$a_1x + b$。我们将情况用$\\sum{a_i}$分类，$\\sum{a_i} = [1, \\frac{k}{n}]$。假如说忽略$n$，我们直接用隔板法计算所得结果是$\\sum{a_i} \\in [1, \\frac{k}{n}]$的情况数之和，因为隔板法隔出了所有的情况，这些情况等于分类后的全集。我们考虑从$k$中剔除$i$个$n$，对剩余的进行隔板法，然后放回这$i$个$n$，放回的情况个数是$\\binom{m}{i}$。这时，我们的计算结果是忽略掉了$\\sum{a_j} \\leq i$的，利用这个性质进行容斥即可得答案。 生成函数首先吧，定义如下： 对于序列$a_0, a_1, a_2, a_3, a_4 \\cdots a_n$，$g(x) = \\sum_{i = 0}^{n}{a_ix^i}$，称$g(x)$是序列的生成函数。 你有$1, 3, 5$面额的硬币，每种数量无限，总共用$k$个，能够组合出多少种面额。 考虑多项式的乘法，用$x^1$表示用$1$元的硬币，用$x^3$表示用$3$元的，以此类推。$$(x^1 + x^3 + x^5)^k$$用幂表示面额数，最后求有多少种幂，在这里忽略系数就是多项式的用处。 HDU1028 求出和为$n$的数的组合的个数，$n \\leq 120$ $(1 + x + x^2 + x^3 + \\cdots) \\cdot (1 + x^2 + x^4 + \\cdots) \\cdots$.最后统计$x^n$的系数。 POJ 1942 1850 1019 HDU 1028 1398 1085 2082 1709 2065 数学期望因为明天要考期望，紧急添加… 妈耶我期望不要爆零。 对于样本空间$A$，随机事件$a$发生的概率是$P(a)$，$P(\\sum{a}) = 1$，$P(a) \\in [0, 1]$。对于互斥事件$a_i, a_j$，$P(a_i) +P(a_j) = P(a_i \\cup a_j)$。 对于$X$的取值$x_i, x_j \\cdots$，取到某一个值的概率是$p_i$，则取到这个值得数学期望是$E(x_ip_i)$d，对于随机变量$X$的期望是$\\sum{x_ip_i}$。假如说掷骰子吧，取值有$[1, 6]$，而掷到每一个数值的概率是$\\frac{1}{6}$，则掷一个骰子的值的数学期望是$\\frac{1}{6} \\cdot 1 + \\frac{1}{6} \\cdot 2 + \\cdots + \\frac{1}{6} \\cdot 6 = \\frac{21}{6}$。 光说不练假把式。 「ep8」某个星球有$n$天，抽取$k$个人，问至少两个人生日在同一天的概率是。$1 \\leq k \\leq n \\leq 10^{6}$。这种，一般都要转换问题，转换为“所有人生日都不同”的问题。第一天，某个人可以选择$\\frac{n}{n}$天，第二个人可以选择的是$\\frac{n - 1}{n}$，第$k$个人可以选择的是$\\frac{n - k + 1}{n}$，所以答案就是$\\prod_{i = 0}^{k - 1}{\\frac{n - i}{n}}$。可以线性计算。 「ep9」毛玉问题，有$K$只毛玉，每只生存一天就会死亡，每只毛玉在死之前有可能生下一些毛玉，生$i$个毛玉的概率是$pi$，问$m$天后所有的毛玉都死亡的概率是多少？ 所有数据$\\leq 1000$。（$UVA11021$代码如下…解释的话…会很复杂。好吧…我承认这道题搞了我俩天。设$f[i]$表示，对于一直毛玉，其子孙后代在$i$天“内”死亡的概率是。假设这一天死了这一只小毛玉死了，概率是$p_0$，如果生下一只的话，生下的小毛玉已经被限制了生命，在$i - 1$天内死的概率是$f[i - 1]$，其中$i - 1$的意思是它的寿命是$i - 1$。对于生下的所有小毛玉，可以独立考虑，则全部死光的概率需要$f[m]^k$。这道题的关键是搞清楚，$f[i]$到底是啥意思QAQ就是这玩意儿害了我俩天。 // by kririae #define R register #include &lt;bits/stdc++.h&gt; using namespace std; const int maxn = 1005; int t, n, k, m; double p[maxn], f[maxn]; inline double fpow(R double a, R int p) { double ans = 1; for (; p; p &gt;&gt;= 1) { if(p &amp; 1) ans = a * ans; a = a * a; } return ans; } int main() { scanf(&quot;%d&quot;, &amp;t); for (int qwq = 1; qwq &lt;= t; ++qwq) { memset(f, 0, sizeof(f)); scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;m); for (int i = 0; i &lt; n; ++i) scanf(&quot;%lf&quot;, &amp;p[i]); f[1] = p[0]; for (R int i = 2; i &lt;= m; ++i) for (R int j = 0; j &lt; n; ++j) f[i] += p[j] * fpow(f[i - 1], j); printf(&quot;Case #%d: %.7lf\\n&quot;, qwq, fpow(f[m], k)); } } 「ep10」咕咕咕「ep11」咕咕咕「ep12」咕咕咕「ep13」咕咕咕「ep14」Va-11 Hall-a (by ihopenot)「题目描述」$Jill$是在$Vallhalla$工作的调酒师。为客人送上美味的饮料是她的工作内容。但$Jill$是个有创造力和上进心的女孩，她并不满足于仅为客人调制菜单上的饮料，她想自己去创造属于自己的饮料。虽说如此，她并不知道怎么去创造一种受客人欢迎的饮料，于是她想出了一个绝妙的办法。$Jill$将$n$瓶酒摆成一列，每瓶酒初始评价值都为$1$，然后有$m$次操作。每次操作$Jill$会在$[l,r]$内的酒中随机选择任意瓶每瓶加入一个评价值随机（不一定相同）的配料，并重复这个操作$k_i$次。由于原料和配料会发生剧烈的化学反应，所以混合之后评价值并不是相加 那么简单。据$Jill$观察，一瓶评价值为$a$酒在加入评价值为整数$b(0 \\leq b &lt; c)$，的配料后评价值会变为$a\\cdot b \\ mod \\ c$。现在$Jill$想知道她最终调制出的酒的评价值的和期望是多少。 一句话题意：给你一个初始全为$1$的长度为$n$的序列，$m$次操作，每次操作重复$ki$次，对于$[l,r]$间的随机一些数$a$，再对每个数选择一个随机整数$b(0 \\leq b &lt; c)$，将这些数变成$a\\cdot b \\ mod \\ c$。问最终所有数的和期望是多少。 为了方便保证精度，你需要输出答案对$10^9+7$取模后的结果。 提示：如果答案是$\\frac{a}{b}$的形式，那么你需要输出$a \\cdot b^{-1} \\ mod \\ (10^9 + 7)$的结果。由于费马小定理，你只需输出$a \\cdot b^{10^9 + 5} \\ mod \\ (10^9 + 7)$就可以了。 「输入格式」第一行三个正整数$n, m, c$接下来每行三个数$l_i, r_i, k_i$表示操作的区间和重复次数。 「输出格式」 一行一个整数表示答案对$10^9+7$取模后的整数。 「样例输入」3 1 3 1 2 1 「样例输出」500000007 「数据规模及约定」对于$30%$的数据$n=10, m \\leq 10, k_i \\leq 10, c \\leq 5$对于$100%$的数据$n \\leq 100, m \\leq 1e6, k_i \\leq 100, c \\leq 50$ 题解由于期望的可加性，我们可以这么处理这道题。对于每个数，我们求出它最后为某一个数的期望，然后求和。因为它最后的值一定属于$[0, c)$。所以我们建立矩阵：$$\\begin{bmatrix} p_0 \\ p_1 \\ p_2 \\ \\cdots \\ p_{c - 1} \\\\end{bmatrix}$$$p_i$表示最后值为$i$的概率是。当然，现在的矩阵是初始的，我们考虑如何对这个矩阵进行转移。即转移到某一次操作后，某一个数变换成某一个数的概率是。转移矩阵的第$i$行第$j$列定义为，数值$i$变换到数值$j$的概率是。特别的，这个矩阵有第$0$行第$0$列。对于一次$[L, R]$的操作，选取到某个数的概率是$\\frac{1}{2}$。而选取到这个数之后，进行的操作可能是乘上$[0, c)$中的任意一个数，乘这个数的概率就是$\\frac{1}{c \\cdot 2}$。所以我们在某个数$x$乘上$[0, c)$后的数$y$，$x \\rightarrow y$之间的边加上概率$\\frac{1}{c \\cdot 2}$。 对于这道题的矩阵乘法，我们这么考虑：$a_{1, 2}$的意思是经过一次操作后，$1$变到$2$的概率，则在乘上原矩阵第二列之后，最后的变为$2$的概率自然加上了某个值，这个值是$1$变为$2$的概率。 按照套路，这个时候该进行矩阵快速幂了。但是，如果直接进行矩阵快速幂的话…我们看看复杂度：$O(nc^3log{km})$，$2.5 \\cdot 10^8$有点玄乎啊。这个时候，考虑优化矩阵乘法。我们$n \\times n$的矩阵乘法的复杂度是$O(n^3)$，如果是$n \\times n$和$n \\times 1$的矩阵乘法，不就是$O(n^2)$了。我们预处理出转移矩阵的$2^k$次方，复杂度是$O(n^3log{k})$，可以接受，然后，用预处理出的信息和$n \\times 1$的矩阵一一结合，得出的就是最后的矩阵，然后对所有求和，得出期望。 $std$代码如下 #include&lt;bits/stdc++.h&gt; using namespace std; #define MOD 1000000007 #define LL long long int n,m,c,ans; int num[105]; struct Matrix{ int x[55][55]; Matrix operator * (const Matrix &amp;b) const { Matrix ret; memset(ret.x,0,sizeof(ret.x)); for(int i=0;i&lt;c;i++) for(int j=0;j&lt;c;j++) for(int k=0;k&lt;c;k++) ret.x[i][k]=(ret.x[i][k]+(LL) x[i][j]*b.x[j][k])%MOD; return ret; } }pw[35],st; int now[55],t[55]; void Merge(int k) { memset(t,0,sizeof(t)); for(int i=0;i&lt;c;i++) for(int j=0;j&lt;c;j++) t[i]=(t[i]+(LL) now[j]*pw[k].x[i][j])%MOD; for(int i=0;i&lt;c;i++) now[i]=t[i]; } int fpow(int a,int b) { LL t=a,ret=1; while(b) { if(b&amp;1) ret=ret*t%MOD; b&gt;&gt;=1;t=t*t%MOD; } return ret; } int main() { freopen(&quot;bar.in&quot;,&quot;r&quot;,stdin); freopen(&quot;bar.out&quot;,&quot;w&quot;,stdout); scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;c); for(int l,r,k,i=1;i&lt;=m;i++) { scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k); num[r+1]-=k;num[l]+=k; } for(int i=1;i&lt;=n;i++) num[i]+=num[i-1]; LL rev_2=fpow(2,MOD-2),rev_c=fpow(c,MOD-2); for(int to,i=0;i&lt;c;i++) { for(int j=0;j&lt;c;j++) { to=i*j%c; st.x[i][to]=(st.x[i][to]+rev_2*rev_c)%MOD; } st.x[i][i]=(st.x[i][i]+rev_2)%MOD; } pw[0]=st; for(int i=1;i&lt;=30;i++) pw[i]=pw[i-1]*pw[i-1]; for(int i=1;i&lt;=n;i++) { memset(now,0,sizeof(now)); now[1]=1; for(int j=0;j&lt;=30;j++) if(num[i]&gt;&gt;j&amp;1) Merge(j); for(int j=0;j&lt;c;j++) ans=(ans+(LL)now[j]*j)%MOD; } printf(&quot;%d\\n&quot;,ans); return 0; } 概率$dp$ $$P(B) = \\sum{P(A)P(B | A)}$$ $B$事件是及格，$A$事件是$100$分以上，所以说$B$事件发生的概率是$A$发生的概率乘$A$发生的前提下$B$发生的概率。 $P(B | A) = \\frac{P(A, B)}{P(A)}$。$A, B$不是独立事件，所以不能直接相乘。可以这么$A$发生的前提下$B$发生的概率。 期望$dp$ $E(A) = \\sum{P(a_i) \\times a_i} = \\sum{E(a_i)}$; 经常会出现$a_i$的值一定的时候，也就是贡献一定的时候，有时会转化为求$P(a_i)$，$a_i$不同的时候，就需要单独计算了。 HDU3853POJ2151$f[i][j][k]$，选到第$i$个队伍，从前$j$个中选$k$个，所有合法情况的概率之和为$f[i][j][k]$。 所有队伍至少做出一个的概率就是$1 - f[n][m][0]$。所有队伍都做出$n$以下的概率是$f[i][m][n]$的前缀和。 POJ3071二进制性质优化概率dp 对于所有点建树，树状数组式建树，对于$i$层，编号从$0$开始，可以发现性质，当前&gt;&gt; 1之后是起父亲节点，当前&gt;&gt; 1 xor 1是其父亲节点的右节点。然后进行普通的转移。对于第$i$层，先把某个值右移$i - 1$层，然后异或$1$，相等，能打。什么骚操作。。。 CF148D$f[i][j]$表示剩余$i$只白鼠，$j$只黑鼠，$A$先手，胜利的概率。 $f[i][0] = 1$，因为$A$先手，如果没有黑鼠就赢了。 $f[0][i] = 0$，没有白鼠$B$胜利。 在这一场胜利有三种情况，这一次抓到白鼠，上一次$B$抓到黑鼠，跑出来只白鼠、这一次抓到白鼠，上一次$B$抓到黑鼠，跑出来只黑鼠。输出$f[w][b]$。 POJ3744 先考虑数值范围很小的情况，$a_i \\leq 1000$，假如说$i$位置有雷，到达$i - 1$位置的概率乘以转移两步的概率就是到达$i + 1$位置的概率，然后跳过$i$位置的计算，中间分开的部分用矩阵快速幂优化一下。 BZOJ4318$f[i][j]$表示到了$i$位置，连续$1$的长度为$j$，的期望分数。$i + 1$，$p_i$的概率是$1$，$1 - p_i$的概率是0.$f[i + 1][j + 1]$的概率是$p_i$，转移到$f[i + 1][0]$的概率是$1 - p_i$。第二种的权值是$0$，前者的权值是$(j + 1)^3$。不过。。。我貌似搞忘看数据范围了，$n \\leq 10^6$。 所以说，$f[i]$表示到$i$位置的期望分数，$g[i]$表示到$i$的期望长度。 TODO HDU4405本题目的大体意思是有n个格子，掷色子的掷出的数目就是你一次到移动格数。其中有m个飞行通道可以让你直接从第xi格飞到第yi格。问你走到终点的期望是多少。 HDU4336有N种卡片，每一袋零食里面最多有一张卡片，给出一袋零食里面每种卡片的概率，问平均要买多少袋零食能收集到所有的卡片。 BZOJ3143首先求出每个点到达的期望次数，$x_i​$，$x_i = \\sum{x_j \\cdot \\frac{1}{d[j]}$。列出系数矩阵，$x_n = 0$。高斯消元解出每个点到达的期望次数。然后每条边到达的期望次数是$w_k = x_i \\cdot \\frac{1}{d[i]} + x_j \\cdot \\frac{1}{d[j]}$。对期望次数从大到小排序，然后依次分配权值。 泰勒展开非线性的函数 $\\rightarrow$ 函数多项式。 $f(x) = f(x_0) + f^{‘}(x_0)(x - x_0) + frac{f^{‘’}(x_0)(x - x_0)^2}{2!} \\cdots$。 指数型母函数假如说有$8$个元素，数值可重复。从中取出$k$个元素，求排列数。 $1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} \\cdots$。进行排列计数。$\\frac{x^i}{i!}$表示某物品选取了$i$次，排列个数。 除以阶乘的原因是排除自身重复排列的影响。 POJ3734$e^x$通过在$0$处的泰勒展开，其实就是指数型母函数的标准形式。 $e^{-x}$在$0$处泰勒展开，和指数型母函数进行加法或减法运算，可以得出奇数项，偶数项的和。备注：$f^{n \\cdot ‘}(x) = (-1)^n \\cdot e^-x$。 SG函数 $Sprague - Grundy$在DAG上进行。 先手必败态。非先手必败，都是先手必胜！ 假设是$NIM$游戏，对于每一堆有$a_i$个物品，则当前堆的$SG(i) = a_i$。结论:对于任意一个$SG$异或值为0的状态，通过一步只能变为$SG$异或值非零。对于任意一个$SG$异或和非零的状态，一定能一步转移到$SG$异或和为0的状态。 阶梯上的博弈问题。给出$n$级阶梯，每次可以把上级阶梯的石子移到下一层。最后当石子全在1时无法移动。$A$先手，问谁胜利。$n \\leq 10^6$。加入说$A$将一堆石子从奇数层移到了偶数层，我们可以再进行一次移动使得局面不变，依然$A$先手。假如说我们将偶数层移动到奇数层，就等同于把一堆石子拿走了，因为奇数层的都可以xjb处理。对于所有偶数层的进行$NIM$，得出答案。 LUOGU2575首先考虑暴力求解，状压枚举，不说了。 问题在于这道题tmd居然还有阶梯博弈的抽象。。。 我们知道，我们每次移走一个棋子的时候，空格的个数是不会改变的，我们把每个0看成一个阶梯的分界线，假如说把$i \\rightarrow j$，$j$的0没了，$i$多出一个$0$，也就是阶梯的分界线变为了$i$，也就是说，把$i$分界线对应阶梯的一部分棋子放到$j$对应阶梯上了。对于每一行，抽出偶数位置，进行$NIM$，作为当前行的$SG$，然后对于每一行$SG$，可以解决问题。 骚操作补充十进制快速幂首先，快速幂要求一下东东$a^b \\ mod \\ p$。但是，直接跑太慢啦，于是我们队$b$进行了二进制的拆分，拆分成了$2^0 + 2^j \\cdots$，于是变成了$a^{2^0 + …}$，化为$a^{2^{0}} \\cdot a^{2^{j}} \\cdots$。注意到只有$\\log{n}$项，所以复杂度是$O(\\log{n})$。但是，细心的人就会发现，关于$b$，还有一个拆分方法。$while(b)\\ a[++curr] = b % 10, b /= 10;$。这样，拆分成了$b = \\sum_{i = 1}^{n}{c_i \\cdot 10^{i - 1}}$。$a^b = a^{c_i \\cdot 10^{i - 1}} \\cdots$。因为带上了$c_i$，实现上还会有一些小问题，这些一会儿解决~这样，我们就可以写出十进制的快速幂！更快！更重要的是，可以部分代替高精度，不信请看。 求$a^b \\ mod \\ p$，$b \\leq 10^{10000}$。大概，只能用数组来存了，不过无所谓。看代码： const int N = 10005; char b[N]; inline ll fpow2(ll a, ll p, ll mod) { ll ans = 1; for (; p; p &gt;&gt;= 1) { if(p &amp; 1) (ans *= a) %= mod; (a *= a) %= mod; } return ans; } inline ll fpow10(ll a, char p[], ll mod) { ll ans = 1; int l = strlen(p + 1); for (int i = l; i &gt;= 1; --i) { (ans *= fpow2(a, p[i] - &#39;0&#39;, mod)) %= mod; a = fpow2(a, 10, mod); } return ans; } 一些题目备选概率：BZOJ2318，BZOJ4720，BZOJ2720，BZOJ3720，收集邮票 各种：NOI2010能量采集 在 daily blog 里加上一篇数论笔记也能体现我真的不是文科生吧","categories":[{"name":"Math","slug":"Math","permalink":"http://kr2.moe/categories/Math/"}],"tags":[],"author":"TraceBack"},{"title":"Atcoder 爽题集合","slug":"atc_problems","date":"2018-06-22T23:26:00.000Z","updated":"2021-04-10T06:33:46.840Z","comments":true,"path":"2018/06/22/atc_problems/","link":"","permalink":"http://kr2.moe/2018/06/22/atc_problems/","excerpt":"Atcoder爽题集合","text":"Atcoder爽题集合 口胡和完整代码对于$[1 .. n]$的排列$A$，每次可以选择一个数放到开头，最后使得数列有序，求最少操作次数。 简单dp 错了错了！！！题目记错了https://www.51nod.com/Question/Index.html#questionId=1060&amp;isAsc=false这是当时写的题解：虽然是简单dp，但是分析过程并不是很简单首先思考，如何成本最小化当前已经排好序的就不用动了，只动没有排好序的，这样成本最小化了什么是排序好的呢？连续的一段+1的然后我们把两段排好的组合起来，能够组合的情况，只有右段的最小值 = 左的最大值 + 1于是我们就把问题转化成了求一段，最长，连续上升，的子序列。这个问题递推就好，注意是按照“数”来进行递推这是 atcoder 的版本：https://atcoder.jp/contests/agc024/tasks/agc024_b scanf(&quot;%d&quot;, &amp;n); for (R int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (R int i = 1; i &lt;= n; ++i) f[a[i]] = f[a[i] - 1] + 1, ans = max(ans, f[a[i]]); printf(&quot;%d&quot;, n - ans); 对于数列$A$，$B$，每一次可以选择$A$中任意多个数，然后选择一个数$k$，使得每个选择的数$a_i$ 变成$a_i\\mod k$。然后代价是$2^k$，最后使得$A$和$B$相同，求代价最小值。 贪心 + 状压dp scanf(&quot;%d&quot;, &amp;n); for (int j = 0; j &lt;= 50; ++j) { f[j] = 0, f[j] |= (1ll &lt;&lt; j); for (int k = 1; k &lt;= j; ++k) if(((1ll &lt;&lt; 51) - 1) &amp; (1ll &lt;&lt; k)) f[j] |= f[j % k]; } for (R int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (R int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;b[i]); int flag = 1; for (R int j = 1; j &lt;= n; ++j) if((f[a[j]] &amp; (1ll &lt;&lt; b[j])) == 0) flag = 0; if(flag == 0) return printf(&quot;%lld\\n&quot;, -1ll), void(); for (int i = 50; i; --i) { for (int j = 0; j &lt;= 50; ++j) { f[j] = 0, f[j] |= (1ll &lt;&lt; j); for (int k = 1; k &lt;= j; ++k) if((ans + (1ll &lt;&lt; i) - 1) &amp; (1ll &lt;&lt; k)) f[j] |= f[j % k]; } int flag = 1; for (R int j = 1; j &lt;= n; ++j) if((f[a[j]] &amp; (1ll &lt;&lt; b[j])) == 0) flag = 0; if(!flag) ans += (1ll &lt;&lt; i); } printf(&quot;%lld\\n&quot;, ans); 对于初始为0的数列$A$，每次可以选择一个$a_i$变成$a_{i - 1} + 1$。最后使得$A$变成$B$，求最少操作次数。 蜜汁性质 scanf(&quot;%d&quot;, &amp;n); for (R int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (R int i = 1; i &lt;= n; ++i) if(a[i] &gt;= i) return puts(&quot;-1&quot;), 0; for (R int i = 2; i &lt;= n; ++i) { if(a[i] - a[i - 1] &gt; 1) return puts(&quot;-1&quot;), 0; if(a[i] == a[i - 1] + 1) ++ans; else ans += a[i]; } printf(&quot;%d\\n&quot;, ans); 对于数列$A$的所有子集之和，进行排序，然后求出排序后的中位数 scanf(&quot;%d&quot;, &amp;n); f[0] = 1; for (R int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;val), f |= (f &lt;&lt; val), sum += val; if(n == 1) return printf(&quot;%d&quot;, sum), 0; for (R int i = (sum &gt;&gt; 1); i; --i) if(f[i]) return printf(&quot;%d&quot;, sum - i), 0;","categories":[{"name":"CS","slug":"CS","permalink":"http://kr2.moe/categories/CS/"}],"tags":[{"name":"Atcoder","slug":"Atcoder","permalink":"http://kr2.moe/tags/Atcoder/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://kr2.moe/tags/Algorithms/"}],"author":"TraceBack"}],"categories":[{"name":"Daily","slug":"Daily","permalink":"http://kr2.moe/categories/Daily/"},{"name":"Math","slug":"Math","permalink":"http://kr2.moe/categories/Math/"},{"name":"Design","slug":"Design","permalink":"http://kr2.moe/categories/Design/"},{"name":"CS","slug":"CS","permalink":"http://kr2.moe/categories/CS/"}],"tags":[{"name":"杂记","slug":"杂记","permalink":"http://kr2.moe/tags/杂记/"},{"name":"瞎写","slug":"瞎写","permalink":"http://kr2.moe/tags/瞎写/"},{"name":"Learning","slug":"Learning","permalink":"http://kr2.moe/tags/Learning/"},{"name":"Memories","slug":"Memories","permalink":"http://kr2.moe/tags/Memories/"},{"name":"Atcoder","slug":"Atcoder","permalink":"http://kr2.moe/tags/Atcoder/"},{"name":"Algorithms","slug":"Algorithms","permalink":"http://kr2.moe/tags/Algorithms/"}]}