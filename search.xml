<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从零开始的 Position Based Fluid</title>
      <link href="2021/08/16/pbf/"/>
      <url>2021/08/16/pbf/</url>
      
        <content type="html"><![CDATA[<p>其实是作为 GAMES101 的大作业的</p><a id="more"></a><p>（其实这是这篇 report 写的第三次了，前两次写的多多少少都有问题）</p><p>说是 report，我当然没打算把它当成 report 来写，就随意一点，写一些自己写这玩意儿中的心得体会。</p><p>作为一个工程和算法融合的项目，我真的是花了挺大精力来做这玩意儿的。</p><p>认认真真研究了数学部分（从七月中旬就开始了！），认真写了 CMake，认真组织了项目结构，认认真真优化代码，认认真真做抽象。<br>于是，目前终于接近尾声了。</p><h2 id="Part-1-Infrastructure"><a href="#Part-1-Infrastructure" class="headerlink" title="Part 1 - Infrastructure"></a>Part 1 - Infrastructure</h2><p>这个 Infrastructure 是一个比较粗略的概念，我在开始这个项目的时候，甚至连是使用 taichi 还是使用 C++ with OpenGL 都没有决定好。</p><p>我有一丢丢使用 taichi 的经验，从那一丢丢体验上来说，我还是不喜欢写 Python，于是我选择了写 C++，当然，也遇到了很多困难。</p><p>说起写 Python，我之前没有使用过任何的 Python 静态查错的工具，之前写的 btrfs auto backup 就因为一些类型一致性的问题出了 bug.</p><p>于是我设计了一套最最最最简单的可配置的 GUI，专门为 PBF 准备的。其能够显示每个 particle 的位置，与颜色（用一个 <code>color ramp</code> 从粒子密度映射到一些比较骚的颜色，方便之后的观察，事实证明很有用）</p><p>GUI 的接口非常简单，</p><pre><code class="cpp">class RTGUI_particles : public GUI {public:  RTGUI_particles(int WIDTH, int HEIGHT);  ~RTGUI_particles() override = default;  void set_particles(const std::vector&lt;SPHParticle&gt; &amp;_p);  void main_loop(const std::function&lt;void()&gt; &amp;callback) override;  void del();  // ...};</code></pre><p>至于为什么单独引一个 <code>del</code> 函数而不是放在析构函数里，其实也是因为 OpenGL 的一些神秘特性，要求 <code>glDelete..</code> 的时间需要提前一些。</p><p>其中，<code>set_particles</code> 提供了向外的最简单最简单的接口，这个简单的接口设计之后帮了我很大的忙。</p><p><code>main_loop</code> 则以显示器的特性以特定的 <code>interval</code> 调用 <code>callback</code> 函数，<code>callback</code> 会阻塞 <code>main_loop</code>，反过来也会被刷新率阻塞。</p><p>这本是 <code>glfw</code> 相比于 <code>glut</code> 的一个“缺陷”，我使用它也只是因为习惯。但是这个设计莫名的有意思，而且很完美地解决了许多的问题。</p><p>还有一些可提升的空间，比如 GUI 端给 <code>callback</code> 传输 GUI 端的部分信息，以便实现 adaptive calculating 的功能。</p><p>当然，实践下来，这套无论是系统还是代码都可以复用了。<br>OpenGL 的细节我就不说了，反正这玩意儿贼难用，就写着写着就写完了。<br>实际上来说，之后可能要在这上面添加更多的 feature，比如不是以 <code>glPoints</code> 的形式，而是以小球体的形式来展示，但是我暂时不想写了。</p><h2 id="Part-2-Mathematics"><a href="#Part-2-Mathematics" class="headerlink" title="Part 2 - Mathematics"></a>Part 2 - Mathematics</h2><p>这整个项目可能有两个难点，第一个就在这里了。对于这部分，我可能会写得更认真一些，毕竟不同于以前的其他工程项目，光实现细节都能写上万字。</p><p>从最开始讲起吧，一整个 PBF 要解决的问题很简单也很显然，但是解决的出发点实在让人觉得很神奇，更神奇的是仅仅使用这么简单的思路居然，就模拟出了液体？</p><p>思路是，液体的密度具有一致性。就是这么“简单”的思路。如果不是写过代码，我是不会相信这么一个思路可以运作的。</p><p>思路有了，将其数学化。使用 Lagrange view，我们需要使用离散的粒子去拟合出连续的场。基于 SPH 的方法，我们使用这个公式：</p><p>$$<br>\rho_i = \sum_{j}{m_j \mathrm{W}(\left |\boldsymbol{p}_i - \boldsymbol{p}_j \right |, h)}.<br>$$</p><p>其中 $\mathrm{W}$ 是核函数 poly6（很帅的名字），$h$ 是计算的区间。现在对于 $\rho_i$ 的定义清晰了，我们只需要抹去 $\rho_i$ 中的下标变为 $\rho$，同时抹去 $\boldsymbol{p}_i$ 的下标，就有了关于 $\boldsymbol{p}$ 的连续场 $\rho$.</p><p>虽然我们还是需要保留离散的形式。我们定义一个 constraint function</p><p>$$<br>  C_i(\boldsymbol{p}_1, \cdots, \boldsymbol{p}_n) = \dfrac{\rho_i}{\rho_0} - 1,<br>$$</p><p>这里有一个需要注意的地方，$C_i$ 是关于 $\boldsymbol{p}_k$ 的函数，其变量是变化的所有点的位置，我第一次就被这里搞混了。</p><p>所以 $C_i$ 的梯度需要考虑一个具体的关于某个点，$\nabla C_i$ 本身并没有显然的意义（有意义的其实是 $\nabla_{\boldsymbol{p_k}}C_i$）<br>在考虑 $\nabla_{\boldsymbol{p}_k}C_i$ 时，应该以固定其他所有点，若只移动点 $k$，整体下降最快的方向是——来思考。</p><p>还需要深入理解的一点是 $C_i$ 的下标 $i$，它的含义也不是那么显然。对于静态的 $C_i$ 其实不太好考虑，我们从动态的视角去考虑。</p><p>首先，$C_i$ 其实是关于所有点位置的函数，所以考虑移动其中某一个点，移动了之后，$C_i$ 的值可能会发生变化。而这个值的意义，其实可以简单考虑为 $\rho_i$ 的变化，即这个粒子所代表的密度变化。</p><p>回到更高层的抽象，我们目前有每个 particle 的位置，即 $\boldsymbol{p}$。假设 $C(\boldsymbol{p})$ 的输出是一个列向量，每一行使用 $i$ 进行索引。我们需要一个 $C(\boldsymbol{p} + \Delta \boldsymbol{p})$，使得这个值最小化。其中这个 $\Delta \boldsymbol{p}$ 是所有点的位置向量组成的张量，是一个全局解。</p><p>但是，很显然，通过 $n$ 个方程解 $3n$ 个值是不可能的，我们需要考虑如何使用 $n$ 个值来替代这 $3n$ 个值。</p><p>于是我们给 $\Delta \boldsymbol{p}$ 限制了方向，$\Delta \boldsymbol{p} = \boldsymbol{\lambda} \nabla C(\boldsymbol{p})$，即这个向量场只能向最快下降方向生长。这样我们只需要 $n$ 个 $\lambda$。这部分具体的实现其实是比较模糊的，之后我还会阐释。<br>网络上的部分资料解释了这里为什么将 $\Delta \boldsymbol{p}$ 限制为 $\nabla C$ 方向，有动量守恒的考量。</p><p>好，那么我们将 $C$ 进行展开为一阶泰勒级数，</p><p>$$<br>\begin{aligned}<br>  C(\boldsymbol{p} + \Delta \boldsymbol{p}) &amp; \approx C(\boldsymbol{p}) + \nabla C^T \Delta \boldsymbol{p} \\<br>  &amp; \approx C(\boldsymbol{p}) + \boldsymbol{\lambda} \nabla C^T  \nabla C \\<br>  &amp; \approx 0,<br>\end{aligned}<br>$$</p><p>这样我们只需迭代求解 $\lambda$ 就可以了.. 对吗？</p><p>解出来的每一个 $\lambda_i$，都是针对这行里所有的向量的。即，每一个 $C_i$，都会对 $n$ 个点的运动均产生限制，而最后每个点的运动的限制，就是这 $n$ 个 $C_i$ 产生的运动限制之向量和。<br>注意，下面这个公式把力拆分成了自己“需要”的作用与其他粒子对自己的作用之和，即：</p><p>$$<br>\begin{aligned}<br>  \Delta \boldsymbol{p_i} &amp;= \lambda_i \nabla_{\boldsymbol{p_i}} C_i + \sum_{j} \lambda_j \nabla_{\boldsymbol{p_j}} C_i \\<br>  &amp;= \dfrac{1}{\rho_0}{\sum_{j}{(\lambda_i + \lambda_j) \nabla_{\boldsymbol{p}_j}C_i}}<br>\end{aligned}<br>$$</p><p>最后需要解决的问题是，$\nabla_{\boldsymbol{p}_k}C_i$ 如何计算？即，在粒子 $i$ 的密度函数（伪）下，如何为 $n$ 个粒子分别计算一个运动方向。</p><p>这个公式是整个 PBF 的核心：</p><p>$$<br>\nabla_{\boldsymbol{p_k}}C_i = \dfrac{1}{\rho_0}<br>\left\{<br>\begin{aligned}<br>  &amp;\sum_{j}{\nabla_{\boldsymbol{p_k}}\mathrm{W}(\left |\boldsymbol{p_i} - \boldsymbol{p_j} \right |, h)} &amp;\text{ if } k = i \\<br>  &amp;-\nabla_{\boldsymbol{p_k}} \mathrm{W}(\left| \boldsymbol{p_i} - \boldsymbol{p_j} \right|, h) &amp;\text{ if } k = j<br>\end{aligned}<br>\right.<br>$$</p><p>这一个公式是一整篇论文的核心，它将前式分成了两个大部分来进行计算，一个是自己该向最稀疏的方向运动，其他所有粒子该向远离自己的方向运动。至于运动多少，就靠解出 $\lambda$</p><p>$$<br>  \lambda_i = \dfrac{C_i(\bf{p_1}, \cdots, \bf{p_n})}{\sum_{k}{|\nabla_{\bf{p}_k}} C_i|^2}<br>$$</p><p>对于这个公式，因为存在分式，就需要考虑分母为 0 会导致系统不稳定，于是我们引入论文中提到的 CFM(constraint force mixing)，向公式中添加松弛参数。</p><p>$$<br>  \lambda_i = \dfrac{C_i(\bf{p_1}, \cdots, \bf{p_n})}{\sum_{k}{|\nabla_{\bf{p}_k}} C_i|^2 + \varepsilon}<br>$$</p><p>这个参数的取值也是个坑，之后再说。</p><p>接下来需要解决的是粒子聚集的问题，粒子的聚集可能有几个原因。（尽管凭借我现在的可视化，并无法观察到粒子聚集的情况）</p><ol><li><p>$C_i &lt; 0$ 的情况，在对于粒子距离极其远的情况，比如两个粒子彻底分离的时候，这种这种时候若还添加约束，有可能使得粒子之间存在其他的排斥力。</p></li><li><p>在周围粒子不足以支撑当前粒子质量时，可能会导致大量粒子聚集，从而产生负压力。（我都忘了为啥了，但是解决问题的方案我会在下一个部分说）</p></li></ol><p>总而言之，解决方法又是平滑平滑</p><p>$$<br>  s_{corr} = -k\left(\dfrac{\mathrm{W}(\boldsymbol{p_i} - \boldsymbol{p_j}, h)}{\mathrm{W}(\Delta \boldsymbol{q}, h)}\right)^n<br>$$</p><p>其中 $\Delta \boldsymbol{q}$ 是一个固定距离，这个公式想要表达的是，在 $\Delta \boldsymbol{q}$ 一定时，两个粒子的距离越远，修正作用越弱。而这个修正被放在了求解 $\Delta \boldsymbol{p}$ 的公式中</p><p>$$<br>  \Delta \boldsymbol{p_i} = \dfrac{1}{\rho_0}{\sum_{j}{(\lambda_i + \lambda_j + s_{corr})}} \nabla \mathrm{W}(\boldsymbol{p_i} - \boldsymbol{p_j}, h)<br>$$</p><h2 id="Part-3-Implementation"><a href="#Part-3-Implementation" class="headerlink" title="Part 3 - Implementation"></a>Part 3 - Implementation</h2><p>目前最终实现的结果在<a href="https://github.com/kririae/toys/tree/main/pbf3d" target="_blank" rel="noopener">这里</a></p><p>效果如图（我有点懒得搞 gif 了，看静态吧！）</p><p><img src="https://p.sda1.dev/2/a5f02d326d4c2432f08fe1816295be93/image.png" alt></p><p>拖 OMP, GCC 的福，我很轻松就将其优化到了 16 threads 15k particles 60fps，单帧计算 13ms+，尽管还有挺大的优化空间，在自己的系统和并行计算知识完备前我就不做 CUDA 和其他多线程优化了，还有一个原因是我懒得去租 intel 的机器，没有一个足够好的 profiler（AMD！你看看人家的 vtune）</p><p>这里有一个比较有意思的小插曲，我在使用 spatial hashing[2] 时，不知道是什么原因（可能是巨大的常数，字面意思的常数），我只要开高等级的优化，编译时间就会很离谱（还没跑出来过）。在随手换成 index_sort 后，只换了 hash 函数，性能就极小数值几十 ms 的级别变为基本所有的操作都是 5ms-，应该是访存还有各类计算的问题，论文中给出了一句意味深长的话，大意是 spatial hashing 的思路本身与访存优化的连续访问相悖。</p><p>我首先实现了 $O(n^2)$ 的哈希方法，并根据 <a href="https://github.com/InteractiveComputerGraphics/CompactNSearch" target="_blank" rel="noopener">CompactNSearch</a> 设计了一套简单的接口。</p><p>虽然名字取的是 <code>CompactHash</code>，实际上我没写 <code>CompactHash</code>，因为 index sort 的性能也还挺不错 x</p><pre><code class="cpp">class CompactHash { public:  explicit CompactHash(float _radius);  // ...  void build();  void add_particle(const SPHParticle &amp;p);  std::vector&lt;SPHParticle&gt; &amp;get_data();  int n_points() const;  int n_neighbor(uint index) const;  int neighbor(uint index, uint neighbor_index) const;  std::vector&lt;uint&gt; &amp;neighbor_vec(uint index);  // ...};</code></pre><p>很可惜的是，在大常数下，$n^2$ 完全无法满足性能需求。我那时偷懒，一直懒于实现高性能的数据结构，直到后来完全无法预览，我在写出了第一版的加速数据结构后整个代码的结果终于能预览了。</p><p>但是！这时候的预览结果可以说是一团糟。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]: Macklin, Miles, and Matthias Müller. “Position Based Fluids.” ACM Transactions on Graphics (TOG) 32.4 (2013): 104.</p><p>[2]: Ihmsen, M., Akinci, N., Becker, M., &amp; Teschner, M. (2010). A Parallel SPH Implementation on Multi-Core CPUs. Computer Graphics Forum, 30(1), 99–112.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Welcome to 19</title>
      <link href="2021/05/06/Welcome-to-19/"/>
      <url>2021/05/06/Welcome-to-19/</url>
      
        <content type="html"><![CDATA[<p>十九岁啦！</p><a id="more"></a><p>刚才准备明天的考试去了，完全忘记了要写生日文这回事。这是我第一次得以在五月六日写生日文。因为每次生日都会碰上半期考试，大型考试的前一天必然在学校里，所以我也无一例外地没有机会准时发布这篇文章。本没有注意到这件事，但这回真的真的，是我第一次准时写这鬼玩意儿。</p><p>依然，按照惯例，思考一下 19 代表着什么。可思来想去，发现 19 并没有代表着什么。17 代表青春，18 代表成人，20 似乎也因为 10 的倍数沾了点光。唯独 19，尽管来说都是一年，却并不能引发我的思考。</p><p>不过话说回来，作为 19 岁的主体，我的大二，应是我作为大学生开始加速的一年。大一并不能做到什么，初来乍到，东西碰壁，好不容易摸索出一两个方向，却因自身实力并不无法得以实践。方向日渐明晰的同时，却对自己当下的弱小感到唾弃。我固然明白，不该在大一急于追求这么多东西，甚至大二大三，都不一定能做出个什么来。大二作为一整年，自然有充足的时间供我支配，也算是一种宽慰吧。</p><h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>18 岁的我到底干了什么，我大多都在博客里有所表现，但是唯独心境的变化我越来越疲于记录。我获得了技术力，却丢掉了那份（自我评价的）淡淡的诗人的气息。</p><p>第一个，是生活的浪漫在时间紧促下不断被压缩的问题。我只能获得一些碎片化的浪漫加以碎片化的时间，再也没有动力随意抽出一个小时在校园里漫步，也无心情静下心来读一本书（上大学之后，除了轻小说，一本课外的都没有读！）。</p><p>很显然，这是不对的，我也清楚。但是自我提升的紧迫感不断逼迫我成为一个标准的”工程师“，而非一个诗人般的代码艺术家。我学会了越来越多的东西——在不少人眼里，这已经算优秀了吧。可惜无论在什么评价语境下，成为一个工具箱绝非一个良好的目的地。</p><p>虽说迷惘是走向前方的充分必要条件，我还是在迷惘的过程中失去了自己所欣赏的太多东西，仿佛我无法同时装下诗人与技术宅两个身份，他们会打架，进而将另一者踢出我的身体。</p><p>第二个，是所谓”现充”的缺乏。当然，定义现充本身就不是一件容易的事。但是很显然，如果将对象的范围扩大，现充 ≠ 幸福。事实是，作为上大学快一年了半个女生都没认识的寡王（室友评价），从来不参加任何团建，一到放假就宅在寝室里打游戏写代码，偶尔到食堂出差这些事，其实还是困扰我不少。</p><p>这可能是我遇到的最好气又好笑的矛盾，我依然羡慕每天都能出门四处逛的人，也羡慕一上大学就能找到女朋友的现充，但是我又讨厌这种生活态度，并非我做不到，我看起来也不像一个社恐的样子，只是不愿意，懒得去，因为一个很简单的理由：那种生活更幸福我选择哪种。</p><p>勾搭优秀的男生比勾搭女生快乐，那我就勾搭一堆。写代码和打游戏比出门游玩快乐，那我就写代码和打游戏。有些时候摸鱼比写代码快乐，那我就摸鱼！这就是现在的生活状态，简单概括为快乐导向型。但是，它依然是不对的。</p><p>那，找女朋友这种事，就缓缓吧（小声）</p><p>第三点，是发送者与接收者的问题。我曾有很长一段时间，什么事情都想帮忙，无论别人遇到什么问题，我总会抽出很长一段时间来帮忙解决而不叫一声麻烦。18 岁之后，而因为前两者的原因，去年我至少骂走了向我求助的四个人。</p><p>我思考了很久这件事，为何我变得再也不愿意帮忙了？答案也很简单，我舍不得我的时间。用于自我提升的时间变得弥足珍贵，而耽误(v.)别人的时间变得理所当然。多么不要脸的一种态度。我希望自己能做一个接收者和发送者，至少至少，不能忘记那些曾经赋予我改变，耽误了他们时间的人。再者，至少得帮助真正想要获得帮助，并且态度正确的人。哪怕对象无法相同，最终也能给予自己一份自私的安慰罢。</p><p>第四点。厚积薄发（？）是否真的正确吗。我最大的”个性“体现在瞧不起基本所有取巧的手段，崇尚实力至上实力说话，于是我选择积累我的实力。我大概也知道，这将是一个极其漫长的过程，且这个过程中我只有自己可以宽慰自己肯定自己，没人会意识到我的实力到达了什么层次，也没有奖状会给予我肯定。可能会很寂寞吧，也可能会很枯燥吧，也可能会被瞧不起，但是至少，这时候的我还基本相信着，这种天真是正确的，这份天真可能是我的曾经给我留下的最大的礼物。</p><h2 id="Prebuild"><a href="#Prebuild" class="headerlink" title="Prebuild"></a>Prebuild</h2><p>也已提到，作为关键的过度的一年，专业课是必不能落下的。在已经入门（自封）了图形学和操作系统的情况下，下一年我需要重新走一遍部分的基础知识，以便在之后的 HPC 比赛上能至少帮到点什么。</p><p>但是，技术与素质本就无法等价，技术提升的同时，素质的提升也不能落下。于自己，如何过得更加幸福与诗意。于他人，如何为他人做到点什么。于国于天下，如何终究留下点什么。这些都是亟待思考的与时间的问题。这就涉及时间分配的问题，我对时间的态度需要在下一年里放宽，不能将所有时间都注入到技术上，我需要 build 更加正确的态度来让我更加正确地分配时间。</p><p>上文我有意无意混淆了快乐与幸福，接下来的一年里，我至少得拥有一份区分快乐与幸福的固执。快乐或许能带来短暂的幸福，但是对我来说，许多快乐终究是过于短浅的，甚至自己都意识不到。将区分快乐与幸福形成一种固执后，才能真正影响到自己的生活。当然，于我，幸福的定义是如何的，就懒得赘述了x</p><p>嘛，作为一个新的开始，感谢各位，也感谢自己，共勉。</p><p>krr.</p><p>2021/05/06</p><blockquote><p>行文略草，可能存在一些问题与表达不完善之处。应该还会修改</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PA_record.log</title>
      <link href="2021/04/10/PA-record-log/"/>
      <url>2021/04/10/PA-record-log/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从指令集实现到操作系统<br>nju-ics-pa 工程记录</p></blockquote><p>那就让我来认真对待这个质量高的夸张的PA。NJU牛逼！</p><p>我就是精神南大人（不）</p><a id="more"></a><h2 id="PA1"><a href="#PA1" class="headerlink" title="PA1"></a>PA1</h2><p>调用顺序：</p><p><code>main.c</code> 调用 <code>init_monitor()</code></p><ul><li><p><code>parse-args</code> 中的 <code>getopt_long</code> 函数的文档查看通过 <code>man 3 getopt</code> 进行。这个在 Arch 下有坑。（会显示 locale 未定义）只需要 RTFM(archwiki) 安装 <code>man-pages</code> 等两个包即可。而 <code>man</code> 后的第一个参数：</p><ul><li>1: Executable programs</li><li>2: System calls3: Library calls</li></ul></li></ul><p>最常见的就是这三个了。我们要查看 <code>getopt.h</code> 中的，选择第三个。找到 <code>getopt_long()</code> 的定义与使用方法。初始化 <code>struct option</code> 后… 详细的就不说了，下次用到的时候再看文档（x</p><ul><li><p><code>init_log</code> 中也无什么可以说的。包括 <code>init_mem()</code>。 </p></li><li><p>接下来是一个比较关键的 <code>init_isa()</code>。 <code>init_isa</code> 中（我选择 riscv32 来学习）。</p><p><code>init_isa</code> 函数中会将 <code>image</code> 复制到 <code>IMAGE_START</code> 中（为 <code>pmem</code> 所代表的地址，由 <code>guest_to_host</code> 函数进行映射，而 <code>guest_to_host</code> 函数的意思为</p><pre><code>/* convert the guest physical address in the guest program to host virtual address in NEMU */</code></pre></li></ul><p>NEMU 的执行会在$n$次循环后结束，而这个$n$由 <code>~0 (-1)</code> 得到。还算比较简单吧。</p><ul><li><p>踩了个坑，使用 uint 的时候，不能拿来判长度。不信你试试看，绝对挂。</p></li><li><p>在 +4 那里又挂了一次。一个 word 是两个字节 xxx</p></li><li><p><code>inline</code> 那个是咋回事？应该是定义函数的时候并不需要加上更多的qulifier？我也记不清了。</p></li></ul><p>需要注意的是，在编写获取寄存器内容的时候，需要特别处理 <code>pc</code>，因为 <code>pc</code> 并未出现在 <code>regsl</code> 中。</p><p>PA1 写完了，来个总结。（至于必答题… 我就偷懒惹</p><p>各类 <code>#include&lt;&gt;</code> 的写法， 我果然还得再努力学习一下。写完代码不能什么都不学到，至少得学到点工程的知识对吧，那就是 Think twice, code once，同一个道理。</p><blockquote><p>补充。实际上我的 debugger 有不少的 bug，但是鉴于此项目整体比较简单，而且启动 debugger 比较麻烦，我后来也没怎么用过这个 debugger。这部分的基础设施我就懒得再 fix bugs 了。</p></blockquote><h2 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h2><blockquote><p>一条指令在 NEMU 中的一生</p></blockquote><p>程序运行顺序：</p><p>在 <code>main.c</code> 开始运行后进入 <code>init_monitor</code>，其中 <code>load_img</code> 会加载其 <code>~.bin</code> 。</p><p>接下来在 <code>engine_start</code> 中，<code>ui_mainloop</code> 会识别其为 <code>batchmode</code> 并且进行 <code>cmd_c</code>进入 <code>cpu_exec</code>。该指令的一生从这里开始。</p><p>说错了点，其实是从循环里的 <code>isa_exec_once()</code> 开始，其在 <code>nemu/isa/riscv32/exec/exec.c</code> 中定义。</p><p>首先来看这个 <code>DecodeExecState</code>，在 <code>decode.h</code> 中定义，</p><pre><code class="c">typedef struct {  uint32_t opcode;  vaddr_t seq_pc;  // sequential pc  uint32_t is_jmp;  vaddr_t jmp_pc;  Operand src1, dest, src2;  int width;  rtlreg_t tmp_reg[4];  ISADecodeInfo isa;} DecodeExecState;</code></pre><p>注意其中的几个关键点。我们按照<code>isa_exec_once()</code> 中的顺序介绍。首先默认不是 <code>jmp</code> 的类型（所以关于 <code>pc</code> 的操作可以暂时忽略）。并将 <code>seq_pc</code> 置为 <code>cpu.pc</code>（之后再管这部分）</p><p>其中的 ISADecodeInfo 是跟着 ISA 的，<code>isa.h</code> 中进行了宏定义将具体的 ISA 定义为了该 ISADecodeInfo。我们的 <code>riscv32_ISADecodeInfo</code> 大致内容如下</p><pre><code class="c">typedef struct {  union {    struct {      uint32_t opcode1_0 : 2;      ...    } i;    struct {      uint32_t opcode1_0 : 2;      ...    } s;    struct {      uint32_t opcode1_0 : 2;      ...    } u;     ...    uint32_t val;  } instr;} riscv32_ISADecodeInfo;</code></pre><p>定义了 opcode 的几种形态，至于这几种形态的具体内容，refer to <code>riscv-spec.pdf</code> 的 page 16。后面带了一个 <code>val</code>，用来存储指令原有的样子。那个加冒号的写法实际上是位段的处理，保证 i/s/u 的二进制位和和标准的 instruction format 对应吧。这里非标准使用 <code>union</code> 的骚操作保证 <code>val</code> 里的每一位都直接被赋值…实在精彩。如果需要自己写这段，大小端的问题需要注意，算了今天就不处理了。</p><p>于是，这条指令进入了 <code>fetch_decode_exec()</code> 函数中。这个函数将带领这个指针走完其一生。</p><p>我们实现的CPU执行一条指令有四个步骤，IF | ID | EX | PC。</p><p>IF 比较简单，阅读 <code>instr_fetch</code> 可以发现，只是一次访问 <code>vaddr</code> 的询问，取其地址内容即可。</p><hr><p>开始 ID 并保证 <code>opcode1_0 == 0x3</code> 。（至于为什么，看文档去）</p><p>接下来是对 <code>opcode6_2</code> 进行 <code>switch</code>。其中 <code>IDEX</code> 是一份宏定义，在 <code>exec.h</code> 中。共进行了三步。确定 instruction 的宽度，通过宏定义 decode 到具体函数，通过宏定义执行具体函数。嘛，由于 switch 是使用跳表，所以会快一些。</p><p>我们在 switch 中使用的都是 IDEX，即默认将 width 置为 0。</p><blockquote><p>mips32和riscv32的访存指令会有不同操作数宽度的版本, 包括32位, 16位和8位, 因此我们还需要把宽度信息记录到<code>s</code>中提供后续过程使用.</p></blockquote><p>然后，设置完宽度后，我们花大篇幅来修改一下译码(ID)操作。给宏提供的参数为具体的 <code>I/S/U</code>，及会被解析为 <code>decode_load_I</code> 函数。依次类推。</p><p>然后是操作数(Operand)的控制，这要求我们进行进一步 Decode，由 Decode Helper Function 完成。 DHF 的宏定义在 <code>include/cpu/decode.h</code> ，而 Decode Operand Helper Function 的宏定义在 <code>local_include/decode.h</code> 中，目前只有两种操作，即 <code>decode_op_i</code> 和 <code>decode_op_r</code>，对应立即数和寄存器。在被宏定义的 <code>decode_op_r</code> 中，有一个 <code>op-&gt;preg</code>，是一个指向对应寄存器的指针。这样做避免了每次都访问 <code>reg_l(val)</code>。</p><p>被 DHF 定义的一系列函数基本都是重复的工程操作，查 specification 即可。照着这个类型，再多实现些指令类型也可。</p><hr><p>译码部分就这样，我们可爱的指令终于可以开始执行了。</p><p>执行部分的函数定义由 <code>def_EHelper</code> 进行。</p><p>需要执行的指令可能有多种情况，即 <code>isa.{}.funct3</code>  就可以区分不同指令，与 <code>funct3/funct7</code> 同时需要以区分指令。但是 <code>EX</code> 系列的宏并不允许我们在指令中进行 <code>switch</code>（你明明就可以不用它！），但是为了与 <code>load</code>, <code>store</code> 代码的整体性，我还是选择用 <code>EX</code> 宏 + 新添加一个函数来处理。</p><p>在操作寄存器的过程中，我们使用 <code>rtl</code>与<code>rtl pseudo</code>。<code>rtl pseudo</code> 存在的意义是方便我们使用 <code>rtl</code>。</p><p>总而言之，经过了大半周摸摸搞搞的修改（这部分没有写 <code>pa-record</code>），终于实现了 <code>RV32I</code> 和 <code>RV32M</code> 系列的指令，实现了部分 <code>klib</code> 后，离项目的完成又尽了一步（躺）</p><hr><p>接下来就是 I/O 的部分了，即设备的输入输出。</p><p>设备的输入输出有集中常见方式。端口 I/O 和内存映射 I/O。</p><p>前者的对寄存器操作设备的方案依赖于 <code>in/out</code> 指令。这两个指令能够负责向某个端口的寄存器写入某些值，设备读取这些值并且进行对应操作。</p><p>MMIO 则更加先进，在物理内存空间上分配一段空间给设备，然后 CPU 在操作某段内存的时候，不知不觉就操作了对应的设备。</p><hr><p><code>mainargs</code> 传入的过程：在 <code>nemu.mk</code> 的 line 19</p><pre><code class="c">CFLAGS += -DMAINARGS=\&quot;$(mainargs)\&quot;</code></pre><p>在编译时这个会被传入到 <code>mainargs[]</code> 变量中，再在 <code>_trm_inirt()</code> 中被传入到 <code>main</code> 函数中去。神秘。</p><hr><p>接下来让我尝试理清楚 NEMU 和 AM 在软硬件上配合的关系。</p><p>首先从硬件层的 NEMU 说起吧。NEMU 在每条指令运行的时候都会尝试观测 <code>device_update_flag</code> 的情况。如果为 <code>true</code>，则会在指令执行结束之后运行 <code>device.c</code> 中的 <code>device_update</code> 函数，这个函数目前（主要）负责：</p><ol><li>进行 <code>vga_update</code>，将会调用 <code>vga.c</code> 中的 <code>vga_update_screen</code> 函数，该函数会观测寄存器 <code>sync</code> 的情况，如果其值为 <code>1</code> 则真正意义上进行同步。</li><li>进行 <code>key_down</code> 的观测，这个是基于 SDL 的 API，就不深究了。</li></ol><p>既然现在要写显卡，我们来看一看 VGA 的部分。<code>update_screen</code> 函数会操作 SDL 读取 <code>vmem</code> 中的内容显示图像，我们姑且不管这一部分，回到软件层面来看一看。</p><p>既然 AM 是 NEMU 的抽象，我们就不能简单从“这俩会通信”来入手。</p><p>最基础的最基础的问题是，NEMU 是编译在 x86-64 上的，而 AM 是跑在 riscv32 上的。而事实上，NEMU 当然能获取自己的寄存器（及内存）信息，AM 也能修改其寄存器（及内存）信息。所以这俩就建立了通信。我们的目的是让自己写的 C 能跑在 riscv32 上。 AM 给用户程序提供了几个常规的 API，比如说 <code>io_read</code> 和 <code>io_write</code>。这两个函数能操作 AM 让 AM  让 AM 修改寄存器信息。</p><hr><p>声卡，虽然会很砖，但是必须实现。仙剑奇侠传怎么能没声音呢？</p><pre><code class="c">/* * * * * * * * * * AUDIO PART * * * * * * * * * * * * AURIO_CTRL   : Audio control, to change freq/channel/samples * AUDIO_STATUS : Used buffer size * AUDIO_PLAY   : Write [buf.start, buf.end) to buffer, wait until there&#39;s space * */AM_DEVREG(14, AUDIO_CONFIG, RD, bool present; int bufsize);AM_DEVREG(15, AUDIO_CTRL,   WR, int freq, channels, samples);AM_DEVREG(16, AUDIO_STATUS, RD, int count);AM_DEVREG(17, AUDIO_PLAY,   WR, Area buf);// * * * * * * * * * AUDIO PART * * * * * * * * * * *</code></pre><p>首先我们来分析一下 <code>am-tests</code> 中的 <code>audio.c</code>。这是一段播放小星星的代码。</p><p><code>audio.c</code> 最开始是检测 <code>AM_AUDIO_CONFIG</code> 的 <code>present</code> 是否为 <code>true</code>，当然，我们需要将其设为 <code>true</code>。</p><p>接下来是初始化 <code>freq</code> 等基本信息，略过。</p><p><code>AUDIO_PLAY</code> 需要一段 <code>Area</code>，用于存即将写入 <code>buffer</code> 的内容…</p><p>我靠，从昨天晚上写到刚才，终于能跑了，来检讨一下笨死了的自己。</p><p>我实现的是一个由 AM 上的 <code>push</code> 和 nemu 里的 <code>pop</code> 维护的一个 queue，这个 queue 装在对应内存里。内存的前 8 个字节用于装 <code>head</code> 和 <code>end</code>，是队列所对应的循环数组的首尾。</p><p>由程序调用 <code>AM</code> 中的 <code>__am_audio_play</code>，其会等待直到 <code>buffer</code> 中有空余空间后进行写入。这里其实有不少问题，是依赖于主机的 context switch 的，所以我采用一种比较保守的实现，但是实际上好像… 额，性能比较弱。即在 <code>push</code> 和 <code>pop</code> 函数内部对 queue 的 size 通过 MMIO 进行维护。 之后可以在这里多想想，然后尝试实现一些以一个 <code>segment</code> 为单位的队列？性能应该会高不少。</p><p>SDL 的回调函数每次会取 2048 个元素（有可能），性能还算不错。但是 <code>push</code> 那边的话因为需要等待空间，性能就比较弱。</p><p>不过第一次写是为了正确实现，抽象的比较高。现在的实现应该是没有问题的，如果仙剑那边跑的实在太卡的话我就用 <code>mem</code> 系列指令重写一下。（虽然 <code>mem</code> 系列我也没优化就是了，肯定要优化一下的，比如给 mem 系列实现一个硬件层的接口让宿主来进行 memset ？？？x）</p><p>之后有心情的话可以去读一下 LiteNES 的代码，这次就算了。居然还能学优化x 之后再说。</p><hr><h2 id="PA3"><a href="#PA3" class="headerlink" title="PA3"></a>PA3</h2><p>PA3 这部分比较难懂，有一些 <code>undoc feature</code>。</p><p>我们来做那个必答题，<code>yield()</code> 调用之后发生了什么。</p><p>进入了 <code>yield</code> 函数，将 <code>a7</code> 作为参数（即 <code>sstatus</code>）传给了 <code>ecall</code>，<code>ecall</code> 执行对应操作，并调用 <code>raise_instr</code> 执行了设置 <code>sepc</code> 和设置 <code>scause</code> 等操作。需要注意，在 <code>cte_init</code> 中，我们将 <code>__am_asm_trap</code> 的<strong>函数指针</strong>传入了 <code>stvec</code>，所以其会 <code>jmp</code> 到 <code>__am_asm_trap</code> 里。<code>__am_asm_trap</code> 的操作相对比较迷惑，大概意思就是在栈里初始化了 <code>Context*</code>，于是在接下来的函数就能访问之前的内容。大概是，这样吧。我是有点没读懂的。</p><hr><p>我一直不太熟悉 ELF 的格式，今天再来 review 一下。</p><blockquote><p> ELF 有面向链接的 section 视角，提供了可重定位信息。第二个是面向执行的 segment 视角，这个视角提供了加载可执行文件的信息。 通过 <code>readelf</code> 我们能看到 <code>section</code> 和 <code>segment</code> 的映射关系。</p><p> ELF 采用 <code>program header table</code> 来管理 <code>segment</code>。通过 <code>ehdr</code> 来管理 <code>section</code>。其中 <code>ehdr</code> 包含了所有 <code>segment</code> 放置的位置（通过一个数组）</p><p> 所以我们的 <code>loader</code> 需要负责加载所有的 <code>segment</code>。</p></blockquote><p>ELF 还有很多我不太熟悉的操作，还是以后遇到问题 <code>man 5 elf</code> 吧。（上面的东西是前几天写的了，懒得补充了）</p><hr><p>今天我们再来梳理一下从 <code>hello.c</code> 到最后程序运行的过程。</p><p><code>hello.c</code> 由其 Makefile 管理。这里再让我吐槽一下 CLion 的逻辑，Makefile 在 CLion 里完全不可用（躺）。我也不想一点一点做移植，就这样将就了。</p><p>然后我们将 <code>hello.c</code> <code>mv</code> 到 <code>ramdisk.img</code>，其为一个已经并未链接的 elf。它会在 nanos-lite 链接的时候由 <code>resource.S</code> 链接到其 <code>.data</code> 段中。（？？？感觉这操作好神秘）</p><pre><code class="asm">.section .data.global ramdisk_start, ramdisk_endramdisk_start:.incbin &quot;build/ramdisk.img&quot;ramdisk_end:// ...</code></pre><p>关于上述步骤，用 <code>readelf</code> 查看 nanos-lite 的编译结果可以看到，<code>.symtab</code> 里有 <code>ramdisk_start</code> 和 <code>ramdisk_end</code> 的痕迹。<code>ramdisk</code> 的一系列 API 能够让读取该段内存的内容。而我们的 <code>loader()</code> 则负责将该段内存读取到其应该存在的地方。（即其自身 ELF header 设置的 entry 及其之后的内容）</p><p>既然 <code>loader</code> 返回了 <code>entry</code>，<code>naive_uload</code> 将 <code>pc</code> 切换到 <code>loader</code> 的 <code>entry</code>，即开始运行 <code>ramdisk</code> 的内容了。</p><p>关于 <code>ecall</code> 的部分我再给自己哆嗦两句。<code>ecall</code> 的类型参数存放在 <code>a7</code> 中，我们规定 <code>a7  = [0..20)</code> 是系统调用。其编号的具体内容在 navy_apps 的 <code>syscall.h</code> 中存放着。<code>syscall.c</code> 中实现了一些系统调用（说来我咋觉得这些东西该放在 nanos-lite 中呢，不过放在 navy-apps 中也有一定道理倒是x）</p><hr><p>终于写完虚拟文件系统了… 写了一周多。这套文件系统里有不少的坑，我们慢慢道来。</p><p>虚拟文件系统又是一层抽象（尽管会略微降低性能？），我们实现了一份比较简单的文件系统，支持基础的读写操作。虚拟文件系统实现的核心是，为特殊文件实现特殊的读写函数，而这个读写函数不一定是针对储存空间操作的，可能是针对某一些特殊的数据流操作的。当然，通用的读写函数也是必须被实现的，这些读写函数将操作真正的一块处于硬盘（？）中的一块被抽象的，称作文件的空间。关于文件的格式已经研究过了，在这里就不再赘述。</p><p>我们在此处只需考虑那些特殊的，“被抽象”出来的文件。比如：</p><pre><code class="c"> typedef struct {  char *name;  size_t size;  size_t disk_offset;  ReadFn read;  WriteFn write;} Finfo;// ...{&quot;/dev/events&quot;, 0, 0, events_read, invalid_write},{&quot;/proc/dispinfo&quot;, 0, 0, dispinfo_read, invalid_write},{&quot;/dev/fb&quot;, 0, 0, invalid_read, fb_write},</code></pre><p>这三者是被抽象出的文件，抽象出的文件的核心在于那个 <code>ReadFn</code> 函数，这个函数是可以被自行定义的，比如 <code>dispinfo_read</code> 就会调用 AM 中实现的一系列接口，返回一段字符。这段字符并没有放在硬盘上。</p><p>在对文件读写时，首先尝试调用 <code>ReadFn</code> 以及 <code>WriteFn</code>，若失败，才会跌落至常规的对文件的读写。</p><p>在此基础上实现了 <code>device.c</code> 中的一系列函数，包括：</p><ul><li><code>serial_write</code>: 串口输入输出，抽象为 <code>stdout</code>/<code>stderr</code></li><li><code>events_read</code>: 从 <code>AM_INPUT_KEYBRD</code> 获取键盘输入信息，抽象为 <code>/dev/events</code></li><li><code>dispinfo_read</code>: 已经提到了</li><li><code>fb_write</code>: 是显存的抽象，实现不太友好（还有不少瑕疵），不想提了。</li></ul><p>总而言之，经过了一段时间，已经解决了这部分的内容，该进入 PA3 的最后一部分啦！</p><hr><blockquote><p>Fixed-point arithmetic</p></blockquote><p>神秘的，可以避开 FPU 实现的方法。</p><p>定点算数实现的核心是避开 IEEE 标准，自己实现一套更加简便的，和当前 ALU 同构的规范。浮点数和定点数的运算本身没有过大的区别，都是数字和数字的碰撞，IEEE 标准徒增功耗（不）</p><p>于是我们定义一套新的标准，对于一个实数 $a$，我们将其表示为 $A = a \cdot 2^8$，在内存中存储为</p><pre><code>31  30                           8          0+----+---------------------------+----------+|sign|          integer          | fraction |+----+---------------------------+----------+</code></pre><blockquote><p>（书里的图，我就嫖来了）</p></blockquote><p>鉴于小数的最低位是在 $2^{-8}$，我们乘上 $2^8$ 之后可以建立一套双射。</p><p>回答这个问题：</p><blockquote><p>阅读<code>fixedpt_rconst()</code>的代码, 从表面上看, 它带有非常明显的浮点操作, 但从编译结果来看却没有任何浮点指令. 你知道其中的原因吗?</p></blockquote><p>确实啊（沉思），先总结一下，<code>fixedpt</code> 让编译器来负责大部分的浮点处理。</p><p>我们用 <a href="https://godbolt.org/" target="_blank" rel="noopener">godbolt</a> 来测试一下，<code>int a = (int)1.333;</code>，得出的指令并没有浮点运算。<code>fixedpt_rconst</code> 也同理</p><pre><code class="c">#define fixedpt_rconst(R) ((fixedpt)((R) * FIXEDPT_ONE + ((R) &gt;= 0 ? 0.5 : -0.5)))#define FIXEDPT_ONE    ((fixedpt)((fixedpt)1 &lt;&lt; FIXEDPT_FBITS))</code></pre><p><code>FIXEDPT_ONE</code> 则是之前提到的 $2^8$，这部分预处理会在编译器完成。而例如，$-1.2$，会出现 $-1.2 \cdot 2^8 - 0.5 \rightarrow -307.7 \rightarrow -307$ 的情况，这个 $\pm0.5$ 估计是拿来修正整数值的吧。晕乎乎，不管了。</p><hr><p>稍微深挖一下 <code>switch_boot_pcb()</code> 的作用，切换到 boot pcb 有什么好处啊？</p><pre><code class="cpp">void switch_boot_pcb() {  current = &amp;pcb_boot;}</code></pre><p>就干了这么简单一件事，再看我们目前的 <code>schedule</code> “算法”</p><pre><code class="cpp">Context* schedule(Context *prev) {  current-&gt;cp = prev;  current = (current == &amp;pcb[0] ? &amp;pcb[1] : &amp;pcb[0]);  return current-&gt;cp;}</code></pre><p>这个问题我思考了好一会儿，还是得跳回 <code>main</code> 函数开始思考。一切的一切都是从 <code>main</code> 函数里调用那次 <code>yield()</code>，开始，走过我画的图中的那些部分，一直走到需要 <code>schedule</code> 的部分。</p><hr><p>解决了，没啥用，大概是 PA 没有描述到的地方，关于回到 <code>pcb_boot</code> 之后该如何调度，这个问题先不管它了… 等遇到复杂的调度问题再说。</p><hr><blockquote><p>不过, 这片空闲的内存位置是操作系统的加载器在加载时刻指定的, 但进程代码真的可以在这一内存位置上正确运行吗?</p></blockquote><p>对对对，我也想问这个问题（不是）</p><p>以前的方法是使用绝对代码，但是这种方法比较笨，程序会维护多个不同加载地址的版本，并且祈祷其中一份能被加载成功。</p><p>一旦存在抽象，就可以通过同构映射出各种奇奇怪怪的东西，比如说 cache，一切可以写入可以读出的东西。但是，对于进程的管理理论上来说，需要操作系统的协助。所以说虚拟内存是一个软硬协同的过程。通过 CPU 内部的 Memory Management Unit。</p><blockquote><p>所谓虚拟内存, 就是在真正的内存(也叫物理内存)之上的一层专门给进程使用的抽象.</p></blockquote><p>然后讨论了一下分段机制的问题，因为分段实在太过混乱，所以我们需要分页。分页机制能够让我们以更低的成本重载代码，之类的。</p><p>分页中的虚拟地址，有如下的表示：</p><p><img src="https://p.sda1.dev/1/20be5ddb765834950e53e28e62904124/image.png" alt="image"></p><p>其中 <code>page offset</code> 为 12 位，刚好足以表示 4kb, 而 V P N (virtual page number) 用于帮助页表进行索引，找到物理地址所属的 frame.</p><p>riscv32 采用二级页表的玩法，每一个进程维护一个页目录，页目录通过 <code>VPN[1]</code> 索引到页目录项，页目录项包含了页表的起始地址，我们通过页目录项找到页表。再在页表中通过 <code>VPN[0]</code> 找到对应页面的物理地址，通过 <code>page offset</code> 找到对应的物理地址。页表中保存的内容均为物理地址。 <a href="[https://xy-plus.gitbook.io/rcore-step-by-step/ye-biao-jian-jie](https://xy-plus.gitbook.io/rcore-step-by-step/ye-biao-jian-jie)">参考</a> 和 <code>riscv-privileged.pdf</code></p><blockquote><p>于是，对一个 null pointer 解引用的时候，实际上发生了页表的访问。至于具体，就是左侧所述的几个步骤。</p></blockquote><p>于是，页表可以抽象成这样的一个函数！对，是我最爱的抽象</p><p>$$<br>y = \mathrm{page}(x)<br>$$</p><hr><blockquote><p>抽象的生命力就在于：尽管人们往往不会注意到，但她能仅仅通过在一整个对象之间插入一层，就使逻辑变得简单了许多。抽象↔同构</p></blockquote><hr><p>这个所谓的 <code>page</code> 函数实际上可能会很复杂，</p><hr><p>因为 page table walk 的行为可能很频繁，而多次访问同一个地址的可能性也很高。每次 page table walk 的成本可能比较高，于是就有了TLB。TLB 缓存了一些之前的结果。</p><p>页表本身是针对进程为单位维护的，所以 TLB 也需要考虑进程的问题。x86 的方法比较暴力，直接在 CR3 更新的时候冲刷 TLB 的内容，保留 Global 位为 1 以避免系统调用的时候发生 TLB Miss.</p><p>Cache 的性能至关重要，因为访问之与访问内存的效率千差万别。</p><p>mips32 中，TLB 的填充由软件进行（天哪？）。</p><hr><p>读完了 VME 实现要求的部分… 真的好复杂…</p><p>总结起来，有这几点需要实现的</p><ul><li>由操作系统填入页表的映射，由 <code>map</code> 函数进行</li><li>由操作系统管理的具体的 page 分配 <code>pg_alloc()</code> 等函数</li><li>由 CPU 内 MMU 管理的具体的虚拟地址解析</li></ul><p>我觉得我先花点时间搞点研究，think twice, code once.</p><p>至于之前 PA 所说的是通用的，我们现在针对 Sv32 进行一些细致的学习。</p><p><a href="https://www.notion.so/Sv32-Page-Based-32-bit-Virtual-Memory-Systems-f5c3a66dcca14b7c8e374728d4d92762" target="_blank" rel="noopener">Sv32: Page-Based 32-bit Virtual-Memory Systems</a></p><h2 id="PA4"><a href="#PA4" class="headerlink" title="PA4"></a>PA4</h2><p>我们还是先开始 PA4 好了，毕竟 PA3 的后面部分有点砖。我简单修了一下批处理系统那套，应该能够基本运行了。不过我还是对分时多任务感兴趣一点，于是就先做 PA4 了。</p><p>PA4 难度不低，我们先解决基本的 Context Switch 的问题。分为几步比较神秘的。</p><p>首先把 <code>Context</code> 和 <code>PCB</code> 的定义扔在这里。</p><pre><code class="c">typedef union {  uint8_t stack[STACK_SIZE] PG_ALIGN;  struct {    Context *cp;    AddrSpace as;    // we do not free memory, so use `max_brk&#39; to determine when to call _map()    uintptr_t max_brk;  };} PCB;struct Context {  uintptr_t gpr[32];  uintptr_t cause, status, epc;  void *pdir;};</code></pre><p>其定义比较清晰，<code>PCB</code> 的意思是进程控制块，用户保存内核栈和 <code>cp</code>，<code>Context pointer</code>，指向保存的用于 Context switch 的“虚假的上下文”。而这个虚假的上下文是虚假给 <code>trap.S</code> 看的，<code>trap.S</code> 会还原这个偷梁换柱的上下文中的信息，并且通过 <code>sret</code> 跳转到其 <code>epc</code> 的位置。偷梁换柱进行的位置是 <code>trap.S</code> 中的 <code>jal __am_irq_handle</code>，这个函数会产生返回值并且放在 <code>a0</code>。我们只需 <code>mv sp, a0</code> 即可漂漂亮亮地替换被还原的上下文。</p><p><code>init_irq</code> 的时候调用了 <code>cte_init</code>，<code>do_event</code> 被作为全局变量<code>user_handler</code> 放入到了 <code>cte.c</code> 中，这个函数指针今后会在 <code>__am_irq_handle</code> 调用，并且会返回 <code>c</code>，在 <code>trap.S</code> 中的 <code>a0</code> 寄存器被接收，先不谈这里。</p><p><code>kcontext</code> 会创建一个上下文，将其放在 <code>kstack</code> 的最底部。然后 <code>PCB</code> 的 <code>union</code> 会将 <code>cp</code> 指向 <code>context</code> 的顶部。<code>sret</code> 会将这玩意儿倒回 <code>Context</code> 设定的位置，开始 <code>Context</code> 部分的运行。</p><p>为了清晰地解释，画一张图。</p><p><img src="https://p.sda1.dev/1/544e01f72a3251751867da0461d29ebb/image.png" alt="image.png"></p><p>为了节约空间（懒）我没有画3一些细节的部分。</p><blockquote><p>[实在太久没有阶段性的成就感了，先把这玩意儿丢到博客里好了]</p></blockquote><hr><p>因为期中考试的原因，有很长一段时间没有写代码，这里回来总结一下。分页机制的实现是为了虚拟内存，这段实现比较复杂，请听我慢慢道来。</p><p>我们从零开始总结一下虚拟内存的支持机制。首先，在任意一次  <code>set_satp()</code> 函数运行前，CPU 均没有开启 VME（因为 <code>set_satp()</code> 函数将设置的值 xor 了 <code>0x80000000</code>，即将最高位设置为 1，开启 VME）.</p><p>在 qemu 初始化过程中，直到运行到 <code>vme_init</code> 之前，都不会处理 VM. 比较有意思的是，在 VME 开启后，nemu 中的 <code>isa_vaddr_check</code> 函数会返回 <code>MEM_RET_NEED_TRANSLATE</code>，即这次内存访问是依赖于 page table walk 的。<code>isa_mmu_translate</code> 会进行 page table walk（它会获取 <code>satp</code> 中 <code>ppn</code> 的值作为 root）。</p><p>现在我们看回 nanos-lite 的部分，nanos-lite 中实现了 <code>map</code> 函数，用于初始化页表。具体实现就不讲了，这里稍微强调一下，任意一个内存地址，都是由一级/二级页表的访问下标和 offset 组成。<code>vaddr</code> 就是 <code>[vpn][vpn][offset]</code> 构成，要索引一个 <code>vaddr</code> 的物理地址，首先获取 <code>satp</code> 的值，然后将其中的 <code>ppn</code> 转换为根页表的初始位置，并且用 <code>vpn1</code> 作为下标在根页表中找到指名下一级页表的 pte(page table entry), 再次使用它的 ppn 计算到下一级页表的具体地址，然后使用 <code>vpn0</code> 再次索引，找到最终的 leaf pte, 计算其 <code>ppn</code> 表示的位置（即 paddr 所在的物理页的地址），并且加上 <code>offset</code>，得到最终的 paddr.</p><p>真的好绕，但是好歹还是实现完了， 但是这只是噩梦的第一步。</p><p>你会发现，之前写了半天的用户进程，居然还需要添加 VME 支持。主要修改了以下部分（按照我实现的时间顺序）</p><ul><li><code>context_uload</code> 中，为 AddrSpace 添加一个页表。<ul><li><code>context_uload</code> 中，</li></ul></li></ul><hr><p>好家伙，后期的 <code>bug</code> 一个比一个玄妙，反正就是极难。还是最好做一步测试一步。</p><p>第一个遇到的是，我找了很久，发现出现了一个空指针的问题，但是我无论如何也没找到空指针是在哪里。读了半天代码，我让它运行起来，结果发现，明明是被初始化为 <code>NULL</code> 的全局变量，居然有值。改这个 BUG 的时候有点浮躁，总之找了好久才发现是 loader 中没有处理 <code>filesz</code> 和 <code>memsz</code> 的边界条件，导致 <code>bss</code> 段等末尾的 <code>section</code> 加载后没有清零（当然，也是因为我的 <code>fs_read</code> 写丑了）</p><p>于是，第一个 <code>bug</code> 通过修改 <code>loader</code> 解决了。</p><p>现在我遇到的是，程序会莫名其妙 <code>HIT BAD TRAP</code> 掉。但是我根本没有地方调用 <code>halt()</code> 啊？于是经过大概一个小时的寻找，我发现 <code>halt()</code> 恰好被放在了 <code>putch() + 4</code> 的位置。这里就出现问题了，如果刚好在 <code>ret</code> 或者 <code>jmp</code> 的位置切换 <code>Context</code>，那锅就大了。</p><p>因为一次指令运行的顺序是这样的：前面的忽略，等指令运行结束，这时候所有的状态本应该是确定的。但是还要检查一次 <code>INTR</code>，如果 <code>intr</code> 为 <code>true</code>，之前放在 <code>jmp_pc</code> 中的值就会被忽略掉，<code>jmp</code> 指令的操作就失效了。于是我们需要特判一下前面是否进行的是会更改 <code>pc</code> 的指令。</p><pre><code class="c">  if (s-&gt;is_jmp == 1) {    reg_csr(0x141) = s-&gt;jmp_pc;    reg_csr(0x142) = NO;    s-&gt;jmp_pc      = epc;  } else {    s-&gt;is_jmp      = 1;    s-&gt;jmp_pc      = epc;    reg_csr(0x141) = s-&gt;seq_pc; // set sepc &lt;- seq_pc    reg_csr(0x142) = NO;        // scause  }</code></pre><p>这样才能解决问题。</p><p>解决这个问题的时间里，我最开始是猜测 <code>SPIE, SIE</code> 构成的状态机会有一些问题，导致 <code>trap.S</code> 中的 <code>sstatus</code> 被还原后直接在 <code>trap.S</code> 运行一半时出锅，但实际上就不是这个问题。</p><p>但是在实现 VME 之后，性能就变得极拉，也暂时也无法优化了。</p><p>其中我还遇到了著名的 Heisenbugs, 即一调试就会消失的 bug.</p><p>主要的 bugs 应该就是这两个，解决之后用户线程和内核线程已经可以共存了。</p><hr><p>该解决最终的 ‘bug’ 了，用户线程的并行问题。</p><p>据说这是最难的问题，我也试了好久… 可惜完全没有头猪。根据 PA4 最后给出的解答：</p><p>最简单的情况，在 <code>A</code> 与 <code>B</code> 之间进行调度。假设目前，我们可爱的操作系统受到了硬件中断，要将 <code>A</code> 切换为 <code>B</code>.</p><p><code>trap.S</code> 最开头会将所有的内容保存到 <code>A</code> 的用户栈上，然后调用 <code>__am_irq_handle</code>，坑就坑在 <code>__am_irq_handle</code> 的最后更改了内存地址空间，切换为了 <code>B</code> 的内存地址空间。</p><p>然后，我们执行了 <code>return c;</code>。 但这时候的 <code>c</code>，已经不是之前的 <code>c</code> 了。这时候的用户栈是 <code>B</code> 的用户栈，一切的 <code>sp</code> 操作都是错误的。</p><p>比如说，<code>c</code> 是在 <code>a0</code> 中(<code>__am_asm_trap</code> 中调用的时候，是把 <code>Context</code> 指针根据调用约定扔在 <code>a0</code> 中的)，而 <code>return</code> 后，可能根本回不到正确的地点。</p><hr><p>这个问题先搁置了，比较恼火…</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Recapture That Power of Setu</title>
      <link href="2021/02/04/ghs/"/>
      <url>2021/02/04/ghs/</url>
      
        <content type="html"><![CDATA[<p>这件事儿还挺有意思的（挠头），水一篇博客。</p><blockquote><p>不是一篇技术博文，这是为了爱和正义与网络安全进行的斗争</p></blockquote><a id="more"></a><hr><p>因为不知道什么原因，2021/2/3 日，我终于发现是因为一些神秘的问题，进而导致无法自定义 header 的 eagle extension 无法方便地从 pixiv 上下载色图！</p><p>盗链这部分就使用 firefox 测试了，比较简单。</p><p>这本应该是一个容易解决的问题。我只是想下色图，而下色图只需要在 <code>referer</code> 中添加 <code>https://www.pixiv.net</code> 即可。但是这件事儿落到 eagle extension 上就变复杂了，因为涉及阅读的 eagle extension 源码的问题，还涉及浏览器安全的问题。</p><p>首先进到 edge 的插件目录里，找到 eagle 的插件，复制出去，然后进行修改。通过开发者模式进行导入。</p><p>观察到下载图片的核心函数，<code>background.js</code> 的 <code>line: 480</code>(and 380，注意有两处，分别对应拖拽和右键菜单) 左右出现了获取图片 base64 等操作。</p><pre><code class="javascript">ensureEagleIsOpen(function () {  msg.src = convertSrc(msg.src);  if (!msg.src) return;  // console.time(&quot;取得图片 base64&quot;);  toDataURL(msg.src, function(base64) {    // console.timeEnd(&quot;取得图片 base64&quot;);    var result = base64 || msg.src;    var data = {...</code></pre><blockquote><p>不得不吐槽一句 <code>toDataURL</code> 的可读性简直了，还把 <code>custom</code> 拼错了</p></blockquote><p>其一部分代码是这样的</p><pre><code class="javascript">xhr.onload = function() {  clearTimeout(timeout);  var reader = new FileReader();  reader.onloadend = function() {    if (!sent) {      sent = true;      if (reader.result.indexOf(&quot;data:image&quot;) &gt; -1) {        callback(reader.result);      } else {        callback(undefined);      }}}  reader.readAsDataURL(xhr.response);};...timeout = setTimeout(function () {  if (!sent) {    sent = true;    xhr.abort();    callback(undefined);  }}, timeout);</code></pre><ol><li><blockquote><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestEventTarget/onload" target="_blank" rel="noopener"><code>XMLHttpRequest.onload</code></a>  <code>callback</code> is the function to be executed when the request completes successfully.”</p></blockquote></li><li><blockquote><p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/FileReader/onload" target="_blank" rel="noopener"><code>FileReader.onload</code></a> property contains an event handler executed when the <code>load</code> event is fired.</p></blockquote></li></ol><p>总而言之，这段代码通过 <code>toDataURL</code> 来尝试获取对应图片的 base64，若失败，将 URL 再传给主程序处理，而主程序端若接受到 URL，则通过代理再次尝试获取该图片。现在的情况是，两次都失败了，因为两次都没有，也不可能设置 <code>referer</code>。</p><p>尝试使用服务端的方法，观察到 eagle 有两套 API，一套是官方最近公布的<a href="https://www.yuque.com/augus-gsjgn/eagle-api" target="_blank" rel="noopener">Open API</a>，还有一套是原本用于 extension 和主程序通信的 API，端口号分别为 <code>41593</code> 与 <code>41595</code>。由于无法获取原 API 的信息，只能使用开放的 API。</p><p>尝试通过官方文档中的模板测试 eagle 服务端是否能进行下载，结论是不行，eagle 的进度条会卡住最后下载失败。</p><pre><code class="javascript">var data = {  &quot;url&quot;: &quot;https://i.pximg.net/img-original/img/2021/02/02/19/18/33/87484491_p0.jpg&quot;,  &quot;name&quot;: &quot;Test&quot;,  &quot;headers&quot;: {    &quot;referer&quot;: &quot;https://www.pixiv.net&quot;  }};var requestOptions = {  method: &#39;POST&#39;,  body: JSON.stringify(data),  redirect: &#39;follow&#39;};fetch(&quot;http://localhost:41595/api/item/addFromURL&quot;, requestOptions)  .then(response =&gt; response.json())  .then(result =&gt; console.log(result))  .catch(error =&gt; console.log(&#39;error&#39;, error));</code></pre><p>我使用其他的链接试了试，似乎 eagle 本身在 Open API 这部分的实现有部分问题，最明显的表现是 <code>添加文件 (0/0)</code>…</p><p>求求你赶紧把这部分的功能做好吧，我只能自己实现了orz</p><p>虽然不知道为什么，不过现在剩下的解法只有通过传递 base64 的方式来下载图片。<code>jQuery</code> 为了安全问题禁止更改 header 中的 <code>referer</code>，于是只能通过服务端的 <code>request</code> 来运行。</p><hr><p>这里又因为经验吃亏了，我也测试了通过 <code>fetch</code> 来包含 header 信息，依然不行。通过抓包显示 <code>fetch</code> 根本没有添加上 <code>referer</code> 参数，似乎也是因为 ajax 不允许修改 <code>referer</code> 的问题。</p><p>再换方法，根据 <a href="https://stackoverflow.com/questions/53627310/using-fetch-in-chrome-extension-doesnt-include-referer-header-in-the-request" target="_blank" rel="noopener"><code>stackoverflow</code> 上的办法</a>，可以通过给插件提供 <code>webRequestBlocking</code> 权限来发送修改 <code>referer</code> 参数。</p><p>好家伙，依然不行。</p><pre><code class="javascript">chrome.webRequest.onBeforeSendHeaders.addListener(  function(details) {    details.requestHeaders.push({name: &#39;Referer&#39;, value: &#39;https://www.pixiv.net&#39;});    return {requestHeaders: details.requestHeaders};  },  {urls: [&quot;http://i.pximg.net/*&quot;]},  [&quot;blocking&quot;, &quot;requestHeaders&quot;]);fetch(&#39;http://i.pximg.net/img-original/img/2021/02/02/19/18/33/87484491_p0.jpg&#39;)</code></pre><p>现在想来，应该就是跨域访问的问题，浏览器阻拦 referer 天经地义，只有我是傻逼和网络安全斗智斗勇。</p><hr><p>除此之外，我还考虑了绕开 referer 的办法，即使用（及其古老的）referer killer 的思路，可惜在 2021 年早已行不通。</p><p>那么，不考虑和浏览器斗智斗勇，现在的解决办法有几个</p><ul><li>搭建“反代”来绕过无法发送带 referer 请求的问题</li><li>写油猴脚本，通过油猴脚本来发送带 referer 的请求，已证明可行，但是工程量不小，我有点懒</li><li>还有一个，通过 inject code 来让浏览器自己发 referer（后续验证不太可行）</li></ul><hr><p>一觉睡了起来，脑子清醒了很多，重新找问题。</p><p>查一查 log，发现 eagle 2.0.0 版本更新是在 2021/1/21，而我最后一张图是在 2021/1/21 晚存的。再次查 log 发现，之前的内容都是通过 base64（见后） 下载的</p><pre><code>[extension] version: 2.1.8 - Save image: [base64][2090658], source: https://www.pixiv.net/artworks/87159236</code></pre><p>所以有两种可能性，eagle 插件更新，edge 更新和 pixiv 外链政策更新导致的问题。</p><p>去查 qq 聊天记录，看到 edge  88 更新是在 2021/2/22 日（当时我去吐槽了好好看），现在唯一需要的是一个老版本的 eagle extension 插件。发现 extension 更新是 1.12 日，更不可能了。在之前发送请求的时候，edge 可能会回以缓存，现在的机制变化了。</p><p>但是换回老版本的 edge 不太可行，这段思考只能帮助我坚定地确定了，和浏览器斗智斗勇是不可能的，最优雅的解决办法是通过 inject code。那，终于到了写代码的时候了。</p><hr><blockquote><p>敢情我昨天一晚上白忙了啊… 不过也算学了不少东西</p></blockquote><p>草，结果是，inject code 也没能解决问题，依然因为 CORS 限制。目前已知油猴脚本可以突破 CORS 的限制，但是完全不知道是怎么做到的。</p><p>通过在原脚本中添加</p><pre><code class="javascript">console.log(msg.src);chrome.tabs.executeScript(  tab.id,  { code: `window.inject_url = &quot;${msg.src}&quot;;` },  () =&gt; {    chrome.tabs.executeScript(      tab.id,       { file: &quot;pixiv.js&quot; },       (res) =&gt; {        console.log(&quot;Exec: &quot; + res);      });  });</code></pre><p>可以实现简单的跨域传递参数和返回参数，</p><p>脚本中的对应函数如下</p><pre><code class="javascript">(function () {  console.log(&quot;Downloading&quot;: window.inject_url);      var ret;  function getPixivImage(url) {    var xhr = new XMLHttpRequest();    var timeout = 700;    var sent = false;    // From background.js    xhr.onload = function () {      clearTimeout(timeout);      var reader = new FileReader();      reader.onloadend = function () {        if (!sent) {          sent = true;          if (reader.result.indexOf(&quot;data:image&quot;) &gt; -1) {            ret = reader.result;          } else {            ret = undefined;          }        }      };      reader.readAsDataURL(xhr.response);    };    xhr.open(&quot;GET&quot;, url);    xhr.responseType = &quot;blob&quot;;    xhr.send();    timeout = setTimeout(function () {      if (!sent) {        sent = true;        xhr.abort();        ret = undefined;      }    }, timeout);  }  getPixivImage(window.inject_url);  return ret;})();</code></pre><p>为了防止 CSRF，这里会不工作也情有可原… 又是一个没有想到的地方。那，估计只能调用油猴脚本了，这操作越来越复杂了。</p><p>油猴脚本的 <code>GM_xmlhttpRequest</code> 可以实现跨域访问，但是还不太清楚其原理。</p><p>但是从外部访问油猴脚本看起来就不太可能… 最终办法真的只有用油猴和 eagle extension 配合了吗？</p><ul><li>使用油猴脚本进行跨域访问，将结果写入全局变量中（使用 messaging 也行）</li><li>通过<code>pixiv.js</code> 获取全局变量和油猴脚本对接，实现简单的跨域访问。</li></ul><p>这里还需要了解 CORS 的简单请求有关内容。满足一系列条件（懒得ref）的请求为简单请求，而简单请求是先发送信息再检查。但是这回的 GET 中含有 referer，所以依然无法满足简单请求的条件。</p><p><a href="https://www.chromium.org/Home/chromium-security/extension-content-script-fetches" target="_blank" rel="noopener">这篇文档</a>里描述了 content scripts 在 chromium 88 里已无法跨域。</p><hr><p>我开了 bgm 上的<a href="https://bgm.tv/group/topic/361172" target="_blank" rel="noopener">讨论</a>。</p><hr><p>好家伙了，我直接好家伙，最后的解决方式有两个</p><p>第一个是，在 bgm 的讨论里有人提到给 eagle 发了 email 请求更改这部分的逻辑，然后… 然后更新版本后问题就解决了。</p><p>第二个是添加反代（没想到基于 cloudflare worker 的反代那么简单？！），既然问题已经解决了就不做了。</p><p>eagle 新版本的逻辑也很奇怪，会先将文件下载到一个 temp 目录里再让主程序从这个目录 fetch 图片。但是这就导致了一个问题：无法 retry。这是个很简单的问题，只要修改一下 retry 的逻辑就好了，但是 eagle 团队就是没有做好…</p><p>而且，什么时候能把设置代理给加回来… 我服气啦</p><p>有很多很幼稚的地方和问题，这就当成变强过程中的一篇幼稚的博文吧。</p><p>不过在写这篇博文里我有这样的感受，以前学的看似“无用”的东西总会有用武之地。哪怕是我已经放弃了的 CTF 也提供给了不少解决问题的能力。感谢自己写过的每一行代码，感谢自己学过的每一个奇奇怪怪的知识。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Learning Cpp</title>
      <link href="2021/01/22/Learning-Cpp/"/>
      <url>2021/01/22/Learning-Cpp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>From C++ Primer (5th edition)</p><p>From OI to Engineering</p></blockquote><a id="more"></a><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ul><li>引用 == 别名。</li><li>引用的初值必须是一个同类型对象</li></ul><ul><li>顶层 const：指针本身是常量，<code>int *const a = &amp;i;</code></li><li>底层 const：指针指向的内容是常量，<code>const int *p2 = &amp;c1;</code></li></ul><p>按照经验来说，复合类型的判断通过打括号来进行。如 <code>(int*) (const a = &amp;i);</code> 最靠近其的符号即其具体内容，”a 本身是个常量“。后者最靠近其的为<code>*</code>，说明其是个指针。</p><p>const expression 的定义为，需要在编译时就能计算得到结果的表达式。一旦你认定一个值为常量表达式，使用 <code>constexpre</code> 申明即可（这样是不是能够编译时计算圆周率）</p><p>在 type alias 中，可以使用 <code>typedef</code> 来创建类型别名。比如 <code>typedef double base, *p;</code>，在新方法中，可以使用 <code>using db = double;</code></p><p>除了 <code>auto</code>，还有 <code>decltype</code> 能用于进行类型推断。<code>decltype(f())</code> 甚至可以推断函数返回值的类型。<code>decltype((var))</code> 的结果永远是引用</p><pre><code class="cpp">int b = 1, _b = 2;int *c = &amp;b;decltype((c)) d = c;cout &lt;&lt; *d &lt;&lt; endl;d = &amp;_b;cout &lt;&lt; *c &lt;&lt; endl;</code></pre><p>输出是 1 2。若要直接写指针引用，则</p><pre><code class="cpp">int *(&amp;d) = c;</code></pre><p>这种时候为了理解，还是打括号。<code>(int*) (&amp;d) = c;</code></p><p>再叠加一层，声明顶层 const 附带的指针引用呢，算了算了（（（</p><p>头文件中不应该包含 <code>using</code>，以免引发冲突。</p><p>返回数组指针的函数，<code>int *func(int i)[10];</code>，或者写作 <code>auto func(int i) -&gt; int(*)[10];</code></p><p>预处理功能中，<code>assert(expr)</code> 能够对表达式求值，若表达式非零则继续，否则停止。预处理器无需使用 <code>std::assert(expr)</code>。</p><p>使用 <code>NDEBUG</code></p><pre><code class="cpp">#ifndef NDEBUG        std::cerr &lt;&lt; __func__ &lt;&lt; std::endl;#endif</code></pre><p>若要脱离调试阶段，只需 <code>#define NDEBUG</code> 即可，即 not debug.</p><p>类似的预处理器定义的名字有</p><ul><li><code>__FILE__</code> 文件名</li><li><code>__LINE__</code> 存储当前行号</li><li><code>__TIME__</code> 存放文件编译时间</li><li><code>__DATE__</code> 存放编译日期</li></ul><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><p>函数指针，<code>int (*pt)(const int &amp;, const int &amp;);</code>，而将函数名作为一个值使用的时候，该函数名就被当成指针。比如，<code>pt = apb</code>，写成 <code>pt = &amp;apb</code> 也行。</p><p>const 成员函数，即常量成员函数。具体的写法为，<code>valtype func(int, int) const { ... }</code>，主要用于限制 <code>this</code> 指针的行为。类内部可以忽略 <code>this</code>，但是为了内容清晰，之后的写法还是加上 <code>this-&gt;...</code> 比较好。<code>decltype(this)</code> 的结果是 <code>ClassType *const</code>，即顶层 const，而顶层 const 是允许修改其指向对象的值的。添加 const 以后，<code>this</code> 的类型变为了 <code>const ClassType *const</code>，即同时满足顶层 const 与底层 const。本身不能被修改，也不能修改其成员函数。</p><p>友元函数，声明位于类最前或最后，意在为非成员函数提供访问 private 的途径。不光如此，还可以为某一个类的成员提供访问权限。但是啊，声明顺序的问题就出现了。假设我们由 A 给 B 提供友元，即 B 要操作 A 的 private 成员。顺序必须为</p><ol><li>声明 A，但是不定义 A 的成员函数（因为这时候还没有进行友元声明）</li><li>在 B 的内容中给 A 添加友元</li><li>定义 A 中的成员函数</li></ol><p>而友元函数真正出现在类的定义域时，是友元函数被<strong>定义</strong>的时候。所以才建议将类的成员函数分开写。</p><p>默认构造函数在 C++ 11 中的写法为 <code>ClassName() = default;</code></p><p>通过添加 <code>mutable</code>，可以设置可变数据成员，即该对象可以被 const 对象修改。</p><p>一个类中，若存在常量成员变量或引用的成员变量时，需要在类的内部添加构造函数并且通过构造函数初始值列表为这些成员提供初始值。</p><p>需要注意，构造函数的初始值最好按照声明变量的顺序进行。否则可能会出现未定义的情况。</p><p>委托构造函数：在多种构造函数的情况下，委托构造函数能够复用之前构造函数的内容以进行构造。</p><p>构造函数偶尔会出现隐式转换，若要抑制隐式转换，使用 <code>explicit</code> 。</p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;memory&gt;using std::make_shared;using std::shared_ptr;using std::string;class Tmp {public:    Tmp() = default; $qwq$    Tmp(const char *&amp;st) : s(st) { }    void print() const {        std::cout &lt;&lt; this-&gt;s &lt;&lt; std::endl;    }private:    string s;};int main() {    Tmp a = &quot;qwq&quot;;    a.print();}</code></pre><p>若将 line 11 加上 <code>explict</code>，该编译不通过。因为 line 21 出现了隐式类型转换。</p><p>类的静态成员，即与类本身直接相关的成员。静态成员可以是 private 或者 public 的，只需要加上前缀 <code>static</code> 即可。既可以用作用域运算符来访问，也可以从类的对象引用或者指针来访问。</p><h2 id="Generic"><a href="#Generic" class="headerlink" title="Generic"></a>Generic</h2><p>泛型算法依赖于迭代器，而迭代器通常不会修改容器本身，于是我们可以知道，泛型算法不会进行容器的操作。</p><p>比如这份代码</p><pre><code class="cpp">void eraseDuplicated(std::vector&lt;std::string&gt; &amp;words) {    std::sort(words.begin(), words.end());    auto end_unique = std::unique(words.begin(), words.end());    words.erase(end_unique, words.end());}</code></pre><p>有些时候，会遇到需要重载 <code>sort</code> 行为的情况，标准库接受一元谓词和二元谓词。<code>stable_sort</code> 表示，若无法判断大小，则保留原有的顺序。</p><p>lambda 表达式可以通过<br>$$<br>[\text{capture list}](\text{parameter list}) \rightarrow \text{return type} { \ \text{function body} \ }<br>$$<br>定义。可以忽略 parameter list 和 return type，但是必须保留 capture list 和 function body</p><pre><code class="cpp">int x = 3;// Capture the parametersauto f2 = [x](const int &amp;i) { return (i &gt; x); };for (int i = 1; i &lt;= 5; ++i)    cout &lt;&lt; f2(i) &lt;&lt; &quot; &quot;;cout &lt;&lt; endl;</code></pre><p>这么说，lambda 表达式是不是可以实现作用域的穿透。（从上向下的穿透）</p><p>而捕获分为几种，值捕获，引用捕获，等。</p><p>来个骚操作，假如，我是说假如哦，如果我想让 sort 函数输出排序的具体过程。</p><pre><code class="cpp">std::ostream&amp; os = cout;std::vector&lt;int&gt; lst{ 5, 4, 3, 2, 1 };std::sort(lst.begin(), lst.end(), [&amp;os](const int &amp;a, const int &amp;b) {        os &lt;&lt; &quot;Comparing:&quot; &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;        return a &lt;= b;});</code></pre><p>若要让编译器进行自动的捕获，parameter list 写成 <code>&amp;</code> 或 <code>=</code> 即可。前者是引用捕获，后者是值捕获。</p><p>若要让编译器进行返回值类型推断，必须使用尾置返回类型。</p><p>标准库的 <code>bind</code> 函数，可以 <code>auto f = bind([](const int &amp;a, const int &amp;b) { return a + b; }, 1, 2)</code>，则 <code>f()</code> 得到 3。类似于提供了参数默认值吧。感觉这操作有种人体改造的感觉。</p><p>之前实现的捕获，也可以用 <code>bind</code> 来复现，不过没多大意思了。顺带，<code>_1</code>，<code>_2</code> 可以被当作占位符使用。这玩意儿居然是 <code>std::placeholders::_n</code>，忽然觉得有点神奇。</p><p><code>ref</code> 函数可以返回一个引用，而 <code>cref</code> 函数可以返回一个常量引用。</p><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><blockquote><p>我每次在 C++ 中看到 Memory 都会觉得莫名浪漫</p></blockquote><pre><code class="cpp">#include &lt;memory&gt;</code></pre><p>智能指针 <code>shared_ptr&lt;T&gt; sp</code> 中，<code>sp.get()</code> 表示返回被管理的原指针，不要轻易使用。</p><p>如果混用 <code>shared_ptr</code> 和普通指针，会导致引用计数的实际值与期望值不符合。</p><p>理论上来说，<code>unique_ptr</code> 是不能被拷贝的。但是拷贝并不只有 <code>=</code> 的拷贝等等，从一个函数返回时，<code>unique_ptr</code> 是能够被拷贝的，因为原对象立马就会被销毁。</p><p>指向数组的 <code>unique_ptr</code> 不支持成员访问运算符（？）</p><p>而若要使用 <code>shared_ptr</code> 来管理数组，需要提供删除器，即 <code>[] (int *p) { delete [] p; }</code> 若不提供删除器，则会出现只 delete 某一个元素的问题。</p><h2 id="Class-again"><a href="#Class-again" class="headerlink" title="Class, again"></a>Class, again</h2><p>合成拷贝构造函数，编译器为我们定义的通过拷贝进行构造的函数，会拷贝除了 <code>static</code> 成员之外的所有成员到正在创建的对象中。</p><p>这种操作让我感到了一丝不合缝的优雅，虽然对成员的类型进行不同方式的定义或许有必要，为了拷贝构造单独规范每种类型的拷贝方式也颇伤大雅了吧？如果将拷贝构造提升到一种更高的逻辑层次或许可以解释这种不和谐。或许是我的理解有些问题，就当我碎碎念了。</p><p>拷贝初始化和直接初始化的差距已经体现了出来，直接初始化采用普通的函数匹配。而（先不忙）</p><p>若拷贝构造函数初始化为 <code>ClassName::ClassName(ClassName c);</code> 而非 <code>ClassName::ClassName(const ClassName &amp;c);</code> 会出现怎样的问题？</p><p>在拷贝时（调用拷贝构造函数），被拷贝对象被拷贝进 <code>c</code> 中，这个过程需要调用拷贝构造函数，而拷贝构造函数又会拷贝构造函数，如此往复。若使用常量引用，第一次的拷贝构造就会被停下来。</p><p>析构函数，指在类中的</p><pre><code class="cpp">~ClassName();</code></pre><p>表示如何移除类所占用的空间。</p><p>虚函数，<code>virtual</code>，用于在派生类的类中重新定义这个函数而存在。在派生的类里，需要加上 <code>override</code> 来表明这是一个派生的函数。</p><p>派生类的定义需要添加 <code>public</code>/<code>protected</code>/<code>private</code> 三个访问说明符之一。<code>class ClassName : public ClassName2 { ... }</code>，这个说明符表示基类中的成员是否对派生类用户可见。</p><h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><p>具体来说，模板函数写成这样</p><pre><code class="cpp">template&lt;typename T&gt;T max(const T &amp;a, const T &amp;b) {    return a &gt; b ? a : b;}...cout &lt;&lt; max(1, 2) &lt;&lt; endl;cout &lt;&lt; max(1.0, 2.0) &lt;&lt; endl;</code></pre><p>这样写就能应付不同的数据类型。</p><p>再看一个</p><pre><code class="cpp">template&lt;typename T, typename U&gt;T max(const T &amp;a, const U &amp;b) {    return a &gt; b ? a : b;}...cout &lt;&lt; max(1, 2.0) &lt;&lt; endl;</code></pre><p>其实 <code>typename</code> 和 <code>class</code> 是基本一样的，都能完成对类型的匹配。</p><p>但是，若这个类型没有同时定义 <code>&gt;</code> 和 <code>&lt;</code> 呢，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>05</title>
      <link href="2021/01/02/05-1/"/>
      <url>2021/01/02/05-1/</url>
      
        <content type="html"><![CDATA[<p><img src="https://p.sda1.dev/0/53075cfbdd441d3bf0eace50b22231ea/image.png" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>九月与十月杂记</title>
      <link href="2020/10/21/sep_oct/"/>
      <url>2020/10/21/sep_oct/</url>
      
        <content type="html"><![CDATA[<p>我也不知道我现在哪来的心情，在一篇论文两个网课一篇演讲还处于尚未动工的状态的情况下写这篇杂记，顺带明天还有 quiz，我还没复习。后天还有体测，我也没个底。可能是因为有很多东西想要表达，也可能是因为实在太久没有正经更新过博客，总之就是，我又开始写作了。</p><a id="more"></a><p>如何完成从高三到大学的转变？</p><p>一个暑假的摸鱼也没有改变我心目中摸鱼的形象——不能摸！无论如何，不能把学习的时间拿来摸鱼！但是结果是很可怜的，我依然抱着罪恶感摸鱼。</p><p>我也曾做过一些“逆反”的尝试，比如安排一整个下午来锻炼，比如花一整天的时间打 gal，我以为多多练习就会没有罪恶感了，然而事实证明不是，罪恶感只会满地堆积，摸鱼还会导致我差点没赶上 ddl。</p><p>很可笑是吧？一个学生为什么会去学习摸鱼。可是高三已经确切地在我心里刻下了深深的烙印，我认为这样是不正确的。我认为我不应该认为一切时间都应该为我的未来服务。我认为… 我应该留出时间来干自己喜欢的事情。我认为… </p><p>好吧，我在学习 CTF 的时候会想，我的线代是不是还不够扎实？我的数分是不是还有一些题目没有复习？然而这样的追求是永无止境的，我总会有题目没有复习，我也总会有知识还没有覆盖到，超过既定时间的复习大多都是无用功，然而我却在追求踏实感的路上越走越远，花费了大量的，原本应该去做自己喜欢的事的时间，或原本应该拿来放松摸鱼的时间。</p><p>然而高三就是这样，你除了学习和一些为了更好地学习的东西之外不应该花功夫，对于高考科目能力的追求是无止境的，因为竞争。高考是相对的竞争，你不变强你的竞争对手就会变强，于是你得变强，于是你就得花费大量时间去追求一个更高的高度，每一次考试都会告诉你你的高度，于是你就去追求一个更高的高度。</p><p>我错在把这种追求映射到了大学的科目上。摸鱼或许只是一个我的希望的代名词，我希望自己是一个会玩的人，我不能成为被文化课束缚的人。</p><p>这个问题尚未解决。</p><p>进了大学之后，曾经的朋友一个一个进入了算法竞赛圈。我得到这些信息之后的第一心情是，为什么我不会这样，为什么我没有想要这样，为什么我没有初升高时那样的，似乎比谁都要强烈的热情了？</p><p>我便陷入了怀念中，怀念自己曾拥有的，却早已失去的各种东西。</p><p>我的青春似乎是有限的柴火，在我走来的路上，我曾获得过度温暖的幸福，在我再次感到寒冷的时候，却一根也找不到了。</p><p>你这不是，常有的中年大叔对青春的怀念么？我觉得不是，我确实是处在一个满溢着青春氛围的地方。看到一楼的活动室里男女共处娱乐的场景，我似乎也有想过要加入他们，我似乎也很想再次在我最熟悉的算法竞赛的领域挥霍我的空余时间，似乎也有过想要找好看的女孩子要 QQ 的想法，也想要稍微打理打理变干净点。这都是我曾熟练的事情。</p><p>我甚至会怀念一年前每天抱着高深书籍研究的自己。我曾想要用广博的知识武装自己，读了好多书，学了好多东西，感觉自己快要变得真的好厉害。那时候我一次一次被人类的智慧所惊艳，然后一次一次立誓自己以后也要干出一番事业。所以我才下定决心来这里，只是为了搞研究，做出一番“有意义”的东西。我曾为我这种思维感到骄傲。</p><p>但是现在我做不到了。</p><p>如果我不能做到棱角分明，就会留下空洞，所以我才不希望被磨平。</p><p>所以我才尝试去学生会做设计，想要留下一些突出的东西。但是似乎不行，第一次合作的体验真的很差，那时我也在考虑将大量精力投入 CTF，所以我在面试上说，“抱歉，我是来弃权的。” </p><p>可笑的是，我似乎并没有把大量精力投入 CTF，我对 CTF 的兴趣是断断续续的，或许今天有心情，我喜欢上 CTF 了，我就学一晚上，被比赛打击到了，于是我就很长一段时间不学。我深知这样是搞不出结果的。</p><p>于是我才回归到自己的茧中。</p><p>我懒得尝试新东西，于是尝试在文化课中寻求慰藉。但是我不喜欢这样的自己，所以我选择学习“摸鱼”。我喜欢那样那样的自己，于是我尝试通过行动在现在的自己中寻找过去的影子。</p><p>这时候肯定会有人劝我，你要走出自己的茧啊，你要去尝试挑战新事物！</p><p>我想，但是我懒啊。</p><p>九月十月并不是很顺利的两个月，我做不到在这篇杂记的结尾来一个苏东坡式上扬。</p><p>就这样吧。</p>]]></content>
      
      
      <categories>
          
          <category> Daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并不可爱的高三</title>
      <link href="2020/07/24/start/"/>
      <url>2020/07/24/start/</url>
      
        <content type="html"><![CDATA[<p>这或许是人生路上又一段<a href="http://music.163.com/song?id=447280637" target="_blank" rel="noopener">稚嫩的歌曲</a>，尽管我依然没能处理好许多事情，我还是决定将其记录下来，无论可爱与否，留给各位当一个参考，也给未来的自己送上一段回忆。而之所以决定在这个最难受的时期写这篇博文，大概也有自我安慰的因素。无论说了多少丧气话，发了多少呆，心里有多难受，无论怎么埋怨命运，我还是得咬着牙填写自己的未来，然后走在这完全被颠覆的人生的路上。</p><a id="more"></a><h2 id="Chapter-Ⅰ"><a href="#Chapter-Ⅰ" class="headerlink" title="Chapter Ⅰ"></a>Chapter Ⅰ</h2><p>我并不坚强，在高三开始时我就知道了。</p><p>进入高三后，我对自己的成绩的意识也越来越明确。直到那时我才认识到，原来拥有目标只是达成梦想中最微不足道的一环，而清晰的自我认知也极其重要。零诊的成绩相较我高三后期并不优异。对比后我大概发现，我离北航还很远。</p><p>我设定北航这个目标似乎并没有多少理由，梦想不需要理由。在那时，我是确确实实准备以北航为目标努力的。</p><p>我还记得高三刚开始时，我把「北航之路」几个字写在笔记本全新的一页上，踌躇满志地出发。那天晚上晚自习下课后，我一个人戴上耳机，走到校园后的菜地去。在夜晚，向日葵只拥有月光，一个个都低垂着头，无精打采地，却在为着第二天的阳光做好抬头的准备。当时我看着向日葵，咬咬牙，那时我知道，如果要达成去北航的可能性，一定得超过班上所有人，而我也知道，站在我前面的二十几位同学是有多可怕。但是天真的我却握着拳头说，我要超过你们所有人，踩在脚下，然后最终达成我的北航之梦。</p><p>那是最初的天真的梦，理综的出现将我打得措手不及。故事即将开始。</p><p>刚合卷的时候我很不习惯，选择题每次都会错三个及以上。第一次理综成绩似乎还能看，但是第二次，第三次，我有越来越多的题目做不完，也有越来越多的选择题失误。我的理综分数从年级的 50 名左右，总分一路后退，一直退到 100，甚至更后。那可能是我高三最痛苦的一段时间，连续五次的退步，似乎把我从竞赛回来后获得的一切赔得血本无归。 每一次退步后，我都会想，「万一高考是这样，我不就完蛋了」。我还记得那时我说，我能有什么努力的理由？无论怎么熬夜学习，得到的结果总是退步退步再退步。仅仅两个月的时间，足以让我把北航的梦忘得一干二净，那段时间，我没法把北航写在自己的笔记本上，后来的一次月考更是把我的心态打到谷底，我思考过放弃，嘴上也说了无数遍放弃算了，这种无用的竞争不存在好了。那时我也真正意识到了北航的距离与自己有多远，不知何时，我停止仰望星空了，我最终决定把北邮当作目标，这个目标相较来说更容易达到。目标的更换到底是好事还是坏事我说不清楚，这个问题或许需要更长久的时间来回答。</p><p>无论如何，最后行动上，我没有忘记我还有一个属于远方的梦想，一切的反转也即将开始。</p><p>从结果上来说，反转是彻底成功的。理综从近乎最弱的一科到了最强的一科，并且从未翻车（除了高考）。可我对于这个反转说不出所以然，那时的颓废的我一定不会用尽全力去学习理综，理综的提升也本不该是一两次考试的事。无论如何，我的理综在我从南科大夏令营回归文化课后完全反转，从完全做不完题，到了 12 月的近乎完美的答卷以及大笔大笔的检查时间。我也有思考过，我的理综为何能反转的问题（嘛，我高考理综是彻底的失败，不过那也是后话了）。现在想想，可能和一诊前大量的刷题不无关系，也和我固有的性质（慢热）有极大关联。</p><p>不到一个月的时间，我从一个失败者变成了同学眼里的成功者，从眼看着把原有的阵地都要丢下，却忽然达到了我定下的北邮的目标，似乎就要成功了呢？离北航的距离也不过十分，只要把语文水平提升起来就好了，高三后期我也只需要保持现状就好了呢。那时的我是这么想的。</p><p>Chapter Ⅰ的经历是最精彩的，也是最令人摸不着头脑的。这剧情是不是差了块拼图，为何忽然就反转了呢？我也不知道。这或许就是人生和小说的最大差距，不是什么剧情都需要足够的铺垫与组织。和最后的失败一样，真的不需要任何理由。</p><p>结尾处我也要为自己辩解一下，那时的我或许也不是真的颓废，每天把时间表排的满满的，写了不少的笔记，按照同桌的说法，我努力到他都想努力了，认为自己真的不努力的，可能也只有我自己。</p><h2 id="Chapter-Ⅱ"><a href="#Chapter-Ⅱ" class="headerlink" title="Chapter Ⅱ"></a>Chapter Ⅱ</h2><p>看似顺利的 end 1 后是一段更加顺风顺水的日子，我的语文忽然考了班上第一名，理综也考了班上第一。在我的心情最膨胀时，放寒假了，我带着那膨胀的心情开始了寒假本该一个月的学习。</p><p>然后，疫情来了，彻底打乱了我的阵脚。</p><p>本来设定好的每天去图书馆自习，却因为疫情肆虐根本无法前往。我在家里的自习效率极其低，从高一开始就是这样。就这样挥霍了半个月，我急，但急不能当饭吃。心急的心情下，我的摸鱼次数变得越来越多。很可笑的是，我的摸鱼并不是专攻一项的摸鱼，甚至也不是沉下心来打一个游戏，而是无所事事的翻翻书，看看论坛，翻翻 im 的聊天消息。这种摸鱼形态带来的最终结果就是，无聊。无聊的心情是难以享受的，娱乐行为的存在就是为了填补无聊带来的无力感，而加以高考的 dead line 的压迫，之后的一个月我一直处于抑郁+无聊的状态。</p><p>反馈也是调节心态的重要方式之一，而那段时间的反馈着实让人胃疼。网课下的考试水，这是全员皆知的，可我认定他们都没作弊，当看到理综的平均分渐渐迫近 270，成绩差的同学都慢慢超过我，我越发烦躁，而每当想到不到 100 天的倒计时，我都会产生呕吐感。有几个晚自习，我都完全无法沉下心来写作业，只能眼睁睁看着会议软件上同学们都埋头苦读，我却在电脑前颓废。那段时间里，我一直质疑——是否应该固执地设定一个目标学校，梦想对我来说，更多是像压力而非动力。</p><p>还好，之后就是开学。开学前，教育部忽然通知说高考延迟一个月，这给我吃了一颗定心丸，「一个月时间足够追赶了，对吧。」那时我这么想。</p><p>事实告诉我，追赶不需要一个月，只需要五天就够了。</p><p>开学考试算是一场彻底的失败，尽管我做好了心理准备，但在拿到那很难看的成绩后依然非常难受。很有趣的是，这次考试的成绩比高三上最差的成绩还要差，但是也比高考好。嘛，这都是后话了。那次失败离下一次考试只有五天，不管是能力还是状态，我都只有五天时间来调整，我屏蔽了所有的，有关后果的思考。我做好了二诊彻底失败的准备，我也有充分的失败的借口。五天过去，二诊考完，出成绩时我发现，我的二诊又成功了，甚至比一诊达到的高度还要高。我享受着这个高度带来的正反馈调节。</p><p>二诊后的三诊，我真正意义上的做到了。当一个朋友跑来对我说：你他妈居然那么高？我意识到我真的把所有人都踩在了脚下，我真的走到了那个以往的自己根本不可想象的高度。第一名，这个梦一般的词汇在高考前最后一个月来到了我身旁，后来的几次模拟，我又拿了一次第一名，证明了那时的自己的实力，并且稳居 30 名以前。高考前我也自信满满，「我的理综，不可能翻车！什么叫做 flag 我不懂。」直到现在我都认为，那并不是毫无来头的傲慢，而是我本应该拥有的最健康的自信。</p><p>Chaper Ⅱ 也以一个足够令人满意的阶段作结，可接下来的故事将抹去我所有的傲慢。</p><h2 id="BAD-END"><a href="#BAD-END" class="headerlink" title="BAD END?"></a>BAD END?</h2><p>这个 BAD END 来的毫无根据，就如同我整个高三的提升一样。直到高考出成绩之前，或者说看到成绩之后，在拿到排名表之前，我都以为自己并没有太大的失误。我本希望自己能最平静地迎来结局，然后快快乐乐地坐上火车走向人生的下一站。</p><p>晚自习的课间，我时常走到教学楼的一角去。离学校不远处是火车东站，时常有列车从那里出发，驶向远方。我曾无数次幻想自己乘坐一辆列车去北京上大学。渐渐的，列车划破空气的声音，就和我的梦想绑定起来了，每当有列车呼啸而过时，那噪音成为了我的慰问品，虽然吵闹，我却不愿意带上耳塞。它总能提醒我不要忘记，我还有一个属于远方的梦，于是我又拿起笔，一边扯着头发，一边望着面前勾勾画画。</p><p>而，我曾拥有的过的梦都化为了吹向远方的风，我无力拥有无力抓住。看到史无前例最低的排名时我愣住了，然后笑了，然后，高三的记忆似乎被染成了黑色，为什么似乎人人都能实现自己的梦想，为什么只有我面临的是不断的失败？我根本无力反省，如果说能反省出来个什么，那我只能说是命运。这就是属于这个人的 BAD END，意料之外，也在我认为的情理之外。</p><h2 id="最终的转折与这段故事的-ending"><a href="#最终的转折与这段故事的-ending" class="headerlink" title="最终的转折与这段故事的 ending"></a>最终的转折与这段故事的 ending</h2><p>如同许多精彩的剧本一样，在一段故事在结尾前给予主角最深的绝望，然后之前的，许许多多的并未被注意到的伏笔一下汇聚成全新的路，带领主角走向前方。</p><p>越想越巧，甚至觉得这不可能是一个巧合。</p><p>或者说，我是幸运的。</p><p>第一个伏笔是18 年年末的竞赛。这或许也是铺垫中最具重量的一者。那时，谁也不会想到，小小竞赛会在最后的升学上发挥这么大的作用。我并未抱有任何功利心去参加信息学竞赛，而 19 年教育部大笔一挥，取消自主招生时，无论是抱有功利心，想通过竞赛去清北的OIer，还是我这种对于其升学效益无所谓的OIer，竞赛奖状都只是一张无关痛痒的奖状了。（严格来说，对于绝大部分此类人）</p><p>在「看似」堵死了竞赛的希望之后，第二个伏笔出现了。那是 19 年我连续参加的国科大，上科大，南科大夏令营。最初我只是对新型大学有点兴趣，而且想出门溜达溜达，就顺势参加了这三个夏令营。</p><p>第三个伏笔是我的零诊一诊二诊成绩。（在提交上科大申请的时候并没有考三诊）。虽然这三次诊断性考试的结果都挺好看，当时我想的却是「诊断性考试除了给点信心，到底有什么用？反正这个分数又不会计入高考」。</p><p>班主任时常说，高考考察的并不仅仅是你的文化课水平，而是——这三年里，你到底学到了多少成长了多少。</p><p>高考结束之后，我眼睁睁看着自己的原本广阔的路被压缩。从一开始的，由分数铺陈的路被一瞬间颠覆，我原本梦想的南大，北邮，完全遥不可及。去南科大的希望也因为机试发挥一般而最终被抹去。我抹着眼泪，坐在地上哭泣。母亲在高考刚结束的时候，一次散步中给我说。「在今年的高考形式下，<strong>你要做好充分的准备</strong>，这或许是你整个高三最差的一次，但是你依然得做出选择。」我在和朋友闲聊时提到这句话，「我妈这不是在给我浇冷水么？」</p><p>但是，真当自己被迫走入这个死胡同时，我偶然抬头发现，似乎还有一个通往更高处的梯子——上科大给予我的具有极大分量的加分。</p><p>这个所谓「极大分量」，照应了我做出的所有准备。第一轮简历筛选，我认识的人绝大多数都没通过，第二轮，面试筛选。这我不清楚，但是我只记得几个送分题我回答的比较好，比如「选南科大还是上科大啊？」「选西交还是上科大啊？」。当然，回答是 YES，但是光一个 YES 的回答显然是不够的，给出判断后还需要给出 Why。母亲所提醒我的，充分的准备，这时候就起效了。结果出来后，我甚至不敢相信自己拿到了 B档加分（20000 人中选 2000，2000 人中选 500）——上科大太给我面子了吧？</p><p>面子不是白给的。如果没有竞赛的经历，我或许根本没法通过初审。如果没有参加多个新型高校夏令营，我或许根本没法拿到 15 的加分，因为参加夏令营代表了我对这所学校存在极大的兴趣（事实如此）。如果没有诊断性考试的优秀成绩，或许上科大会认为我是一个不太会学习的学生。因为，15分，它给的真的太多了，以至于能够照亮死胡同里的我，让我走向前方。</p><p>我从来就不是一个纯粹的功利主义者，我并不想卷入广大学生的 GPA 战争中，或许上科大真的看到了我对 OI 的初衷，也看到了我为了什么而努力。「卷」似乎真的是一个难以突破的东西，所以胜者会得到「突围者」的称号。// 这是我之后添加的，或许与上文没什么关系吧。</p><h2 id="After-Story"><a href="#After-Story" class="headerlink" title="After Story"></a>After Story</h2><p>现在看来，高三的所有成功不过是梦一场，没有小说般的因果，却也骤然结束，迎来了一个似乎圆满的结局。不过啊，你看，如果将高三上的状态作为故事的开头，所有的故事，都是以困境开始，以顺境结束。这么说，这个在 events 中处于奇数位置的高考，会不会只是一个开头而非结尾？我也许可以任性到认为高考就是高中生活的 BE，但是灿烂的花火本身就是以漆黑与滚烫作为起点，以璀璨绽放作为终点，而非以一些原料为起点，被装在漆黑的包装里为终点。或许吧，现在的我，只是不知所措地站在一个前所未有的宏大的故事的起点上，这个故事不会以考试来评判我是否胜利，也不会短短半年就划上句号。我似乎一直沉迷于对失败的开头进行计数——中考啊，竞赛啊，高考啊，却忽略掉了曾经的每一个故事都有一个令人开心的 HE 呢。在这个并不可爱的高三后，我或许会迎来一个更加精彩而挑战的未来吧。</p>]]></content>
      
      
      <categories>
          
          <category> Daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瞎写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OI 与其高考数学应用</title>
      <link href="2020/04/25/OIwithMath/"/>
      <url>2020/04/25/OIwithMath/</url>
      
        <content type="html"><![CDATA[<p>假的标题…</p><a id="more"></a><h2 id="Pro-01"><a href="#Pro-01" class="headerlink" title="Pro 01"></a>Pro 01</h2><p>几位大学生响应国家的创业号召，开发了一款应用软件。为激发大家学习数学的兴趣，他们推出了“解题获取软件激活码”的活动。这款软件的激活码为下面数学问题的答案：已知数列$1, 1, 2, 1, 2, 4, 1, 2, 4, 8, 1, 2, 4, 8, 16, \cdots$，其中第一项是$2^0$，接下来两项是$2^0, 2^1$，再接下来三项是$2^0, 2^1, 2^2$，依此类推。求满足如下条件的最小整数$N:N &gt; 100$且该数列的前$N$项和为$2$的整数幂。那么该款软件的激活码为（   ）</p><table><thead><tr><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>440</td><td>330</td><td>220</td><td>110</td></tr></tbody></table><p>高考中的新题的解法，往往都可以联系到 OI 上去。我们称此题最终构造的数列为$A$，处理$A$这个整体会不方便，想到每一个子数列为$B$，则$A$为$n$个$B$首尾相接，且最后还会有一段剩余序列$C$，于是有</p><p>$$<br>A:\underbrace{[2^0]}_{B_1}, \underbrace{[2^0, 2^1]}_{B_2}, \underbrace{[2^0, 2^1, 2^2]}_{B_3}, \cdots, \underbrace{[2^0, 2^1, 2^2, \cdots,2^{n - 1}]}_{B_n}, C<br>$$</p><p>注意到，若对此数列求和，$S = \sum_{i = 1}^{n}{\sum{B_i}} + \sum{C}$，若求$\sum{B_i}$，对于高中数学，可以用差比数列求和方式。对于OIer，可以发现$B_i$与二进制的关系，即$\sum{B_i} = 2^i - 1$，则$\sum_{i = 1}^{n}{\sum{B_i}} = 2^{n + 1} - (n + 2)$。此时能够想到，若$S = 2^k, k \in \mathbb{N^+}$，则</p><p>$$<br>\sum{C} - (n + 2) = 2^k - 2^{n + 1} \Rightarrow \sum{C} = 2^{n + 1}(2^{k - (n + 1)} - 1) + (n + 2)<br>$$</p><p>很显然，若$k &gt; n + 1$，有$\sum{C} &gt; B_n$，与$C$的定义冲突，故$k = n + 1$，$\sum{C} = n + 2$，假设$C = B_t$，满足$\sum{C} = 2^t - 1$</p><p>对于考场做题，对于整体的数列$B$总共占位$(n^2 + n)/2$，分别带入选项，可得$29 \times 29 + 29 = 870$，剩余为$5$，则$5 + 3 = 2^3$，满足条件，其余检验略（我记得有优化）。欸，有点记不到当初做题时候怎么排除选项的了，先这样吧（结尾水）。</p><h2 id="Pro-02"><a href="#Pro-02" class="headerlink" title="Pro 02"></a>Pro 02</h2><p>定义”规范01数列“${a_n}$如下：${a_n}$共有$2m$项，其中$m$项为$0$，$m$项为$1$，且对于任意$k \le 2m, a_1, a_2, \cdots,a_k$中$0$的个数不少于$1$的个数，若$m = 4$，则不同的”规范01数列“共有多少个？</p><p>第一次见这题是在 mgt 博客上，第二次见是小题狂练，mgt 博客给出的方法是 dp，小题狂练给出的方法是<strong>枚举</strong>。经同桌尝试，纯粹的枚举在考场上基本不可行。是否有一种，容易想到，且容易计算的方法，能够优雅地解决这个选择压轴题？</p><p>首先，对于$a_n$的前缀和数列$S_n$，满足$S_k \ge 0$，且$S_{2n} = 0$（将数列中的$0$看成$-1$）。对于 OIer 们容易想到$f[i][j]$，最后取$f[n][0]$，但是抽象的$f[i][j]$不适合打草稿——这是初始的想法。当然，对于没有 OI 的文化课选手，其实也能想到该方法（比如我，我个人是先想到该方法再想到 dp 的），详见 16 年 Ⅱ 卷的选择题第五题。本题是 16 年 Ⅲ 卷的选择题，这解法上微妙的巧合，不得不让人兴奋。</p><p>首先的首先，需要画一个坐标系。如图：<br><img src="https://i.loli.net/2020/04/19/8TAHloIVuz9qcDt.png" alt="Clipboard - 2020-04-19 16.10.56"></p><p>然后就做完了。</p><p>看到$(8, 0)$的点，其对应的值是$14$，此题答案$14$。每一个点$(i, j)$对应的横坐标的意义是，这个数列长度为$i$，而$j$的意义是，此时前缀和为$j$。则$(8, 0)$表示，长度为$8$的数列，其中$0, 1$个数（计算过程中的$0, -1$）相等。每一个点，其值都等于其左上的点与左下点值的和，因为数列长度增长一，要不然前缀和加$1$，要不然$-1$。</p><p>当然，还有一个办法，卡特兰数列，画图的方式也和卡特兰数列的计算方式类似。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Winter Vacation</title>
      <link href="2020/02/04/winter-vacation/"/>
      <url>2020/02/04/winter-vacation/</url>
      
        <content type="html"><![CDATA[<p>寒假编译的$\LaTeX$文档，就当一个练习吧</p><a id="more"></a><div class="row">    <embed src="https://files.catbox.moe/2xqjqn.pdf" width="100%" height="550" type="application/pdf"></div><div class="row">    <embed src="https://files.catbox.moe/99969w.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
      
      
      
        <tags>
            
            <tag> Learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>004</title>
      <link href="2019/12/31/004/"/>
      <url>2019/12/31/004/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/12/31/bjRehZmaXKJs3tD.png" alt></p><a id="more"></a><h1 id="2019-12-31-杂记"><a href="#2019-12-31-杂记" class="headerlink" title="2019/12/31 杂记"></a>2019/12/31 杂记</h1><p>好了，新年贺图做完了，本来想动态起来的，结果没水平，只好水了张静态的。</p><p>提起我 2020 年的主题，自然是高考。2020 将被分为两个部分，第一个 20，是「我的高考」，第二个 20，是「我的大学」。如果将竞赛看作我的第一次青春，这就是第二次青春的起点与终点与再出发。这一年会经历很多事——虽然每一年都是这样的，那就请让我期待吧，期待自己的改变，并期待世界的改变。</p>]]></content>
      
      
      <categories>
          
          <category> Design </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>003</title>
      <link href="2019/11/24/003/"/>
      <url>2019/11/24/003/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/11/28/NxQTHaFy9rStinL.jpg" alt="称为你的奇迹_画板 1.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Design </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>送给自以为是的大人</title>
      <link href="2019/11/08/tenkinoko/"/>
      <url>2019/11/08/tenkinoko/</url>
      
        <content type="html"><![CDATA[<p>——世界为什么会回归原有的样子</p><a id="more"></a><p>这可能是我第一次在看完电影之后立马写简评。显然，这样会引出不少 emotional 的结论，不过，天气之子的内核在兴奋过去后可能就会淡化了吧。</p><p>本质上是杂谈，所以就别纠结篇章结构了。</p><p>果然，ioa 能对上电波的作品我大多都能对上。（笑）</p><p>天气之子是做给特定时间段的特定的人们看的。包括我。我可能在曾经的博客中提到过，我受 flcl 影响不小。可惜我的那段故事的结局并不是 HE，我一直很后悔那时候做出了所谓「现实」的「抉择」。</p><p>LR 说，天气之子显然是商业片。我倒要反弹琵琶，这是诚哥向小众审美小众视角迈出的一步。虽然这步不一定成功，或者说并不一定优秀，但是至少观众们都能感受到。</p><p>看完电影后的第一感觉就是，「真的好叛逆啊。」叛逆到甚至有点扯淡，离家出走——到结局都没有仔细交代离家出走的原因，枪，哇，居然还开枪，躲逃警察的追捕，哇，还带打人的么，这结局是什么啊，居然还带淹了世界的（这篇简评我可能不会涉及这部份剧情表达的中心）。</p><p>显然的，「叛逆」本身就会打乱大部分观众的电波。我在看到一半时也吐槽，扯淡，扯淡。坐在旁边的陌生的大概是高中生的女孩看完也在嚷嚷，怎么这么扯的啊。旁边的自以为是的大人也这么说——她是那个陌生女孩的母亲，估计吧。诚哥考虑到了这点，如果他真想做出不折不扣的商业片，他会像你的名字那样，避免过于激进的剧情。</p><p>可是，还是要恰饭的。诚哥恰饭的本钱就是画面。这么说似乎也不准确。诚哥是以画面为食活下去的。从对生活的细致观察，诚哥的画面中处处表现着世界的温柔。从锲而不舍地画雨滴落下，再在水中溅起，每一帧都是匠人的追求。</p><p>回到之前所谓「激进」的话题。诚哥这部作品里有 flcl 的影子。比如「骑摩托的大姐姐」，flcl 本身就是日系作品中青春的代名词，当骑摩托的大姐姐出现时，诚哥想要表现的核心（之一）已经明确了。青春的内核在本作中的体现是什么？叛逆，泪水，恋爱，欢笑。那些自以为是的大人们，与在称为大人的途中自以为是的年轻人们啊，那些叫嚷着「不要自负」的大人啊。</p><p>新海诚还是那个长不大的孩子，在讲述着一些长不大的孩子的故事。</p><p>///后面是乱写了</p><p>激进的必然性，与青春</p><p>骑摩托的帅气大姐姐</p><p>没有丢掉的手铐</p><p>被大水淹没的东京</p><p>他作品中的人总是凭一己之力改变着世界</p><p>那个混混哥也有妻子和孩子</p><p>圭介大叔为了躲避警察抛下了帆高</p><p>而又为了帆高打倒了警察</p><p>大人们或许还是孩子</p><p>世界为什么会回归原有的样子</p><p>睡了。</p><p>这篇肯定会改，但不是今天。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>001</title>
      <link href="2019/10/20/001/"/>
      <url>2019/10/20/001/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/10/20/nL7Bm3KkqavSXej.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Design </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>今日的改动</title>
      <link href="2019/10/12/add-comment-system/"/>
      <url>2019/10/12/add-comment-system/</url>
      
        <content type="html"><![CDATA[<p>添加了评论系统。</p><a id="more"></a><p>貌似还有一些 bug，不过我先懒得管了。已经将近一年没摸过 CSS 和 HTML 了，还能改改前端也是不容易。先说起因吧。起因就是考试考的太差，跑去吃包子，吃完包子路上看到优衣库，想着自己缺🕊衬衫，逛了半天结果买了条浅蓝色的衬衫，不过因为我腿短看起来一般般。回家后完全无心学习。于是就开始搞博客。</p><p>Valine 的设计风格还是很舒适的，添加起来也比较简单。搞好 LeanCloud，然后加一发 appId 和 appKey 就好。然后就出问题了，头像部分没有对齐。看了看 F12，这个 theme 自带的 CSS 规定了 img 的对齐，于是 Valine 的头像对齐就歪了。说来老早之前我添加 gitment 的时候也出现了这个问题。然后加句 <code>:not(img.vimg)</code>，就解决了。</p><p>q姐提到说 Valine 国内版本需要备案，于是最好用国外版，需要注意。</p><p>之后又听说 Valine 出了阅读量统计功能，窝又加上了。一开始 <code>id</code> 项我用的 <code>post.title</code>，结果可能是编码的缘故（？），一直 404。改成 <code>url_for(post.path)</code> 之后就好了哎。趁机也熟悉了一下 hexo 的渲染机制。</p><pre><code class="html">&lt;span id=&quot;&lt;%- url_for(post.path) %&gt;&quot; class=&quot;leancloud_visitors&quot; data-flag-title=&quot;文章阅读量统计&quot;&gt;  &lt;em class=&quot;post-meta-item-text&quot;&gt; 阅读量 &lt;/em&gt;  &lt;i class=&quot;leancloud-visitors-count&quot;&gt;0&lt;/i&gt;&lt;/span&gt;</code></pre><p>后来想着添加字数统计功能，查了一圈，只查到 hexo-wordcount，我也懒，就干脆用现成的。结果一 <code>npm</code>，整个 <code>node_modules</code> 莫名其妙挂了，各种报错，然后又只能重新 <code>npm install</code>。想了想，添加在了 meta 部分，但是分隔符没做好？折腾 CSS 失败。也总算折腾结束了。</p><p>上周瞎构思了一下无后端博客系统。我记得冰河姐用 github api v3 做过一个？高考结束了我也开个坑吧。</p><p>代码块渲染貌似还有问题。暂时不解决了。</p><p>嘛，晚安。</p>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>有感而发</title>
      <link href="2019/10/03/Feeling20191003/"/>
      <url>2019/10/03/Feeling20191003/</url>
      
        <content type="html"><![CDATA[<p>有关《Dimension ~w~》</p><a id="more"></a><p>我一直是这么想的——</p><p>无论看多少作品，我总脱离不了一些所谓鄙视链低端的低级趣味，所谓被「人设」吸引。</p><p>现在想想，我喜欢的作品中，多少是因为我对某一名角色产生了感情，或男主帅气，或女主可爱，嗯… 这种偏爱会产生带入感，而这带入感终究会转化为那股怅然若失的感情，而怅然若失是阻碍我理性评价的最大因素之一。</p><p>我果然还是感性的，很少被剧情本身打动——剧情对我来说终究乏力，反而去注重作品中人与人之间的感情，不断地回味，不断地回味，最终产生了对作品的感情，然后，明明是「不到 8 分」的作品我偏要去打个 9 分。</p><p>——恩。</p><p>——然而这到底是人设的功劳还是剧情的功劳？当然，都有。不过这个回答不能让我满意。我不断地思考这个问题。</p><p>刚刚摸鱼看完 Dimension ~W~，又是那种怅然若失的感觉。「可能是因为发糖不够么」</p><p>其实一开始就是冲着女主去的，班上 lzy 在放，于是我就跟着他们看，「啊，女主真可爱，剧情也还行，好吧我去看吧。」然后就莫名奇妙被安利了。</p><p>多少作品是这样？莫名奇妙被安利。记得当初玩 ISLAND 只是在微博上看到了动画化的消息，于是就去玩了，最终收获了意想不到的惊喜。向日葵的教会与长长的暑假？也是看到别人玩，我就跟着去了。NOT LIVES？貌似只是看见 bgm 列表里有人在看，于是我就去看了，然后还蛮对电波。反而，许多直接被安利的作品，我反而对不上电波。不仅仅是作品的原因吧。为什么别人的安利基本没成功过？为什么我刻意去 bgm 列表寻找的作品总是不够让人满意？</p><p>所谓「可遇而不可求」，tty 如此总结。这个问题就留给我继续思考吧。</p><p>顺带一题，Dimension W 真好看。如果要理性评价，这部作品不够优秀，但是我看的很爽，那就够了。</p>]]></content>
      
      
      <categories>
          
          <category> Daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瞎写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>restart</title>
      <link href="2019/09/21/restart/"/>
      <url>2019/09/21/restart/</url>
      
        <content type="html"><![CDATA[<p>因为高三了，没时间折腾，我的 VPS 需要关闭一年，那期间 daily blog 寄存在 mgt 或 lr 的 server 上。而这个技术博客，我花了一个晚上的时间部署到了 netlify 上。算是 restart 吧？</p><p>顺带还折腾了 mathjax，「数论」那篇的公式渲染依然有问题。本以为是 mathjax v3 的锅，结果只是博文格式的一些问题。之后国庆再来解决吧。</p><p>我删除了基本所有的博文，之后大概率会加回来，不过现在就让博客干净一点，因为那些博文质量实在不高，基本都是 OI 期间水的。</p><p>下周上八天课。啊啊啊啊啊啊</p><p>闲扯就到这里。</p><p>TraceBack. 2019/09/22</p>]]></content>
      
      
      <categories>
          
          <category> Daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 瞎写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五彩斑斓的 OI</title>
      <link href="2019/07/15/colorful_oi/"/>
      <url>2019/07/15/colorful_oi/</url>
      
        <content type="html"><![CDATA[<p>仅此献给那段时光。</p><a id="more"></a><p><img src="https://i.loli.net/2019/07/15/5d2bebe2c98cd83491.jpg" alt></p><p>听 mgt 说，火车上特别适合写些东西，然而我又没什么可以写的，想来想去，还是补完去年十二月就停笔的 OI 记吧。</p><p>事后再回忆，很多事情往往会变得更精彩。对于 OI 也同样，自从去年十二月被坑掉 WC 名额，我就一直在逃避有关 OI 的话题。我在 OI 方面是一个失败者，在高潮还未开始时就已戛然停止。看着 HH 和 swk 参加 NOI，心里其实蛮不是滋味。然而，是时候写一篇 OI 记了，已经快一年了，我有写一篇 OI 记的必要了，如果事后留下的仅仅是精彩的回忆，那 OI 的滋味岂不少了一份丰富。</p><p>之前我是写过一段有关 OI 期间的回忆的，但是由于时间有些久远，更重要的是，我在写那篇文章时，OI 期间最精彩的日子还没到来。</p><p>仅此献给我的 OI 时光。</p><p>距离上次进入 OI 教室也只有一周的时间，但是那些人已经开始陌生起来。他们开始进行省选培训，而我仅仅是在补课期间进去自习而已，不仅仅是羡慕他们能再翘掉半年的文化课时间，更是对自己 OI 生涯短暂的扼腕叹息。</p><p>我在 USAC 游记中也提到过，我 OI 生涯最大的遗憾就是，没能出省进行大型的比赛，没能在 APIO 和 HH、ioa、青蛙子、q姐面基。因为身在强校，我一直窝在学校里享受优质的教学资源，于是，每天早晨开始的考试，下午的评奖，晚上短短的摸鱼时间变成了我的日常，从开始集训到集训结束，虽然我吃的很多，体重依然减了 10 斤以上。</p><h2 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h2><p>我给雷哥，CBR打了招呼，然后坐在自己的座位上。我的座位在最后一排，从左向右数第四个，当然，我不是因为想要摸鱼才选择最后一排的，只是因为觉得那个位置很清净，还不用承受冷到爆炸的空调的洗礼。</p><p>教室的里的空调一直是一个传说，去年暑假，哪怕是最热的时候，教室里的温度也不超过 25 度，所以我进教室通常会披一件皮肤衣。</p><p>谈到摸鱼，有段时间，每天晚上我会给自己半个小时到一个小时看漫画，有一次被老师看到，吓得差点从座位上跳起来。还有一次，L 同学去吃饭了，忘记关他的摸鱼界面，我给他拍下来发给他，说我不帮他关，让他自己回教室关。教室背后的窗帘永远是拉上的，因为玻璃反光，那些摸鱼的同学不仅脸上会反射着奇妙颜色的光，而当 W 老师进教室时，背后的玻璃也能把他们出卖。</p><p>整个教室，有不少人的电脑运行内存比别人多了一倍以上，而在那些特殊的电脑里，我的电脑又是最特殊的之一。现在想来都是运气好。大概是在一年前，老师给所有人的电脑换上了 win 7，因为一开始的 xp 实在是难用。换上的那一天，我在电脑上装上了网易云，VSCode 还有一些常用的软件。第二天来的时候，忽然发现我装上的东西都没有被删掉，因为电脑是安装了还原卡的。后来问 W 老师，老师说，第一次重启时不会启动还原卡。可能是因为那天塞了过多需要开机启动的东西，我的电脑成了班上开机最慢，每次早晨到校，我会按开机，然后去厕所蹲一会儿，回来后差不多该开机结束了。</p><p>xp 的电脑曾经困扰了我很久，因为 xp 实在是太难用了… 因为 xp 系统的原因，我用了大半年的 sublime text，直到装上 win 7，我才享受上 VSCode 和 Clion，Clion 的代码背景着实好看，有一段时间我用发热巫女的一张专辑背景做代码背景，结果 W 老师不满意了，于是我就换回了 VSCode，用的 EvaTheme，mgt 推荐的，着实好看，还有 Fira Code。关于编译环境，我因为编译环境问题（DevCpp GDB 支持太差），不到万不得已不用 gdb 调试，一直用 luogu IDE 进行输出调试。每次写完代码，都扔到 luogu IDE 上运行。</p><p>闲杂的事情就谈到这里，如果还有想起什么，之后再补充吧。</p><p>有关去年暑假开始前的 OI 生活，我并没有什么印象。只记得在 NOIP 2017 中拿了 40 分，18 年年初的所有校内比赛基本都爆零，在 SCOI 2018 中拿了 40 分——当时我连树状数组都不会打。三月高高兴兴去电子科大参加比赛，本以为能基本 AK，结果爆零。现在想来也应该，那时的我基本什么都不会，所有的进步都是在 18 年 7 月放假之后开始的。</p><p>其实那段故事也是一个教训，是操之过急的后果。因为选手水平不一，我早早地跟着其他的选手学了很多省选知识点，包括 LCT，FFT，网络流，DP 优化等等，然而联赛知识点都不熟悉，何谈省选？代码能力不足，思维能力不足，仅仅学会无数的知识点，却不会使用。</p><p>四月，我开始进行专题学习。不知道出于什么原因，我对线段树和 DP 莫名恐惧，可能是因为所有的 DP 题都做不出来，导致我直到联赛前都害怕 DP 题（其实现在也有点）。也可能是因为曾经被线段树难题虐爆，我也迟迟没敢学习线段树，现在想来其实很可笑。我组织大约三十道题，包括 wuvin 处传下来的线段树题，一道一道开始做。在线段树的学习中，我发现自己善于总结，从几十道线段树题中抽离出数据结构题的套路以及本质，也总结了不少主席树，树套树的题（那时我还没有意识到我应该专注于联赛）。五月，我开始做 DP 的专题。幸运的是，最终联赛我并没有翻车在动态规划的题目上（D1T2）。</p><p>六月七月，学校开始集训。</p><p>自此，“OI 与我”的故事已经结束，而 intro 则是那场考试，后来的日子，我将其命名为“五彩斑斓的 OI”。</p><h2 id="五彩斑斓的-OI"><a href="#五彩斑斓的-OI" class="headerlink" title="五彩斑斓的 OI"></a>五彩斑斓的 OI</h2><p>不论是我初中的文化课的技术爆炸，还是高中物理的学习的提升，都源于某一次考试。初二下时有一次，我考了年级 20 名，自那次之后，我的成绩便突飞猛进，高中物理学习也是如此。有一次周考，我莫名其妙考了满分，从那次开始，我的物理水平一路飙升。</p><p>mgt 的那句话我很赞同，努力学习，并且接受反馈是一件很幸福的事情，而成绩的步进是一种良性循环，从考好，到高兴，到虚荣心驱动自己再次想要考好。虽然我并不乐意承认，偶然的一次考好是我进步的直接原因，但是这的确是我在”看山还是山“时期的回忆吧。</p><p>但是，并不是每个人都有好运气，也并不是每个人都有一次偶然考好的机会。成绩的测量是客观的，尽管有其不准确性。从成功的原因中抽离出核心的话，我认为是”自信“吧。许多人的成功是不可复制的，但我认为，自信引导的成功并非不可复制，在我身上，已经被 ctrl + v 三次了。</p><p>六月一次，似乎是因为难得的早睡，起床后的状态特别好，早早地来到学校和 JZO，LPA 打了招呼，趴在桌子上睡了一个小时。那天想必是天晴吧，不然我也不会有如此好的心情。就连老师过来宣布”今天要考试“都似乎不算什么了。老师把成绩单放在网上时，我颤抖地点开，却发现 XZK 的名字位于第二行，第一行是万年满分的 std 同学。那次考试我拿了 240 分，是我第一次上 100 分，是我第一次上 200 分，也是我第一次拿全班第一。与往常不同，我没有在意我是否能完完全全地做起每一道题，而是去在于我能否拿更高的分，果然，每道题都没有拿全分，但是每道题都有 80 分。</p><p>全班第一，全班第一，这个名词现在听起来其实很残酷，也很可笑。</p><p>为何可笑？其实我当初并不是全班第一，因为班级分为联赛班和省选班，省选班的同学都在楼上自习，我仅仅是联赛班第一而已。当 W 老师在班上问我，你是否要参加省选班时，我选择了联赛班。也是那次选择，代表我降级了梦想。如果在那时选择省选，就代表我要放弃之后的文化课学习，冒极高的风险，再停课大半年。我本认为，面对青春年华无需考虑”风险“二字，仅需委心任去留，但我终归面对了现实，那个曾经仰望星空的孩子也低下了头，为自己以往的颓废、错误的学习方法道歉。我至今无法接受我当初的选择，但是，如果如今的我再次面临相同的选择，我依然会选择面对现实，人往往会面对此类冲突，我让步了。</p><p>为何残酷？在最后，联赛班的同学一起补文化课时，我了解到，联赛班最终只有四个人拿到了一等奖。我，JZO， 还有两个我非常反感的同学。其中一个，每天电脑开机便是游戏，集训期间每天的游戏时间超过六个小时，而每天除考试外基本不会做题。另外一个，与前者同流合污，不谈他不善交际的问题，脑子里随时缺了一根筋，话里带刺，每次考试只要题简单，并且容易错，他的题目就会出现”文件错误“，我可以带着恶意猜测，他是怕做不对题被骂才故意改错的文件名么？不仅如此，他也满口不离游戏，每次玩游戏被逮的都是他。不怕得罪人，我可以愤慨地说，可怜那些努力却没能拿到一等的同学。但 OI 确实很大程度上是一种智力竞赛，人生无常。但是 OI 终归不是人生，以智商在 OI 中取胜，不代表能在所有的竞争中胜出，漫漫长路上，人格与人性才是成功的决定性因素。OI 中失利的同学们，请看向前方。</p><p>故事继续。</p><p>让我印象深刻的有一次下雨，碰巧，父亲出差，没法送我去学校，我只能和母亲两人坐地铁去学校。母亲也在市中心上班，离学校很近。出发时雨还不大，直到我下地铁，走到地铁口，我才发现不对劲。雨水哗啦哗啦从楼梯上淌下来，排水道里滴答滴答的雨滴声和流水声混杂在一起，有不少没带伞的年轻人在门口等待着雨变小。我带了一把大伞，母亲则是因为怕重随身带着一把太阳伞。在老天爷发威时，太阳伞当然不管用。没等走五步，母亲的伞已经翻着断了，我只能和她互换。那太阳伞也太可怜了，在大风中毫无作用，我将伞贴在身上倒着御风而行，周围全是湿淋淋的上班路中的年轻人们，被大风大雨吹打地毫无形象可言。也不知道自己是怎么到学校的，反正当我踏进教室时，浑身都在滴水，出发时被我寄以厚望的篮球鞋也里里外外湿透了，要知道，这鞋子常在雨中走，却从未湿过袜子。托坐在最后一排的福，我那天整天是脱了鞋子踩在地上考的试，尽管旁边的学长看到我脱鞋，尴尬地对我笑了笑。顺带一提，那天的考试也算顺利。</p><p>再之后呢？时长一个月的集训也结束了，我回到家。坚持着每天做题。</p><p>再之后就是电子科大的集训。那段时间承载着我 OI 期间最美好的回忆，有泪水，也有奋斗。最幸福的不过是每天放学后买一杯奶茶，回到酒店里打 OSU，然后出去吃顿香香的黄焖鸡，接着回酒店写代码。酒店里看不到电子科大。夏天是成都的雨季，今年也一样。那段时光被我放在了“NULL”中，有缘的读者应该能看到吧。18 年的夏天是我的 Summer Pocket，是最珍贵的宝物，而我现在也已经写尽了我脑中的那段时光，无法在思绪中剥离出更多的细节和故事。离开“鸟白岛”时，我并没有意识到自己的不舍，转眼就是金秋九月。</p><p>回到文化课的班上，又要和班主任斗智斗勇了。第一次斗智斗勇是四月，省选前，班主任不允许我停课，而我非要停课，经过一番对峙，还算达成了和解，他最终允许我带电脑到学校去学习，并且允许我去机房。他不同意我停课，很大程度因为他班带的班上很少有竞赛一等奖的学生，他也不相信我能拿到竞赛一等奖。任何学生都无法和他讲理，他认为自己是绝对正确的，就算你能写出陈情表都没法说服他，唯一能动摇他的，就是利益，和极高的成功的可能性。但是这里我要提一句，这里所指的利益，不是他的利益，而是我的利益，他说到底是一个负责任的老师，只是负责任的方式不太令人赞同罢了。我截图下我所有的成绩表，挑选其中考的比较好的打印给他看，不断陈述自己搞竞赛搞好的可能性之高，并且描述竞赛搞好后有多少优惠，经过一番辩驳后，他最终同意我在国庆直到联赛停课。第一个月的文化课学习还算顺利。十月，停课正式开始。</p><p>停课生活并没有什么很精彩的故事，也和暑假的集训期间相同，到校，睡觉，考试，评奖，考得好就继续刷题，考的差就开始颓废。晚自习看看漫画，看看轻小说，十点回家后听听歌，十一点睡觉。这便是我停课期间的日常。</p><p>但是如果仅仅描述就很无趣。</p><p>就如同我 OI 的排名是全国 1k 多一样，数字有多大，就含有多少故事，多少泪水。如果学校仅仅是拿数字出去宣传，就淡化了这个数字的意义，教育学生变成了<code>++i</code>，青春被抽象为了数字 1。数字是 OI 中努力的附属品，而不是 OI 的一切，分数也同样。384 不算高分，失误也不少，但是 384 等于我的图论总结，我的 DP 总结，等等等，还有我的 OI 人生之和，NOIP 考试过程中的激活的每一个神经元都是我 OI 集训期间的一段时光，都是我的青春。那参考的 OI 人数，每一个 1 都对应一个人，对应一个颓废的人，对应一个聪明的人，对应一个努力的人。OI 不仅仅是我的青春，是全中国，全世界千千万万 OIer 的青春，OI 如此有魅力，也是因为此吧。停课期间的每个“day x 总结”也一样，“最终集训”文件夹中的上百个文件，每个文件都对应我的一段时光，对应着我的努力和泪水，在此角度下，文件也不再仅是对硬盘中二进制数据的抽象。</p><p>再次踏入 UESTC 集训期间的楼时，已经是三个月后了，踌躇满志地打开 IDE，面临最终的挑战，要说紧张也难免，但是激动更胜一筹。那天晚上，我看完了 PA 三部曲中的 Tari Tari。</p><p>迈出 UESTC 校门的时候象征着我 OI 时期的终结，并没有多少波澜起伏，就这么平静地结束了。在集训期间我少多次恐惧那一刻，但是真到那时，那份恐惧也涣然冰释了。和同学们最后吃了一次饭，便挥手道别。</p><p>OI 再见。</p><h2 id="人-amp-人"><a href="#人-amp-人" class="headerlink" title="人 &amp; 人"></a>人 &amp; 人</h2><p>这段很难写。</p><p>我之前描述的都是基本完全从我个人角度出发的故事，是独奏，接下来就是合奏了吧。</p><p>OI 期间最精彩的，便是我认识的那些人了。</p><p>这份后劲至今还留存着，我在退役后大半年又因为 OI 认识了 ioa 姐，一个很有趣的人。他和我喜欢的作品也类似，爱好也类似，这是缘分，他们是 OI 留给我的礼物，他也是 HH 留给我的礼物吧…</p><p>如果你在现在询问我，我当初选择 OI 后悔么？我定会做出与广大 OIer 相同的回答——不后悔，这不是废话么。不光是感谢 OI 给予我的时间，更是感谢 OI 给予我的那些朋友。</p><p>所谓“网友”的关系，也因为 OI 变得不同。</p><p>17 年 8 月，中考失利，我出远门旅行。当时我还是个东方众，于是就因为同喜欢东方，并且同学习 OI 认识了 LR 和 mgt。我正巧发现他俩也认识，就把他们拉进了一个群里，当时群里就我们三个人，每天一起聊天，刷题。</p><p>但是说起来，我最早认识的其实是青蛙子吧，因为我记得我和他谈过“马上就要体考”的话题。那个小群转眼间变成了我的精神寄托，开学后，我一拿到手机，第一件事就是打开 TIM，和他们聊上两句。渐渐转向十一月，OIer 们毕业的日子。mgt 拿了一等就退役了，我觉得很可惜。LR 则失利。只拿了一个二等奖。我三等奖都没拿到，想着反正才学习了几个月，也没有感受到压力。</p><p>某一个周六集训的早上，我在 github 关注中发现了一个奇怪的 id，“q234rty”，$q \uparrow 2 \rightarrow 3 \rightarrow \ 4 \downarrow r \rightarrow t \rightarrow y$，居然是键盘上连着的一串，我想，这个人有点个性。于是点进他的 github 主页，也没怎么在意，就继续做题学习了。直到后面有一天，我再次点开了他的 github 主页，并且找到了他的博客，一看，这人怎么这么强啊？！拿了那么多牌？还参加了 NOI？分数这么高？我才发现我的 github 关注中居然有如此的神仙，正巧，那时找到了他的 qq，我就加了他，我那时的 qq id 和 github id不同，他居然认出了我。之后，我一直背着群里的各位叫他 q 姐，并且问他 OI 学习的问题。后来认识的就是 HH 了吧。我不太记得请我是怎么认识 HH 的，可能是看到他在我的一篇博客下的评论吧，我也是这么认识 ioa 的。刚认识他时，他才学 OI 不久，很多代码都调不来。没想到今天都已经参加 NOI 了，我还是颇为感慨。再后来就是纸夜姐，jjj，纸夜姐、jjj我都是在网易云上认识的，我也记不得为啥我当初要拉他们到群里去，总觉得这是天意，总之结果是，我们都相处的很不错。</p><p>这里我本想写很多我们之间的事，想想最终还是决定保留在心底，所以”人 &amp; 人”篇会显得有些不完整。</p><p>时过境迁，LR 和 mgt 都已成了大学生，我，HH 和 ioa 都成了高三学生，群里也基本不会聊算法了。这个小群已陪伴了我快两年。</p><p>在我写这篇文章时，HH 已经绝笔了吧，我为曾有这样一个朋友而自傲，同时我也恨他。</p><p>不知道你们看到这段会怎么想。</p><p>总之，谢谢。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>写了三个多小时，总算把这份长久的遗憾给弥补了，虽然有许多不满意的地方。</p><p>现在是 2019/7/15 10:45，火车正行驶在陕西境内。离北京还很远，希望这次旅行能够顺利吧。</p>]]></content>
      
      
      <categories>
          
          <category> Daily </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Memories </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Math Theory</title>
      <link href="2018/07/30/math_theory/"/>
      <url>2018/07/30/math_theory/</url>
      
        <content type="html"><![CDATA[<h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h1><p>这真的是一篇很长的数论笔记。<br>有不少问题。</p><p><img src="https://i.loli.net/2018/08/04/5b652a0e624c9.jpg" alt></p><blockquote><p>数论全笔记</p></blockquote><a id="more"></a><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul><li>整除</li><li>素数判定</li><li>线性筛</li><li>互质</li><li>约数</li><li>调和级数</li><li>余数</li><li>最大公约数和最小公倍数</li><li>欧拉函数</li></ul><h3 id="唯一分解定理"><a href="#唯一分解定理" class="headerlink" title="唯一分解定理"></a>唯一分解定理</h3><p>每个数，都可以唯一被分解成$p_1^{c_1}p_2^{c_2}…p_n^{c_n}$的形式，其中$p_i$是素数。</p><h3 id="互质"><a href="#互质" class="headerlink" title="互质"></a>互质</h3><p>$a$, $b$互质，即没有公共的质因子。即在唯一分解后，所有的$p_i$不相同。</p><h3 id="整除"><a href="#整除" class="headerlink" title="整除"></a>整除</h3><p>通常有两种写法…这份笔记中，所有的都依照后面一种。</p><ul><li>若$a ; mod ; b = 0$，则$a$能被$b$整除，或$b$能整除$a$，写作$a | b$</li><li>若$b = ka$，记为$b$被$a$整除，$a$整除于$b$。写作$a | b$。</li></ul><p>绕一绕的话…$n = km$，读作$m$整除$n$，$n$被$m$整除，$m | n$，$|$的前后顺序依照$x$整除$y$的形式…绕一绕…过一会儿就绕好了~总之记住，小的放前面，大的放后面。</p><p>整除的性质是一切证明的关键，这里给出：</p><ul><li>$a | b, a | c$，则有$a | (b \pm c)$。</li></ul><h3 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h3><p>若一个数$N$是合数，一定存在$T \leq \sqrt{n}$，且$T$能整除$N$。</p><p>反证法，假设命题不成立，那么一定存在$T &gt; \sqrt{n}$且$T | N$。那么一定存在$\frac{N}{T} \leq \sqrt{n}$且$\frac{N}{T} | N$。则命题成立~</p><p>代码为试除法</p><pre><code class="cpp">inline bool prime(ll val){  for (int i = 2; i &lt;= sqrt(val); ++i)    if(val % i == 0) return false;  return true;}</code></pre><h3 id="线性筛"><a href="#线性筛" class="headerlink" title="线性筛"></a>线性筛</h3><p>普通筛法略过了，我们讲讲线性筛。</p><p>线性筛$O(n)$的原理是，使每个数只被自己最小的质因子筛一次。</p><p>都知道$a \in N$，$b$是质数，那么$a \cdot b$一定不是质数。我们令每个合数只被自己最小的质因子$p$筛出来，那么每个合数只会被筛一次.我们对于每一个数$a$，用$a$去乘上$\leq a$的所有质数。接下来给出，到每个数的时候，它一定被筛过的证明。</p><p>这里是我万年理解不到的…别的教程也不提这个…so郁闷,请把这一段认真看完…我尽量保证了语言没问题。</p><p>我们的筛法是，标记某个小于其本身质数 $\times$ 某个小于其本身的合数。那么，假设，在进行那个“小于其本身的素数”的处理的时候，我们枚举了所有小于其本身的合数，而那时的$break$规则是$prm[j] * val &gt; n$，这个数一定是$\leq n$的，所以其一定被筛过。这种反向思考很赞，但是别人为啥都不提这一点呢。但是啊，普通筛的时候，这么看吧！假如说当前的数可以被分解成$p_1^{c_1}…$，那么它会被所有的$p$筛一次，而某个数的素因子的个数是$\log{n}$级别的，那么复杂度$n\log{n}$。线性筛保证每个数一定只会被其最小的质因子筛过一次，根据上面的描述，已经足够了，所以线性筛的复杂度是$O(n)$。</p><p>代码如下</p><pre><code class="cpp">inline void prime(){  for (int i = 2; i &lt;= n; ++i)  {    if(!vis[i]) prm[++cnt] = i;    for (int j = 1; j &lt;= cnt; ++j)    {      if(i * prm[j] &gt; n) break;      vis[i * prm[j]] = 1;      if(i % prm[j] == 0) break;    }  }}</code></pre><p>代码的顺序和刚才思维的顺序略有不同，而这正好是线性筛的妙处啊！</p><p>尝试一下，并不好实现的思维题</p><h4 id="「ep1」-质因数分解-N-。"><a href="#「ep1」-质因数分解-N-。" class="headerlink" title="「ep1」 质因数分解$N!$。"></a>「ep1」 质因数分解$N!$。</h4><p>这样看~</p><p>利用线性筛的思路，我们每个合数只被其最小质因子筛一次。</p><p>我们知道一个数的质因数分解形式后，用这个数乘上一个质数，能够知道计算结果的质因数分解形式。我们对结果的形式累乘，就是答案~不优化的话，时间复杂度和空间复杂度都是$O(n\log{n})$，实现也会很复杂。仅练习思维。</p><h4 id="「ep2」-求-L-R-的质数个数。-L-R-leq-2-31-R-L-leq-10-6-。"><a href="#「ep2」-求-L-R-的质数个数。-L-R-leq-2-31-R-L-leq-10-6-。" class="headerlink" title="「ep2」 求$[L, R]$的质数个数。$L, R \leq 2^{31}, R - L \leq 10^{6}$。"></a>「ep2」 求$[L, R]$的质数个数。$L, R \leq 2^{31}, R - L \leq 10^{6}$。</h4><p>可以筛$R - L$的，那么我们先把$[2, \sqrt{R}]$之间的数筛出来，这里的数一定可以组合出$[L, R]$的所有数。然后对于所有质数，我们进行$[L, R]$的标记。$vis[i \times p] = 1, i \in [\frac{L}{p}, \frac{R}{p}]$。</p><h3 id="调和级数"><a href="#调和级数" class="headerlink" title="调和级数"></a>调和级数</h3><p>并不能给出详细的解答，总之记住公式，$\sum_{i = 1}^{n}{\frac{n}{i}} = n\ln{(n+1)} + nr$。$r$为欧拉常数，约等于$0.5772156649$，所以遇到形如$\sum_{i = 1}^{n}{\frac{n}{i}}$的算式，在时间复杂度中通常记作$n\log{n}$，或$n\ln{n}$。我习惯前者。调和级数通常用作时间复杂度的证明。</p><h3 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h3><p>下面介绍一点约数常用定理。</p><p>定义$N$。</p><p>约数的定义为$d | N$，d为约数。</p><p>可以简单发现，$p_i$是$N$的约数，也就是说，$p_1^{c_1}p_2^{c_2}…p_n^{c_n}$的子集都是其一个约数。</p><p>假设$N$进行唯一分解后的数是$p_1^{c_1}p_2^{c_2}…p_n^{c_n}$。</p><ul><li>$N$的正约数的个数 $=\prod_{i = 1}^{m}{(c_i + 1)}$。乘法原理</li><li>$N$的正约数和为$\prod_{i = 1}^{m}{(\sum_{j = 0}^{c_i}{(p_i)}^j)}$。手玩~</li><li>$N$的正整数约数集合是试除法，这里不再赘述…<br>还有一个求法。</li><li>对于数字$d$，$d$一定是$d \cdot k$的约数。这样筛下来，复杂度是$O(\sum_{i = 1}^{n}{\frac{n}{i}})$。利用调和级数，$O(n\log{n})$。比$O(n\sqrt{n})$要好得多。</li></ul><h3 id="余数"><a href="#余数" class="headerlink" title="余数"></a>余数</h3><p>$a ; mod ; b = c$，称$c$是$a$除以$b$的余数。余数的定义式如下   $a ; mod ; b = a - \lfloor \frac{a}{b} \rfloor \cdot b$<br>看一个例题：$BZOJ1257$。</p><h4 id="「ep3」求-sum-i-1-n-k-mod-i-。"><a href="#「ep3」求-sum-i-1-n-k-mod-i-。" class="headerlink" title="「ep3」求$\sum_{i = 1}^{n}{k ; mod ; i}$。"></a>「ep3」求$\sum_{i = 1}^{n}{k ; mod ; i}$。</h4><p>转化题目，求$\sum_{i = 1}^{n}{(k - \lfloor \frac{k}{i} \rfloor \cdot i)} \Rightarrow k \times n -\sum_{i = 1}^{n}{(\lfloor \frac{k}{i} \rfloor \cdot i)}$。由于复杂度的问题，我们从$\frac{k}{i}$入手，因为会有一段区间，使得其不变。我们设$\lfloor\frac{k}{i}\rfloor = x$。这段区间的值是$\frac{(i_{first} + i_{end}) \times (end - first + 1)}{2} \times x$。所以问题来了，我们需要快速获取什么区间内，$\lfloor\frac{k}{i}\rfloor$不变。<br>结论如下，我也不知道怎么推的。$i \in [x, \lfloor \frac{k}{\lfloor \frac{k}{x} \rfloor} \rfloor]$时，$\lfloor\frac{k}{i}\rfloor$不变。$x$是上一个的右端点 + 1，即这次的左端点，这是数论分块的经典写法。具体请见代码，lyd的代码如下：</p><pre><code class="cpp">#define ll long long#define R register#include &lt;bits/stdc++.h&gt;using namespace std;ll n, k, ans;int main(){  scanf(&quot;%lld%lld&quot;, &amp;n, &amp;k);  ans = n * k;  for (int l = 1, r; l &lt;= n; l = r + 1)  {    r = k / l ? min(k / (k / l), n) : n;    ans -= (k / l) * (l + r) * (r - l + 1) / 2;  }  printf(&quot;%lld&quot;, ans);}</code></pre><h4 id="「ep4」求-sum-i-1-n-sum-d-i-d-2-mod-p-，-n-leq-10-12-p-leq-10-9"><a href="#「ep4」求-sum-i-1-n-sum-d-i-d-2-mod-p-，-n-leq-10-12-p-leq-10-9" class="headerlink" title="「ep4」求$\sum_{i = 1}^{n}{\sum_{d | i}{d^2}} ; mod ; p$，$n \leq 10^{12}, p \leq 10^9$"></a>「ep4」求$\sum_{i = 1}^{n}{\sum_{d | i}{d^2}} ; mod ; p$，$n \leq 10^{12}, p \leq 10^9$</h4><p>首先，$\sum{i ^ 2} = \frac{n(n + 1)(2n + 1)}{6}$，是公式，至于怎么用，下面通过这道题来解释。</p><p>首先注意到，枚举$i$是不现实的。$10^{12}$不可能。我们转换思维，枚举$d$。</p><p>对于$d \leq n$，$d$的倍数的个数为$\lfloor \frac{n}{d} \rfloor$，每次的贡献是$\lfloor \frac{n}{d} \rfloor \cdot d^2$,对整体进行数论分块，对于$\sum_{i \in [L, R]}{i^2} = \frac{R(R + 1)(2R + 1)}{6} - \frac{(L - 1)(L)(2L - 1)}{6}$，我们对于$\lfloor \frac{n}{d} \rfloor$相同的整体进行计算，然后套数论分块模板~</p><pre><code class="cpp">// by kririae#define ll long long#include &lt;bits/stdc++.h&gt;using namespace std;ll n, mod, ans;inline ll fast_pow(ll a, ll p){  ll ans = 1; a %= mod;  for (; p; p &gt;&gt;= 1)  {    if(p &amp; 1) ans = (a * ans) % mod;    a = (a * a) % mod;  }  return ans;}inline ll inv(ll a, ll p){  return fast_pow(a, p - 2);}inline ll calc(ll val){  static ll _inv = inv(6, mod); val %= mod;  return (((((val * (val + 1)) % mod) * ((val &lt;&lt; 1) + 1)) % mod) * _inv) % mod;}int main(){  scanf(&quot;%lld%lld&quot;, &amp;n, &amp;mod);  for (ll l = 1, r; l &lt;= n; l = r + 1)  {    r = (n / l) ? min(n / (n / l), n) : n;    ans = (ans + (n / l) * ((calc(r) - calc(l - 1) + mod) % mod)) % mod;  }  printf(&quot;%lld&quot;, ans);}</code></pre><p>复杂度是$O(\sqrt{n})$。</p><p>简单总结下这道题过程中出现的问题…</p><ul><li><code>calc(r) - calc(l - 1)</code>出现了负数。</li><li>逆元求太多次，忘了加<code>static</code>。</li><li>注意<code>mod</code>的问题。</li></ul><blockquote><p>逆元的问题我会在后面提到。</p></blockquote><h3 id="最大公约数和最小公倍数"><a href="#最大公约数和最小公倍数" class="headerlink" title="最大公约数和最小公倍数"></a>最大公约数和最小公倍数</h3><p>定义：若存在$d$，$d | a$且$d | b$，$d$中最大的一个就是$gcd(a, b)$，$(a, b)$的最大公约数。若存在$a | m$且$b | m$。$m$取值最小的一个被称作$lcm(a, b)$，$(a, b)$的最小公倍数。</p><p>特别的，给出另一种$gcd$的理解方式。将$a, b$进行质因数分解，这俩重叠的部分就是$gcd(a, b)$。下面的证明将会用到。这种理解方式会被用到大量的证明中去。</p><p>最大公约数性质如下，$gcd(a, b) = gcd(b, a)$，$gcd(a, 0) = a$，$gcd(a, 1) = 1$, $gcd(ak, bk) = k \cdot gcd(a, b)$，$gcd(a + kb, b) = gcd(a, b)$，若$gcd(a, b) = 1$, $gcd(ab, k) = gcd(a, k) \cdot gcd(b, k)$。</p><p>给出最后一条的证明，这里会用到$gcd$的另一种理解方式~。</p><p>证明：$k = \prod{k_i^{f_i}}$,$a = \prod a_i^{q_i}$,$b = \prod b_i^{s_i}$  ,则根据定义：$gcd(a, k) = \prod a_i^{min(q_i, f_i)}$  ，$gcd(b, k) = \prod b_i^{min(s_i, f_i)}$  ，又$a$, $b$互质，所以不存在$a_i = b_i$,则$ab = \prod a_i^{q_i} \cdot \prod b_i^{s_i}$，从而$gcd(ab, k) = \prod a_i^{min(q_i, f_i)} \cdot \prod b_i^{min(s_i, f_i)}  =gcd(a, k) \cdot gcd(b, k)$。$Q.E.D$</p><p>倒数第二条的证明我将在更相减损术处提到。</p><p>有定理，$gcd(a, b) \times lcm(a, b) = a \cdot b$。令$d = gcd(a, b)$，$x = \frac{a}{d}, y = \frac{b}{d}$。则$gcd(x, y) = 1, lcm(x, y) = x \cdot y$。则$lcm(x, y) \cdot d = \frac{a \cdot b}{d}$。</p><p>更相损减术，定理如下，$gcd(a, b) = gcd(b, a - b) = gcd(a, a - b)$。欧几里得算法，$gcd(a, b) = gcd(b, a ; mod ; b)$。由于更相损减术是欧几里得算法的特例，这里给出欧几里得算法的证明。若$a &lt; b$，易得$gcd(a, b) = gcd(b, a)$。若$a \geq b$，不妨设$gcd(b, a ; mod ; b) = gcd(a - nb, b)$，$n$为任意整数。设$a = nb + k$，根据定义，有$k = a ; mod ; b$。对于公约数$d$，有$d | a$，$d | nb$。则$d | (a - nb)$。$d | k$，所以$d | b, d | a ; mod ; b$.，公约数集合相同，所以最大公约数相同。备注一句，因为$d$对于所有公约数都成立，所以说公约数集合成立，这是证明中的常见手段。</p><p>代码如下：</p><pre><code class="cpp">int gcd(int a, int b){  return b ? gcd(b, a % b) : a;}</code></pre><h4 id="「ep5」给出-a-0-b-0-a-1-b-1-，求满足-gcd-x-a-0-a-1-lcm-x-b-0-b-1-的-x-的个数，-a-b-leq-10-9"><a href="#「ep5」给出-a-0-b-0-a-1-b-1-，求满足-gcd-x-a-0-a-1-lcm-x-b-0-b-1-的-x-的个数，-a-b-leq-10-9" class="headerlink" title="「ep5」给出$a_0, b_0, a_1, b_1$，求满足$gcd(x, a_0) = a_1, lcm(x, b_0) = b_1$的$x$的个数，$a, b \leq 10^9 $"></a>「ep5」给出$a_0, b_0, a_1, b_1$，求满足$gcd(x, a_0) = a_1, lcm(x, b_0) = b_1$的$x$的个数，$a, b \leq 10^9 $</h4><p>朴素算法如下，我们知道，$x | b_1, b0 | b1$，$a_1 | x, a0 | a_1$,某个数的约数个数大约$2 \sqrt{n}$，我们枚举$b_1$的约数$x$，然后$check$是否满足$gcd(x, a_0) = a_1, lcm(x, b_0) = b_1$。具体来说，我们用搜索算法组合出$b_1$所有的约数，然后判断条件是否满足，可过，代码懒得给了qwq颓颓颓</p><p>机智的算法先咕咕咕着…</p><h3 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h3><p>之前提到过，对于$gcd(a, b) = 1$的情况，我们称$a, b$互质，互质的另一种解释方法是：$a = \prod{a_i^{q_i}}$，$b = \prod{b_i^{e_i}}$，所有的$a_i != b_i$。也就是${a} \cap {b} = \emptyset$。对于三个及更多，互质称作“两两互质”，即所有的数没有公共质因子。</p><p>欧拉函数，定义为$[1, n]$中和$n$互质的数的个数，记作$\varphi(n)$。</p><p>$\varphi(n)$有以下公式：</p><p>$$\varphi(n) = n \cdot \prod_{(prime;p) | n}{(1 - \frac{1}{p})}$$</p><p>证明：</p><p>设$p$为$n$的质因子，则$p | n$，而$kp \leq n$的所有$kp$都不与$n$互质。而$kp$有$\lfloor \frac{n}{p} \rfloor$个，而$q$为$n$质因子，$kq$有$\lfloor \frac{n}{q} \rfloor$个，而$pq$的倍数又被重复计算，所以$n$中含有$\lfloor \frac{n}{pq}\rfloor$个重复计算的，需要剔除。$[1, n]$中不含$p, q$为质因子的数的个数是$n - \frac{n}{p} - \frac{n}{q} + \frac{n}{pq} = n(1 - \frac{1}{p})(1 - \frac{1}{q})$。同理可得。代码如下：注意精度问题，需要特殊处理。</p><pre><code class="cpp">inline int phi(int n){  int ans = n;  for (int i = 2; i &lt;= sqrt(n); ++i)    if(n % i == 0)    {      ans = (ans - ans / i);      while(n % i == 0) n /= i;    }  if(n &gt; 1) ans = ans - ans / n;  return ans;}</code></pre><p>$\varphi$函数的性质有：</p><ul><li>$[1, n]$的数中和$n$互质的数的和是$\frac{n \cdot \varphi(n)}{2}$。就是$gcd(a, n) = 1$，$a$的和。由九章算术，$gcd(n, a) = gcd(n, n - a)$。所以我们要求出$(n, n - a)$的平均数，手玩可得，平均数为$\frac{n}{2}$。</li><li>若$a, b$互质，则$\varphi(ab) = \varphi(a) \cdot \varphi(b)$。这是积性函数的性质，积性函数我将会在后面进行讨论。设$a = \prod{a_i^{c_i}}$,$b = \prod{b_i^{d_i}}$。则$\varphi(a) = a \cdot  \prod_{i \in {a_i}}{(1 - \frac{1}{i})}$，$\varphi(b) = b \cdot  \prod_{i \in {b_i}}{(1 - \frac{1}{i})}$。又${a_i} \cap {b_i} = \emptyset$，则$\varphi(a) \cdot \varphi(b) = ab \cdot \prod_{i \in {a_i}}{(1 - \frac{1}{i})} \cdot \prod_{i \in {b_i}}{(1 - \frac{1}{i})}$，且$\varphi(ab) = ab \cdot \prod_{i \in ({a_i} \cup {b_i})}{(1 - \frac{1}{i})}$，得证。写公式好累。通过这个性质，可以$O(n)$预处理$\varphi$值。这个先不忙。</li><li>$n$为质数时，$\varphi(n) = n - 1$。这个没必要解释吧QwQ</li><li>$\sum_{d | n}{\varphi(d)} = n$。这条的证明已经折磨了我一个小时了…可以用狄利克雷卷积来证明。有一个初等证明，但还是不简单。对逻辑要求极高。<br>证明：<br>首先，对于分母为$b$，分子为$a$，$a &lt; b$的既约分数，假如说固定$b$的取值，那么$a$的取值有$\varphi(b)$种。关于这道题，我们考虑所有的$\frac{i}{n}, i \in [1, n]$，将其约分，对于约分后的分数$\frac{a}{b}$，一定有$gcd(a, b) = 1, b | n, a | i$且$a &lt; b$。假定一个$d | n$，那么在之前的分数集合中，以$d$为分母的既约分数个数就有$\varphi(d)$个。而$|$分数集合$| = n$，所以$\sum_{d | n}{\varphi(d) = n}$<br>$Q.E.D.$<br>举个例子来演示一下吧<br>对于$6$，我们构造出了$\frac{1}{6}, \frac{1}{3}, \frac{1}{2}, \frac{2}{3},\frac{5}{6}, \frac{1}{1}$。这其中，以$1 | 6$为分母的有$\varphi(1)$个，也就是$\frac{1}{1}$。以$2 | 6$为分母的有$\varphi(2)$个，也就是$\frac{1}{2}$。以此类推，我们可以发现，分母$d$的取值只有$d | n$，而$\varphi(i)$的和正是前面分数集合的大小。<br>真是妙极了</li><li>$n = \prod{p_i^{c_i}}$，则$f(n) = \prod{f(p_i^{c_i})}$。首先，易得，$gcd(p_i^{c_i}, p_j^{c_j}) = 1$，满足积性函数，则易证。</li><li>若$p | n$，则有$\varphi(p \cdot n) = \varphi(n) \cdot p$</li><li>反之，$\varphi(p \cdot n) = \varphi(n) \cdot (p - 1)$。<br>因为$p$是质数，且$p \nmid n$(?)，所以$gcd(p, n) = 1$。有$\varphi(p) = p - 1$，由积性函数性质可证明。对于$p | n$，带入定义式，$\varphi(n) = n \cdot \prod_{(prime;p) | n}{(1 - \frac{1}{p})}$，因为$p | n$，所以直接在前面的$n \cdot p$，得证。（好方法啊</li></ul><h4 id="欧拉函数拓展"><a href="#欧拉函数拓展" class="headerlink" title="欧拉函数拓展"></a>欧拉函数拓展</h4><h5 id="O-n-递推"><a href="#O-n-递推" class="headerlink" title="$O(n)$递推"></a>$O(n)$递推</h5><p>证明参见刚才的最后俩条</p><pre><code class="cpp">inline void phi(int n){    for (int i = 2; i &lt;= n; ++i)    {        if(!vis[i]) prm[++cnt] = i;        for (int j = 1; j &lt;= cnt; ++j)        {            if(i * prm[j] &gt; n) break;            vis[i * prm[j]] = 1;            if(i % prm[j] == 0)            {                phi[i * prm[j]] = phi[i] * prm[j];                break;            } else phi[i * prm[j]] = phi[i] * (prm[j] - 1);        }    }}</code></pre><h5 id="狄利克雷卷积和莫比乌斯反演初步"><a href="#狄利克雷卷积和莫比乌斯反演初步" class="headerlink" title="狄利克雷卷积和莫比乌斯反演初步"></a>狄利克雷卷积和莫比乌斯反演初步</h5><p>$Dirichlet$定义如下：$qwq(n) = \sum_{d | n}{f(n)g(\frac{n}{d})}$ 。简化记为$qwq(n) = f(n) * g(n)$。我只会这点（逃</p><h3 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h3><p>同余的定义如下，$a ; mod ; m = b ; mod ; m$，则称$a, b$同余，写作$a \equiv b ; (mod ; m)$ ，<code>a \equiv v \ (mod \ m)</code>.</p><p>对于$i \in [0, m - 1], {a + km}$，$i ; mod ; m = a$。这是$; mod ; m$下的<strong>同余类</strong>。模数$x$的同余类有$x - 1$个，构成<strong>完全剩余系</strong>。</p><p>$[1, m]$中$gcd(i, m)$，$i$组成的集合叫做简化剩余系$S$。设$a \in S, b \in S$，由欧几里得算法可得$gcd(a \cdot b, m) = 1 \Rightarrow gcd(a \cdot b ; mod ; m, m) = 1$。则$a \cdot b \ mod \ m \in S$。</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>欧拉定理的定义如下：如果$gcd(a, n) = 1$，则$a^{\varphi(n)} \equiv 1 \ (mod \ n)$。我并不会证明。欧拉定理可以推导出费马小定理。费马小定理如下：若$p$是质数，则$a^p \equiv a \ (mod \ p)$。我也不会证。</p><p>欧拉定理有重要推论，$a^b \equiv a^{b \ mod \ \varphi(n)} \ (mod \ n)$。若$a, n$互质。</p><h4 id="关于欧拉定理的本质"><a href="#关于欧拉定理的本质" class="headerlink" title="关于欧拉定理的本质"></a>关于欧拉定理的本质</h4><p>这里又要提到一个别人不常提到的东西了。这样测试：$a^{i} \ mod \ p$。循环节的长度一定是$\varphi(p)$。但不一定是最小的。$5^i \ mod \ 13$的循环节是$5 \ 12 \ 8 \ 1$，长度为$4$，$\varphi(13) = 12$。$4 |12$。然后，之后会在拓欧降幂处提到。</p><h4 id="「ep6」求-a-b-b-b…-mod-10-9-7-，-b-有-n-个。-a-b-leq-10-16-。"><a href="#「ep6」求-a-b-b-b…-mod-10-9-7-，-b-有-n-个。-a-b-leq-10-16-。" class="headerlink" title="「ep6」求$a^{b^{b^{b…}}} \ mod \ (10^{9} + 7)$，$b$有$n$个。$a, b \leq 10^{16}$。"></a>「ep6」求$a^{b^{b^{b…}}} \ mod \ (10^{9} + 7)$，$b$有$n$个。$a, b \leq 10^{16}$。</h4><p>首先需要知道，后面挂着的那一坨该怎么处理。我们看$b^b$的本质是什么？$b^b = \underbrace{b \times b \times \cdot\cdot\cdot \times b}_{b}$。转化为$a^{a^{b - 1}} \ mod \ (10^9 + 7)$。根据费马小定理$a^{p - 1} \equiv 1 \ (mod \ p)$。所以$a^{a^{b - 1}} \equiv a^{(a^{b - 1}) \ mod \ (p - 1)} \ (mod \ p)$。不懂这一步的话可以考虑$1$哪去了。然后用快速幂解决。</p><h3 id="拓-扩-展欧几里得算法"><a href="#拓-扩-展欧几里得算法" class="headerlink" title="拓(扩)展欧几里得算法"></a>拓(扩)展欧几里得算法</h3><p>拓欧的定理如下$ax + by = gcd(a, b)$。而我们就是要解这个不定方程。</p><p>问题来了，如何解?根据欧几里得算法，有$ax + by = bx’ + (a \ mod \ b)y’ = gcd(a, b) = gcd(b, a \ mod \ b)$。而根据之前提到过的模数的定义，$a \ mod \ b = a - \lfloor \frac{a}{b} \rfloor \cdot b$，得出$ax + by = bx’ + (a - \lfloor \frac{a}{b} \rfloor \cdot b)y’$。化简得到$ax + by = ay’ -  b \cdot (x’ - \lfloor \frac{a}{b} \rfloor \cdot y’)$。我们令$x = y’, y = x’ - \lfloor \frac{a}{b} \rfloor \cdot y’$。当$b = 0$时，$x = 1, y = 0$。因为$ax = gcd(a, 0) = 1$。</p><p>$$<br>代码如下</p><pre><code class="cpp">inline void exgcd(int &amp;x, int &amp;y, int a, int b){  if(b == 0) return x = 1, y = 0, void();  else return exgcd(y, x, b, a % b), y -= (a / b) * x;}</code></pre><p>注意，由$bezout$定理可得，$exgcd$必定有整数解。简单解释一下代码，由于写成递归形式，某一层和上一层的$x, y$是反过来的。就有$y -= (a / b)*x$，对应原本的算式是$y = x’ - \lfloor \frac{a}{b} \rfloor \cdot y’$。</p><h4 id="「ep7」BZOJ1407-Savage"><a href="#「ep7」BZOJ1407-Savage" class="headerlink" title="「ep7」BZOJ1407 Savage"></a>「ep7」BZOJ1407 Savage</h4><p>推完公式后…出了各种各样的问题…干脆面向题解。</p><p>公式如下：$c_i + xp_i \equiv (c_j + xp_j) \pmod{M}$.如果存在解，那么可以有两个同一时刻在同一位置。转换为$x(p_i - p_j) - km = c_i - c_j$。首先判定有无整数解，如果有的话，$x \leq min(l[i], l[j])$。因为在死亡之后碰面不做数~</p><p>代码如下</p><pre><code class="cpp">// by kririae#include &lt;bits/stdc++.h&gt;using namespace std;inline void exgcd(int &amp;x, int &amp;y, int a, int b){  if(b) exgcd(y, x, b, a % b), y -= (a / b) * x;  else x = 1, y = 0;}inline int gcd(int a, int b){  return b ? gcd(b, a % b) : a;}int n, c[20], p[20], l[20];inline bool judge(int M){  for (int i = 1; i &lt;= n; ++i)    for (int j = i + 1; j &lt;= n; ++j)    {      int a = p[i] - p[j], b = c[j] - c[i];      a = (a % M + M) % M;      int g = gcd(a, M);      if(b % g == 0)      {        // 有解        int x = 0, y = 0;        exgcd(x, y, a, M);        x = ((x * (b / g)) % (M / g) + (M / g)) % (M / g);        if(x &lt;= min(l[i], l[j])) return false;      }    }  return true;}int main(){  scanf(&quot;%d&quot;, &amp;n);  int mx = 0;  for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d%d%d&quot;, &amp;c[i], &amp;p[i], &amp;l[i]), mx = max(mx, c[i]);  for (int M = mx; M &lt;= 1e6; ++M)    if(judge(M)) return printf(&quot;%d&quot;, M), 0;}</code></pre><h3 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a>乘法逆元</h3><p>多数时候用于处理除法带$mod$的情况，$\frac{a}{b} \equiv a \cdot \mathrm{inv}(b) \pmod{m}$。$\mathrm{inv}(b)$就是$b$的逆元。逆元存在的前提是：…先不说这个，我们用丢番图方程的整数解来证明。上式可以化为$a \equiv ab \cdot \mathrm{inv}(b) \pmod{m}$。再次化简得到$b \cdot \mathrm{inv}(b) \equiv 1 \pmod{m}$。$b \cdot \mathrm{inv}(b) - km = 1$。此方程当且仅当$gcd(b, m) = 1$时有解，进而推导$b$在$mod \ p$意义下的乘法逆元当且仅当$gcd(b, m) = 1$时存在。第一种方法，对于逆元存在的时候，可以求$exgcd$。从而得出逆元。</p><p>还有一种解法，当$p$为质数时，利用费马小定理：$b^p \equiv b \pmod{m}$。$b \cdot b^{p - 2} \equiv \pmod{m}$。所以$b^{p - 2}$是$b$在模$p$意义下的乘法逆元。代码分别是<code>exgcd(x, y, a, p), return (x % p + p) % p</code>。<code>return fpow(a, p - 2, p)</code>。</p><p>但是，还有一种球法！$inv[1] = 1, inv[i] = (p - \lfloor\frac{p}{i}\rfloor) \cdot inv[p \ mod \ i] \ mod \ p$。</p><p>写成代码是这样</p><pre><code class="cpp">for (int i = 2; i &lt;= n; ++i)    inv[i] = (p - p / i) * inv[p % i] % p;</code></pre><p>前两种复杂度是$O(log{n})$,最后一种是$O(n)$，不常用。</p><p>顺带一提，$inv(b, p) = inv(b \ mod \ p, p)$，不然用个锤。因为定义，$ax \equiv 1 \pmod{m}$。$ax \ mod \ m = a \ mod  \ m \cdot x \ mod \ m$。</p><h3 id="线性同余方程"><a href="#线性同余方程" class="headerlink" title="线性同余方程"></a>线性同余方程</h3><p>给定$ax \equiv b \pmod{m}$。可以得到$ax + my = b$，有解当且仅当$gcd(a, m) | b$。方程的所有解是$\ mod \ \frac{m}{gcd(a, m)}$和$x$同余的整数。</p><h4 id="中国单身狗定理"><a href="#中国单身狗定理" class="headerlink" title="中国单身狗定理"></a>中国单身狗定理</h4><p>有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？</p><p>中国单身狗定理要求以下方程组的解</p><p>$$\begin{equation}<br>\left{<br>  \begin{array}{lr}<br>    x \equiv a_1 \pmod{m_1} \<br>    x \equiv a_2 \pmod{m_2} \<br>    \cdots \<br>    x \equiv a_n \pmod{m_n}<br>    \end{array}<br>  \right.<br>\end{equation}$$</p><p>其中，$gcd(m_1, m_2, \cdots, m_n) = 1$。我被这玩意儿折腾半个月了，这里重新来认真搞一搞。</p><p>令$M = \prod{m_i}$，$M_i = \frac{M}{m_i}$。令$t_i$是$M_it_i \equiv 1 \pmod{m_i}$的一个解，（也就是$M_i$关于模$m_i$意义下的一个逆元。则$x$的唯一一组解是$x = (\sum_{i = 1}^{n}{a_it_iM_i}) \ mod \ M$。</p><p>证明：<br>因为$gcd(m_i, m_j) = 1$，所以$gcd(m_i, M_i) = 1$。所以，存在$t_i$，是$M_i$在$\ mod \ m_i$意义下的乘法逆元。即$t_iM_i \equiv 1 \pmod{m_i}$，可以得到$a_it_iM_i \equiv a_i \pmod{m_i}$，又$m_j | M_i$，所以$a_it_iM_i \equiv 0 \pmod{m_j}$。构造$x = \sum{a_it_iM_i}$，所以满足$x = a_it_iM_i  + 0 \equiv a_i \pmod{m_i}$。$Q.E.D.$</p><h4 id="EXCRT-中国EX单身狗定理（大雾"><a href="#EXCRT-中国EX单身狗定理（大雾" class="headerlink" title="$EXCRT$ 中国EX单身狗定理（大雾"></a>$EXCRT$ 中国EX单身狗定理（大雾</h4><p>相比$CRT$，$EXCRT$有个区别，$m_i, m_j$不一定互质。重新看方程：</p><p>$$\begin{equation}<br>\left{<br>  \begin{array}{lr}<br>    x \equiv a_1 \pmod{m_1} \<br>    x \equiv a_2 \pmod{m_2} \<br>    \cdots \<br>    x \equiv a_n \pmod{m_n}<br>    \end{array}<br>  \right.<br>\end{equation}$$</p><p>既然无法一次合并，那就考虑两两合并。</p><p>我们考虑前俩方程：$x \equiv a_1 \pmod{m_1}, x \equiv a_2 \pmod{m_2}$。转换成以下形式，$x = a_1 + k_1m_1, x = a_2 + k_2m_2$，减一下变成$k_1m_1 - k_2m_2  = a_2 - a_1$，根据某打起来太麻烦的定理，这里存在整数解的前提是$gcd(m_1, m_2) | a_2 - a_2$。然后解啊！用扩欧解出特解$k_1, k_2$。令$g = gcd(m_1, m_2), k_1’, k_2’$为俩特解，则$k_1 = \frac{m_2}{g}t + k_1’, k_2 = \frac{m_1}{g}t + k_2’$，带回原式：令$x_0 = a_1 + m_1k_1’$，$x \equiv x_0 \pmod{lcm(m_1, m_2)}$。</p><p>代码如下</p><pre><code class="cpp">// by kririae// 题解ver#define ll long long#include &lt;bits/stdc++.h&gt;using namespace std;inline void exgcd(ll &amp;x, ll &amp;y, ll &amp;g, ll a, ll b){  if(b) exgcd(y, x, g, b, a % b), y -= (a / b) * x;  else x = 1, y = 0, g = a;}inline ll EXCRT(ll *_a, ll *_m, ll n){  ll a = _a[1], m = _m[1], g, x, y, mod;  for (int i = 2; i &lt;= n; ++i)  {    exgcd(x, y, g, m, _m[i]);    if((_a[i] - a) % g) return -1;    x *= (_a[i] - a) / g, mod = _m[i] / g, x = (x % mod + mod) % mod;    a = m * x + a, m = m / g * _m[i], a %= m;  }  return (a % m + m) % m;}const int maxn = 1e5 + 5;ll n, m[maxn], a[maxn];int main(){  cin.tie(0);  ios::sync_with_stdio(false);  cin &gt;&gt; n;  for (int i = 1; i &lt;= n; ++i)    cin &gt;&gt; m[i] &gt;&gt; a[i];  cout &lt;&lt; EXCRT(a, m, n) &lt;&lt; endl;}</code></pre><h4 id="BSGS"><a href="#BSGS" class="headerlink" title="BSGS"></a>BSGS</h4><p>问题如下：</p><p>求解方程，$a^x \equiv b \pmod {p}$。其中$gcd(a, p) = 1$。</p><p>考场写不来BSGS咋办！暴力啊！</p><p>由费马小定理可得，$a^{p - 1} = 1$，所以只用从枚举$[0, p - 1]$。</p><p>然后考虑，如何优化爆搜。这时候就要拉出我们可爱的分块妹子。</p><p>设$x = i \cdot t - j$，其中$t = \sqrt{p}$。$j \in [0, t - 1]$。分块成功~方程转化为$a^{it - j} \equiv b \pmod{p}$。也就是$a^{it} = b \cdot a^j \pmod{p}$。注意$t$是定值，然后枚举$b \cdot a^j$，插入$hash$方便查询。再枚举$a^{it}$，到$hash$表去查询。代码如下：（SDOI2011 计算器）</p><pre><code class="cpp">// by kririae#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;inline void exgcd(ll &amp;x, ll &amp;y, ll &amp;g, ll a, ll b){  if(b) exgcd(y, x, g, b, a % b), y -= (a / b) * x;  else x = 1, y = 0, g = a;}inline ll fpow(ll a, ll p, ll mod){  ll ans = 1;  for (; p; p &gt;&gt;= 1) {    if(p &amp; 1) (ans *= a) %= mod;    (a *= a) %= mod;  } return ans;}inline ll BSGS(ll a, ll b, ll p){  static map&lt;ll, ll&gt; fd;  fd.clear(); int t = sqrt(p) + 1; b %= p;  for (int j = 0; j &lt; t; ++j)    fd[(b * fpow(a, j, p)) % p] = j;  if((a = fpow(a, t, p)) == 0) return b == 0 ? 1 : -1;  for (int i = 0; i &lt;= t; ++i) {    ll val = fpow(a, i, p);    int j = fd.find(val) == fd.end() ? -1 : fd[val];    if(j &gt;= 0 &amp; i * t - j &gt;= 0) return i * t - j;  } return -1;}ll t, k, a, b, p, g, x, y;int main(){  scanf(&quot;%lld%lld&quot;, &amp;t, &amp;k);  switch(k) {    case 1:      while(t--) {        scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;p);        printf(&quot;%lld\n&quot;, fpow(a, b, p));      } break;    case 2:      while(t--) {        scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;p);        exgcd(x, y, g, a, p);        if(b % g) puts(&quot;Orz, I cannot find x!&quot;);        else printf(&quot;%lld\n&quot;, ((x * (b / g)) % p + p) % p);      } break;    case 3:      while(t--) {        scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;p);        ll ans = BSGS(a, b, p);        if(ans == -1) puts(&quot;Orz, I cannot find x!&quot;);        else printf(&quot;%lld\n&quot;, ans);      } break;  }}</code></pre><h3 id="线性基"><a href="#线性基" class="headerlink" title="线性基"></a>线性基</h3><p>线性无关。</p><p>基的概念。</p><p>寻找线性基。</p><p>求出的线性基需要和原集合的选线性组合完全一致。</p><p>求线性基方法如下：</p><p>对于我新加入的某个数，我对它进行二进制的扫描，从高到低位。如果当前位$i$已经有一个线性基$a[i]$，那么我们可以认为，当前数如果要表示，一定选取了那个基，所以我们剔除基的影响，也就是$s[i] \ xor \ a[i]$。最后所得的$a[i]$就是所有的线性基。</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;const int N = 1e5;ll n, mx, t, ans, s[N], a[N];int main() {  scanf(&quot;%lld&quot;, &amp;n);  for (int i = 1; i &lt;= n; ++i)    scanf(&quot;%lld&quot;, &amp;s[i]);  for (int i = 1; i &lt;= n; ++i)    for (int j = 51; j &gt;= 0; --j)      if(s[i] &amp; (1ll &lt;&lt; j)) {        if(a[j] == 0) {          a[j] = s[i];          break;        }        s[i] ^= a[j];      }  for (int i = 51; i &gt;= 0; --i) ans = max(ans, ans ^ a[i]);  printf(&quot;%lld&quot;, ans);}</code></pre><h4 id="SCOI2016-幸运数字"><a href="#SCOI2016-幸运数字" class="headerlink" title="SCOI2016 幸运数字"></a>SCOI2016 幸运数字</h4><p>给出一棵树，每个结点都有一个值$a[i]$，求$i \rightarrow j$路径上的异或最大值。$n \leq 20000$</p><p>倍增上跑线性基。对于每个点$f[i][j]$，存一个$vector$，表示从$i$向上$2^j$的线性基有哪些…每次用$merge$进行暴力合并。最后查询的时候，找到$lca(i, j)$，然后对于$i \rightarrow lca(i, j)$，$j \rightarrow lca(i, j)$的线性基进行合并。复杂度$O(n\log^3{n})$。</p><p>再次跪拜q234rty神犇，没有他窝就A不了这道题。<br>因为。</p><pre><code class="cpp">for (int i = 0; i &lt;= 60; ++i) if(b[i]) insert(b[i], a);</code></pre><p>开始没加if。</p><p>第一种是树剖ver，复杂度$O(nlog^4n)$，不开O2跑不过。</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define ll long long#define ls t[k].son[0]#define rs t[k].son[1]using namespace std;namespace BZOJ4568 {inline char gc(){  static char buf[1 &lt;&lt; 18], *fs, *ft;  return (fs == ft &amp;&amp; (ft = (fs = buf) + fread(buf, 1, 1 &lt;&lt; 18, stdin)), fs == ft) ? EOF : *fs++;}inline ll read(){  register ll k = 0, f = 1;  register char c = gc();  for (; !isdigit(c); c = gc()) if (c == &#39;-&#39;) f = -1;  for (; isdigit(c); c = gc()) k = (k &lt;&lt; 3) + (k &lt;&lt; 1) + (c - &#39;0&#39;);  return k * f;}const int N = 20005;struct Node {  int l, r, son[2];  ll b[65];} t[N &lt;&lt; 2]; int root, tcnt; ll g[N], w[N];int n, q, head[N], ver[N &lt;&lt; 1], nxt[N &lt;&lt; 1], tot;int siz[N], son[N], fa[N], dep[N], id[N], top[N], cnt;inline void addedge(int u, int v) {  ver[tot] = v;  nxt[tot] = head[u];  head[u] = tot++;}inline void dfs1(int x) {  siz[x] = 1, son[x] = 0;  for (int i = head[x], to; ~i; i = nxt[i]) {    if((to = ver[i]) == fa[x]) continue;    fa[to] = x, dep[to] = dep[x] + 1;    dfs1(to);    if(siz[to] &gt; siz[son[x]]) son[x] = to;    siz[x] += siz[to];  }}inline void dfs2(int x, int topf) {  id[x] = ++cnt, w[cnt] = g[x], top[x] = topf;  if(!son[x]) return;  dfs2(son[x], topf);  for (int i = head[x], to; ~i; i = nxt[i]) {    if((to = ver[i]) == fa[x] || to == son[x]) continue;    dfs2(to, to);  }}inline void insert(ll x, ll *a) {  for (int j = 60; j &gt;= 0; --j)    if(x &amp; (1ll &lt;&lt; j)) {      if(a[j] == 0) return a[j] = x, void();      x ^= a[j];    }}inline void merge(ll *a, ll *b) {  for (int i = 0; i &lt;= 60; ++i) if(b[i]) insert(b[i], a);}inline ll gmax(ll *a, ll ans = 0) {  for (int i = 60; i &gt;= 0; --i) ans = max(ans, ans ^ a[i]);  return ans;}inline void pushup(int k) {  merge(t[k].b, t[ls].b), merge(t[k].b, t[rs].b);}inline void build(int &amp;k, int l, int r) {  k = ++tcnt, t[k].l = l, t[k].r = r;  if(l == r) return insert(w[l], t[k].b), void();  int mid = l + r &gt;&gt; 1;  build(ls, l, mid), build(rs, mid + 1, r);  pushup(k);}inline void query(int k, int l, int r, ll *ans) {  if(t[k].l == l &amp;&amp; t[k].r == r) return merge(ans, t[k].b), void();  int mid = t[k].l + t[k].r &gt;&gt; 1;  if(r &lt;= mid) query(ls, l, r, ans);  else if(l &gt; mid) query(rs, l, r, ans);  else query(ls, l, mid, ans), query(rs, mid + 1, r, ans);}inline ll work(int x, int y) {  static ll ans[65], tmp[65];  memset(ans, 0, sizeof(ans));  while(top[x] != top[y]) {    if(dep[top[x]] &lt; dep[top[y]]) swap(x, y);    memset(tmp, 0, sizeof(tmp));    query(root, id[top[x]], id[x], tmp);    merge(ans, tmp);    x = fa[top[x]];  }  if(dep[x] &gt; dep[y]) swap(x, y);  memset(tmp, 0, sizeof(tmp));  query(root, id[x], id[y], tmp);  merge(ans, tmp);  return gmax(ans);}inline void solve() {  memset(head, -1, sizeof(head));  n = read(), q = read();  for (int i = 1; i &lt;= n; ++i) g[i] = read();  for (int i = 1, x, y; i &lt; n; ++i) {    x = read(), y = read();    addedge(x, y);    addedge(y, x);  }  dfs1(1), dfs2(1, 1), build(root, 1, n);  for (int i = 1, x, y; i &lt;= q; ++i) {    x = read(), y = read();    printf(&quot;%lld\n&quot;, work(x, y));  }}}int main() {  return BZOJ4568::solve(), 0;}</code></pre><p>第二种是倍增ver，不开O2跑得过，复杂度$O(nlog^3n)$</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define ll long long#define ls t[k].son[0]#define rs t[k].son[1]using namespace std;namespace BZOJ4568 {inline char gc(){  static char buf[1 &lt;&lt; 18], *fs, *ft;  return (fs == ft &amp;&amp; (ft = (fs = buf) + fread(buf, 1, 1 &lt;&lt; 18, stdin)), fs == ft) ? EOF : *fs++;}inline ll read(){  register ll k = 0, f = 1;  register char c = gc();  for (; !isdigit(c); c = gc()) if (c == &#39;-&#39;) f = -1;  for (; isdigit(c); c = gc()) k = (k &lt;&lt; 3) + (k &lt;&lt; 1) + (c - &#39;0&#39;);  return k * f;}const int N = 20005;struct Node {  int l, r, son[2];  ll b[65];} t[N &lt;&lt; 2]; int root, tcnt; ll g[N], f[N][25][65];int n, q, head[N], ver[N &lt;&lt; 1], nxt[N &lt;&lt; 1], tot;int fa[N][25], dep[N];inline void addedge(int u, int v) {  ver[tot] = v;  nxt[tot] = head[u];  head[u] = tot++;}inline void dfs(int x) {  for (int i = head[x], to; ~i; i = nxt[i]) {    if((to = ver[i]) == fa[x][0]) continue;    dep[to] = dep[x] + 1, fa[to][0] = x;    dfs(to);  }}inline void insert(ll x, ll *a) {  for (int j = 60; j &gt;= 0; --j)    if(x &amp; (1ll &lt;&lt; j)) {      if(a[j] == 0) return a[j] = x, void();      x ^= a[j];    }}inline void merge(ll *a, ll *b) {  for (int i = 0; i &lt;= 60; ++i) if(b[i]) insert(b[i], a);}inline ll gmax(ll *a, ll ans = 0) {  for (int i = 60; i &gt;= 0; --i) ans = max(ans, ans ^ a[i]);  return ans;}inline ll lca(int x, int y) {  static ll ans[65];  memset(ans, 0, sizeof(ans));  if(dep[x] &lt; dep[y]) swap(x, y);  for (int i = 20; i &gt;= 0; --i)    if(dep[fa[x][i]] &gt;= dep[y])      merge(ans, f[x][i]), x = fa[x][i];  if(x == y) return merge(ans, f[x][0]), gmax(ans);  for (int i = 20; i &gt;= 0; --i)    if(fa[x][i] != fa[y][i]) {      merge(ans, f[x][i]), merge(ans, f[y][i]);      x = fa[x][i], y = fa[y][i];    }  merge(ans, f[x][0]), merge(ans, f[y][0]), merge(ans, f[fa[x][0]][0]);  return gmax(ans);}inline void solve() {  memset(head, -1, sizeof(head));  n = read(), q = read();  for (int i = 1; i &lt;= n; ++i) insert(g[i] = read(), f[i][0]);  for (int i = 1, x, y; i &lt; n; ++i) {    x = read(), y = read();    addedge(x, y);    addedge(y, x);  }  dfs(1);  for (int t = 1; t &lt;= 20; ++t)    for (int i = 1; i &lt;= n; ++i)      fa[i][t] = fa[fa[i][t - 1]][t - 1],      memcpy(f[i][t], f[i][t - 1], sizeof(f[i][t])),      merge(f[i][t], f[fa[i][t - 1]][t - 1]);  for (int i = 1, x, y; i &lt;= q; ++i) {    x = read(), y = read();    printf(&quot;%lld\n&quot;, lca(x, y));  }}}int main() {  return BZOJ4568::solve(), 0;}</code></pre><h4 id="BZOJ2844"><a href="#BZOJ2844" class="headerlink" title="BZOJ2844"></a>BZOJ2844</h4><p>给出集合$S$，将集合$S$的所有子集取出来，对于每一个子集求出其异或和，排序，放到数组$a$中，给出数$k$，求$a$在$a$中第一次出现的下标是？</p><p>对于线性基的组合出来的集合$S_1$，我们把这个$S_1$分成两部分，第一部分是线性基，第二部分是由线性基组合出来的数字。假如$|S_1| = 2^n$，并且线性基有$m$个。对于查询的某一个数$j$，这个数一定可以由后面的$2^{n - m}$种组合再加上唯一的线性基的补全方案来组合。所以对于某一个数$j$，组合方案数和$j$是多少其实是无关的，所以只需要我们知道$j$在线性基的组合中排第几位。</p><p>重复一次，子问题就是求$j$是在线性基的所有子集的组合中的第几大。解决方式如下，对于$j$的每一位，假如说当前这一位$i$拥有一个$a[i] != 0$，那么我们可以称这一位是“流动”的。假如说不存在，那么一定选取了一个比它大的线性基。要理解这里还要明确“排序”的意义，假如说我选取了基$a_8$，那么对于第$8$位一定是选取了的。所以对于第$8$位的排序，一定是与流动的二进制位有关，这么看来，在集合$S_1$中的位置也只是由流动的二进制位决定的，对于数字$j$，我们抽离出所有的流动的二进制位，抽离的二进制位表示对应的$a$中的基的选取情况。因为选取更大的基，数字也就更大，所以二进制位的数值就是在$S_1$中的位置，最后套上$2^{n - m}$处理即可。</p><h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h4><p>给出$n$个数，把这些数分成两部分，使得这两部分的异或和差最小。$n \leq $</p><h3 id="数论函数补充"><a href="#数论函数补充" class="headerlink" title="数论函数补充"></a>数论函数补充</h3><p>以下公式都基于唯一分解定理。假设我们已经分解了$n$。<br>除了莫比乌斯函数，之前的都提到过:</p><ul><li>$\varphi(n)$，欧拉函数，$[1, n]$中和$n$互质的数的个数。</li><li>$\sigma(n)$，$n$的正约数之和$\prod_{i = 1}^{m}{\sum_{j = 0}^{c_i}{p_i^{j}}}$。</li><li>$\mathrm{d}(n)$，$n$的正约数个数。$\prod{c_i + 1}$。</li></ul><p>这几个的计算原理都很简单，就不给予证明了~。<br>然后，如题，补充的是莫比乌斯函数和莫比乌斯反演，我们直接进入下一个版块。</p><h3 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h3><h4 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h4><p>某小学学的东西，$|A \cup B \cup C| = |A| + |B| + |C| - |A \cap B| - |A \cap C| - |B \cap C| + |A \cap B \cap C|$。其实就是，首先算每个集合的大小，发现算重了旁边的，就减去，结果发现又算少了，又加上，这个思想在欧拉函数的计算上用到过。我们不如换个写法：</p><p>$$|\bigcup_{i = 1}^{n}{A_i}| = \sum_{i = 1}^{n}{|A_i|} - \sum_{1 \leq i &lt; j \leq n}{|A_i \cap A_j|} + \sum_{1 \leq i &lt; j &lt; k \leq n}{|A_i \cap A_j \cap A_k|} - \cdots - (-1)^{n - 1}|A_1 \cap A_2 \cap \cdots \cap A_n|$$</p><p>咕咕咕</p><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>定义我不详细解释了，大概来说，是这个样子的：$c_{i, j} = \sum_{k = 1}^{m}{a_{i, k} * b_{k, j}}$。</p><p>矩阵乘法的前提是行列必须对应另一个矩阵的行列。矩阵乘法满足结合律， 分配率，但是不满足交换律。注意，不满足交换律。</p><p>举个例子吧，最经典的题</p><h4 id="「ep8」求斐波那契数列的第-n-项，-n-leq-10-18-。"><a href="#「ep8」求斐波那契数列的第-n-项，-n-leq-10-18-。" class="headerlink" title="「ep8」求斐波那契数列的第$n$项，$n \leq 10^{18}$。"></a>「ep8」求斐波那契数列的第$n$项，$n \leq 10^{18}$。</h4><p>$f[i] = f[i - 1] +f[i - 2]$。所以，可以构造矩阵如下：</p><p>$$\begin{bmatrix}<br>    1 &amp; 1 \<br>    1 &amp; 0 \<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>    f[n] \<br>    f[n - 1]<br>\end{bmatrix}=<br>\begin{bmatrix}<br>    f[n + 1] \<br>    f[n]<br>\end{bmatrix}$$</p><p>我也不知道咋证，反正矩阵可以求快速幂。<br>于是</p><p>$$\begin{bmatrix}<br>    1 &amp; 1 \<br>    1 &amp; 0 \<br>\end{bmatrix}^n<br>\times<br>\begin{bmatrix}<br>    1 \<br>    1<br>\end{bmatrix}=<br>\begin{bmatrix}<br>    f[n + 1] \<br>    f[n]<br>\end{bmatrix}$$</p><h4 id="「ep9」求斐波那契数列前-n-项和，-n-leq-10-18-。"><a href="#「ep9」求斐波那契数列前-n-项和，-n-leq-10-18-。" class="headerlink" title="「ep9」求斐波那契数列前$n$项和，$n \leq 10^{18}$。"></a>「ep9」求斐波那契数列前$n$项和，$n \leq 10^{18}$。</h4><p>其实是差不多的，构造如下：</p><p>$$\begin{bmatrix}<br>    1 &amp; 1 &amp; 0 \<br>    0 &amp; 1 &amp; 1 \<br>    0 &amp; 1 &amp; 0<br>\end{bmatrix}<br>\times<br>\begin{bmatrix}<br>    S[n] \<br>    f[n + 1] \<br>    f[n]<br>\end{bmatrix}=<br>\begin{bmatrix}<br>    S[n + 1] \<br>    f[n + 2] \<br>    f[n + 1]<br>\end{bmatrix}$$</p><p>后面会有更多的题涉及矩阵，所以这个基础知识一定要搞好。<br>我们来看一个矩阵 + 概率的题。</p><h4 id="矩阵中的图论建模"><a href="#矩阵中的图论建模" class="headerlink" title="矩阵中的图论建模"></a>矩阵中的图论建模</h4><p>矩阵通常可以和图论中的邻接矩阵联系起来，看到图论的时候不妨往矩阵这里想一想。</p><h5 id="「ep10」工作-by-ihopenot"><a href="#「ep10」工作-by-ihopenot" class="headerlink" title="「ep10」工作 (by ihopenot)"></a>「ep10」工作 (by ihopenot)</h5><p>$Ambiguous$是居住在$byte$镇的量子居民，$byte$镇可以看成是$n$个点，$m$条单向边的联通图。每天清晨，$Ambiguous$都会以$P_i$的概率出现在$i$号节点，之后由于工作原因，$Ambiguous$每小时会有一定概率移动。具体而言，$Ambiguous$如果在$i$号节点并且存在一条编号为$j$的边从$i$出发，那么她就有$p_j$的概率走这条边。<br>可以保证从每个节点出发的边概率和不超过$1$，但不保证为$1$，如果$Ambiguous$没有走任何一条边，那么她就会留在当前节点。<br>今天清晨来临之前$Ambiguous$突然想知道，今天工作结束后自己在每个节点的概率是多少。<br>$n \leq 300, m \leq 100000, t \leq 10^{18}$。</p><p>这道题算是矩阵优化的基础题目，虽然原题暴力也可过，但是$t \leq 10^{18}$呢QAQ<br>矩阵这么构造，最开始的矩阵</p><p>$$\begin{bmatrix}<br>    P_1 \<br>    P_2 \<br>    P_3 \<br>    \cdots \<br>    P_n<br>\end{bmatrix}$$</p><p>每次转移的矩阵是题中构造的邻接矩阵，对于这个邻接矩阵$pow(t)$之后乘上原矩阵，这个矩阵中的每一个位置表示到达某个点的概率。因为$c_{i, j} = \sum_{i = 1}^{k}{a_{i, k} \times b_{k, j}$。所以最后的某个点的点权是 所以入边的概率之和，没问题qwq。</p><h5 id="「ep11」给出一个满足对角线均为正数的非负矩阵，判断这个矩阵是否有某一次方为全正数矩阵。-n-leq-1000-by-ihopenot"><a href="#「ep11」给出一个满足对角线均为正数的非负矩阵，判断这个矩阵是否有某一次方为全正数矩阵。-n-leq-1000-by-ihopenot" class="headerlink" title="「ep11」给出一个满足对角线均为正数的非负矩阵，判断这个矩阵是否有某一次方为全正数矩阵。$n \leq 1000$ (by ihopenot)"></a>「ep11」给出一个满足对角线均为正数的非负矩阵，判断这个矩阵是否有某一次方为全正数矩阵。$n \leq 1000$ (by ihopenot)</h5><p>首先一看，莫名其妙…考场上写的矩阵快速幂验算，想苟50，结果只苟到了20…<br>下来听到有人说“不是图论建模么”，我心里一惊，然后反应过来了。<br>哇这道题吹爆！！！<br>首先，我们把$A$矩阵看成一个邻接矩阵，可以发现，转化为01矩阵之后是没有影响的。而矩阵的某一个位置$i, j$表示$i \rightarrow j$有一条边。矩阵中所有全为正数，表示这个图全连通，而矩阵乘法之后，我们考虑乘法的意义是什么。<br>写写就知道（其实我也是感性理解），乘出来的矩阵表示$i \rightarrow j$经过$k$条边就几种方案。（？<br>如果$a[i][j] = 0$，代表$i$不能到$j$。也就是$i, j$不处于一个$SCC$。<br>$SCC!$，启发我了…不处于一个$SCC$的点，无论怎么搞都不会处于一个$SCC$，所以，对最开始的图求一个$tarjan$，看全部是否都处于同一个联通快中。</p><pre><code class="cpp">// 贼棒的图论建模// by kririae#include &lt;bits/stdc++.h&gt;using namespace std;namespace IO{inline char gc(){  static char buf[1 &lt;&lt; 18], *fs, *ft;  return (fs == ft &amp;&amp; (ft = (fs = buf) + fread(buf, 1, 1 &lt;&lt; 18, stdin)), fs == ft) ? EOF : *fs++;}inline int read(){  register int k = 0, f = 1;  register char c = gc();  for (; !isdigit(c); c = gc()) if (c == &#39;-&#39;) f = -1;  for (; isdigit(c); c = gc()) k = (k &lt;&lt; 3) + (k &lt;&lt; 1) + (c - &#39;0&#39;);  return k * f;}}namespace Life{const int maxn = 1005;int n, t, a[maxn][maxn], dfn[maxn], low[maxn], cnt, tot;stack&lt;int&gt; s;bitset&lt;maxn&gt; vis;inline void tarjan(int x){  dfn[x] = low[x] = ++cnt;  s.push(x), vis[x] = 1;  for (int i = 1; i &lt;= n; ++i)  {    if(!a[x][i]) continue;    if(!dfn[i])    {      tarjan(i);      low[x] = min(low[x], low[i]);    } else if(vis[i]) low[x] = min(low[x], dfn[i]);  }  if(low[x] == dfn[x])  {    int curr; ++tot;    do {      curr = s.top(); s.pop(); vis[curr] = 0;    } while(curr != x);  }}inline void solve(){  using namespace IO;  t = read();  while(t--)  {    memset(dfn, 0, sizeof(dfn));    memset(low, 0, sizeof(low));    memset(a, 0, sizeof(a));    while(!s.empty()) s.pop();    vis.reset(); cnt = 0; tot = 0;    n = read();    int flag = 0;    for (int i = 1; i &lt;= n; ++i)      for (int j = 1; j &lt;= n; ++j)        a[i][j] = read();    for (int i = 1; i &lt;= n; ++i)          if(!dfn[i]) tarjan(i);    if(tot == 1) puts(&quot;YES&quot;);    else puts(&quot;NO&quot;);  }}}int main(){  return Life::solve(), 0;}</code></pre><h3 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h3><h4 id="加法原理和乘法原理"><a href="#加法原理和乘法原理" class="headerlink" title="加法原理和乘法原理"></a>加法原理和乘法原理</h4><p>可以简单想想成一张图，如果图是这样的：</p><p>$1 \rightarrow 2, 1 \rightarrow 2, 1 \rightarrow 2 \cdots$</p><p>那么$1 \rightarrow 2$的路径数就是所有边的总和，这就是加法原理。</p><p>如果图是这样的</p><p>$1 \rightarrow 2, 1 \rightarrow 2, 1 \rightarrow 2 \cdots$</p><p>$2 \rightarrow 3, 2 \rightarrow 3, 2 \rightarrow 3 \cdots$</p><p>$3 \rightarrow 4, 3 \rightarrow 4, 3 \rightarrow 4 \cdots$</p><p>问$1 \rightarrow 4$的路径和，就是每个关键点的路径条数的乘积，这就是乘法原理。</p><h4 id="排列和组合"><a href="#排列和组合" class="headerlink" title="排列和组合"></a>排列和组合</h4><p>$\binom{n}{m} \Rightarrow \binom{n}{m}$。</p><p>写作$P_n^{m}$，表示从$n$个物品中取出$m$个排成一排，产生的不同的排列的数量为。$P_n^{m} = \frac{n!}{(n - m)!}$，可以这么推导：第一次选，有$n$个，第二次选，有$n - 1$个，第三次选…以此类推，最后可以选的有$n - m +1$个。</p><p>写作$\binom{n}{m}$，表示从$n$个物品中选取$m$个组成集合，产生的不同的集合的数量为。$\binom{n}{m} = \frac{n!}{m!(n - m)!}$。这么考虑，对于一个长度为$m$的序列，排列方式有$P_m^{m} = m!$。总数量除以排列数就是组合数。</p><h4 id="组合数的性质"><a href="#组合数的性质" class="headerlink" title="组合数的性质"></a>组合数的性质</h4><ul><li>$\binom{n}{m} = \binom{n}{n - m}$。$\binom{n}{m} = \frac{n!}{(n - m)!}$，$\binom{n}{n - m} = \frac{n!}{(n - m)!}$。当然，对于组合数来说，硬核证明是不好的。从$n$个钟选取$m$个，剩下的组成一个补集。补集的取值情况和原集合是一一对应的。</li><li>$\binom{n}{m} = \binom{n - 1}{m} + \binom{n - 1}{m - 1}$。硬核证明免了，谁都会带公式。我们考虑第$n$号元素选和不选，如果选了，剩下的情况是$\binom{n - 1}{m - 1}$，如果不选，剩下的情况是$\binom{n}{m - 1}$。</li><li>$\sum_{i = 0}{n}{\binom{n}{i}} = 2^n$。硬核证明也免了，谁都会带公式。公式等同于对$n$个数中选取任意多个数，也就是每个数有取或者不取，也就是$2^n$种情况。</li></ul><p>额…之后统一写法…</p><h4 id="组合数的求解"><a href="#组合数的求解" class="headerlink" title="组合数的求解"></a>组合数的求解</h4><ul><li>利用递推式求解，性质2。复杂度$O(n^2)$。</li><li>利用定义求解，复杂度$O(n\log{n})$。其实可以用逆元递推到$O(n)$。<pre><code class="cpp">#define ll long long#include &lt;bits/stdc++.h&gt;</code></pre></li></ul><p>using namespace std;</p><p>const int maxn = 10005;<br>const int mod = 1e9 + 7;</p><p>int fac[maxn];<br>template<typename t><br>inline void exgcd(T &amp;x, T &amp;y, T a, T b)<br>{<br>  if(b) exgcd(y, x, b, a % b), y -= (a / b) * x;<br>  else x = 1, y = 0;<br>}<br>template<typename t><br>inline T inv(T a, T x = 0, T y = 0)<br>{<br>  // ax \equiv 1 \pmod {p} -&gt; ax = pk + 1 -&gt; ax - pk = 1<br>  exgcd(x, y, a, mod);<br>  return (x % mod + mod) % mod;<br>}</typename></typename></p><p>inline void init()<br>{<br>    fac[0] = 1;<br>    for (int i = 1; i &lt; maxn; ++i)<br>        fac[i] = (1ll * fac[i - 1] * i) % mod;<br>}</p><p>inline ll C(int n, int m)<br>{<br>  return ((((1ll * inv(fac[m]) * fac[n]) % mod) * inv(fac[n - m])) % mod);<br>}</p><p>int main()<br>{<br>    init();<br>    // code…<br>}</p><pre><code>#### 二项式定理$$(a + b)^n = \sum_{k = 0}^{n}{\binom{n}{k}a^kb^{n - k}}$$证明我不会。#### $Lucas$定理若$p$是质数，则有$\binom{n}{m} \equiv \binom{n \ mod \ p}{m \ mod \ p} \cdot \binom{\frac{n}{p}}{\frac{m}{p}}$。证明我也不会，貌似需要生成函数。##### 给定$n, g$，求$g^{\sum_{d | n}{\binom{n}{d}}} \mod{99911659}$。因为$99911659$是质数，$ex$欧拉定理可知，费马小定理也行，$a^b \equiv a^{b \mod{\varphi(n)}} \mod{n}$，所以$g^{\sum_{d | n}{\binom{n}{d}}} \mod{99911659} = g^{\sum_{d | n}{\binom{n}{d}} \mod{99911658}} \mod{99911659}$。目前的问题就是快速求$\sum_{d | n}{\binom{n}{d}} \mod{99911658}$。$n \leq 10^9$，所以$n$的约数个数不超过$2\sqrt{n}$。也就是说跑的过。那么问题来了，$Lucas$定理的适用范围仅仅是质数，怎么办怎么办（捧读）。分解$9911658 = 2 \cdot 3 \cdot 4679 \cdot 35617$。对于几个分解后的质数，我们带入中国剩余定理，求出正确的$\binom{n}{d} \mod{9911658}$。代码如下~```cpp#define ll long long#include &lt;bits/stdc++.h&gt;using namespace std;namespace BZOJ1951{const int mod = 999911658;const int prm[4] = {2, 3, 4679, 35617};inline ll fpow(ll a, ll p, ll mod){  ll ans = 1;  for (; p; p &gt;&gt;= 1) {    if(p &amp; 1) ans = (a * ans) % mod;    a = (a * a) % mod;  } return ans;}int g, n, factor[40000], cnt, fact[40000], a[4];inline void init(){  for (int i = 1; i * i &lt;= n; ++i)    if(n % i == 0) {      factor[++cnt] = i;      if(i != n / i) factor[++cnt] = n / i;    }}inline int C(int n, int m, int p){  if(m &gt; n) return 0;  return fact[n] * fpow(fact[m] * fact[n - m], p - 2, p) % p;}inline int lucas(int n, int m, int p){  if(m == 0) return 1;  return C(n % p, m % p, p) * lucas(n / p, m / p, p) % p;}inline int work(int p){  memset(fact, 0, sizeof(fact));  fact[0] = 1;  for (int i = 1; i &lt;= p; ++i)    fact[i] = fact[i - 1] * i % p;  ll ans = 0;  for (int i = 1; i &lt;= cnt; ++i)    ans = (ans + lucas(n, factor[i], p)) % p;  return ans;}inline int CRT(){  ll ans = 0, M = 999911658;  for (int i = 0; i &lt; 4; ++i)    ans = (ans + (a[i] * (M / prm[i]) % mod) * fpow(M / prm[i], prm[i] - 2, prm[i])) % mod;  return ans;}inline void solve(){  cin &gt;&gt; n &gt;&gt; g;  if(g == 999911659) return puts(&quot;0&quot;), void();  init();  for (int i = 0; i &lt; 4; ++i) a[i] = work(prm[i]);  printf(&quot;%lld\n&quot;, fpow(g, CRT(), 999911659));}}int main(){  return BZOJ1951::solve(), 0;}</code></pre><h4 id="Catalan-数列"><a href="#Catalan-数列" class="headerlink" title="$Catalan$数列"></a>$Catalan$数列</h4><p>定义如下：$Cat(n) = \frac{\binom{2n}{n}}{n +1}$。</p><p>有以下问题：</p><ul><li>$n$个左括号和右括号组成的合法序列的个数。</li><li>$[1, n]$形成的合法出栈序列的个数。</li><li>在平面直角坐标系上，不越过$x - y = 0$一条直线，每次只能向上或者向右走，的路线的条数。</li></ul><p>$Catalan$数列通常采用朴素的组合数求法，也有递推版本的。</p><h3 id="组合数学-ver2-0"><a href="#组合数学-ver2-0" class="headerlink" title="组合数学 ver2.0"></a>组合数学 ver2.0</h3><p>排列与组合。</p><p>$\frac{n!}{(n - m)!}$。$n!$是全排列的数量，$(n - m)!$是除去$m$个以外的排列顺序个数。除一下就好了。</p><p>$\frac{n!}{m!(n - m)!}$。总数除以算重的。圆上的排列问题。$\frac{n!}{(n - m)!n}$ 。</p><p>具体求法。逆元预处理，阶乘预处理。</p><p>$\binom{n}{m} = \binom{n - 1}{m} + \binom{n - 1}{m - 1}$的杨辉三角理解方式。</p><blockquote><p>HDU4135</p></blockquote><p>求$\sum_{i = 1}^{n}{[gcd(i, x) = 1]}$。$n \leq 10^9$。</p><p>对于一个固定的$x$，我们要求$i$的个数。但是我们发现，求互质没法下手，我们尝试用不互质去解决。$gcd(x, i)  != 1$的条件，$i$是$x$的某个因数。所以我们枚举$x$的所有质因数$p_i$，满足条件的$p_i \cdot k \leq n$就是$x$的个数。但是，会发现，我们算重了很多情况，于是进行容斥。进行一次$dfs$，因为$n \leq 10^9$的条件下，$p_i$的个数不超过10，对于每一个，容斥$\frac{n}{i}$，最后用$n$减去该答案。</p><blockquote><p>???</p></blockquote><p>给出$n \times m$的矩阵，$q$个询问，每次询问$(x_1, y_1) \rightarrow (x_2, y_2)$的路径个数。$n, m \leq 1000$，$q \leq 10^5$。</p><p>$dp$的解法不用说了，小学难度。</p><p>问题是让用组合数。引出隔板法，隔板法是这么一个东西：</p><p>将$k$个物品用板子分成$m$份。能够分的情况个数是：$\binom{k + m - 1}{m - 1}$。</p><p>将$k$个物品分成$m$份，需要添加$m - 1$个板子，我们可以把板子看成别的物品，总和也有就$k + m - 1$个物品，从中选出$m - 1$物品，也就有$\binom{k + m - 1}{m - 1}$种情况。</p><p>再转回原题目，首先，假如说是从$(1, 1) \rightarrow (n, m)$，我们考虑把路径分成横着的$n$份，总共要下降$m$次，也就是说，把$m$次下降分到$n$份中，也就是隔板法的经典问题，答案是$\binom{n + m - 1}{n - 1}$。（写反了，懒得改，将就看看吧。</p><blockquote><p>HDU6397</p></blockquote><p>给出$n, m, k$，从$[0, n - 1]$中选取$m$个数，使得合为$k$，问方案数，数字可重复。$n, m, k \leq 10^5$</p><p>首先考虑简化版本的问题，$k \leq n - 1$。我在$k$个$1$中放隔板，和一定为$k$，个数是$\binom{k + m - 1}{m - 1}$，那么问题来了，$k &gt; n - 1$咋办。我们将每一个数字表示为$a_1x + b$。我们将情况用$\sum{a_i}$分类，$\sum{a_i} = [1, \frac{k}{n}]$。假如说忽略$n$，我们直接用隔板法计算所得结果是$\sum{a_i} \in [1, \frac{k}{n}]$的情况数之和，因为隔板法隔出了所有的情况，这些情况等于分类后的全集。我们考虑从$k$中剔除$i$个$n$，对剩余的进行隔板法，然后放回这$i$个$n$，放回的情况个数是$\binom{m}{i}$。这时，我们的计算结果是忽略掉了$\sum{a_j} \leq i$的，利用这个性质进行容斥即可得答案。</p><h3 id="生成函数"><a href="#生成函数" class="headerlink" title="生成函数"></a>生成函数</h3><p>首先吧，定义如下：</p><p>对于序列$a_0, a_1, a_2, a_3, a_4 \cdots a_n$，$g(x) = \sum_{i = 0}^{n}{a_ix^i}$，称$g(x)$是序列的生成函数。</p><p>你有$1, 3, 5$面额的硬币，每种数量无限，总共用$k$个，能够组合出多少种面额。</p><p>考虑多项式的乘法，用$x^1$表示用$1$元的硬币，用$x^3$表示用$3$元的，以此类推。<br>$$<br>(x^1 + x^3 + x^5)^k<br>$$<br>用幂表示面额数，最后求有多少种幂，在这里忽略系数就是多项式的用处。</p><blockquote><p> HDU1028</p></blockquote><p>求出和为$n$的数的组合的个数，$n \leq 120$</p><p>$(1 + x + x^2 + x^3 + \cdots) \cdot (1 + x^2 + x^4 + \cdots) \cdots$.最后统计$x^n$的系数。</p><blockquote><p> POJ 1942 1850 1019 HDU 1028 1398 1085 2082 1709 2065</p></blockquote><h3 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h3><p>因为明天要考期望，紧急添加…</p><p>妈耶我期望不要爆零。</p><p>对于样本空间$A$，随机事件$a$发生的概率是$P(a)$，$P(\sum{a}) = 1$，$P(a) \in [0, 1]$。对于互斥事件$a_i, a_j$，$P(a_i) +P(a_j) = P(a_i \cup a_j)$。</p><p>对于$X$的取值$x_i, x_j \cdots$，取到某一个值的概率是$p_i$，则取到这个值得数学期望是$E(x_ip_i)$d，对于随机变量$X$的期望是$\sum{x_ip_i}$。假如说掷骰子吧，取值有$[1, 6]$，而掷到每一个数值的概率是$\frac{1}{6}$，则掷一个骰子的值的数学期望是$\frac{1}{6} \cdot 1 + \frac{1}{6} \cdot 2 + \cdots + \frac{1}{6} \cdot 6 = \frac{21}{6}$。</p><p>光说不练假把式。</p><h4 id="「ep8」某个星球有-n-天，抽取-k-个人，问至少两个人生日在同一天的概率是。-1-leq-k-leq-n-leq-10-6-。"><a href="#「ep8」某个星球有-n-天，抽取-k-个人，问至少两个人生日在同一天的概率是。-1-leq-k-leq-n-leq-10-6-。" class="headerlink" title="「ep8」某个星球有$n$天，抽取$k$个人，问至少两个人生日在同一天的概率是。$1 \leq k \leq n \leq 10^{6}$。"></a>「ep8」某个星球有$n$天，抽取$k$个人，问至少两个人生日在同一天的概率是。$1 \leq k \leq n \leq 10^{6}$。</h4><p>这种，一般都要转换问题，转换为“所有人生日都不同”的问题。第一天，某个人可以选择$\frac{n}{n}$天，第二个人可以选择的是$\frac{n - 1}{n}$，第$k$个人可以选择的是$\frac{n - k + 1}{n}$，所以答案就是$\prod_{i = 0}^{k - 1}{\frac{n - i}{n}}$。可以线性计算。</p><h4 id="「ep9」毛玉问题，有-K-只毛玉，每只生存一天就会死亡，每只毛玉在死之前有可能生下一些毛玉，生-i-个毛玉的概率是-pi-，问-m-天后所有的毛玉都死亡的概率是多少？-所有数据-leq-1000-。（-UVA11021"><a href="#「ep9」毛玉问题，有-K-只毛玉，每只生存一天就会死亡，每只毛玉在死之前有可能生下一些毛玉，生-i-个毛玉的概率是-pi-，问-m-天后所有的毛玉都死亡的概率是多少？-所有数据-leq-1000-。（-UVA11021" class="headerlink" title="「ep9」毛玉问题，有$K$只毛玉，每只生存一天就会死亡，每只毛玉在死之前有可能生下一些毛玉，生$i$个毛玉的概率是$pi$，问$m$天后所有的毛玉都死亡的概率是多少？ 所有数据$\leq 1000$。（$UVA11021$"></a>「ep9」毛玉问题，有$K$只毛玉，每只生存一天就会死亡，每只毛玉在死之前有可能生下一些毛玉，生$i$个毛玉的概率是$pi$，问$m$天后所有的毛玉都死亡的概率是多少？ 所有数据$\leq 1000$。（$UVA11021$</h4><p>代码如下…解释的话…会很复杂。好吧…我承认这道题搞了我俩天。<br>设$f[i]$表示，对于一直毛玉，其子孙后代在$i$天“内”死亡的概率是。假设这一天死了这一只小毛玉死了，概率是$p_0$，如果生下一只的话，生下的小毛玉已经被限制了生命，在$i - 1$天内死的概率是$f[i - 1]$，其中$i - 1$的意思是它的寿命是$i - 1$。对于生下的所有小毛玉，可以独立考虑，则全部死光的概率需要$f[m]^k$。这道题的关键是搞清楚，$f[i]$到底是啥意思QAQ就是这玩意儿害了我俩天。</p><pre><code class="cpp">// by kririae#define R register#include &lt;bits/stdc++.h&gt;using namespace std;const int maxn = 1005;int t, n, k, m;double p[maxn], f[maxn];inline double fpow(R double a, R int p){  double ans = 1;  for (; p; p &gt;&gt;= 1)  {    if(p &amp; 1) ans = a * ans;    a = a * a;  }  return ans;}int main(){  scanf(&quot;%d&quot;, &amp;t);  for (int qwq = 1; qwq &lt;= t; ++qwq)  {    memset(f, 0, sizeof(f));    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;m);    for (int i = 0; i &lt; n; ++i) scanf(&quot;%lf&quot;, &amp;p[i]);    f[1] = p[0];    for (R int i = 2; i &lt;= m; ++i)      for (R int j = 0; j &lt; n; ++j)        f[i] += p[j] * fpow(f[i - 1], j);    printf(&quot;Case #%d: %.7lf\n&quot;, qwq, fpow(f[m], k));  }}</code></pre><h4 id="「ep10」咕咕咕"><a href="#「ep10」咕咕咕" class="headerlink" title="「ep10」咕咕咕"></a>「ep10」咕咕咕</h4><h4 id="「ep11」咕咕咕"><a href="#「ep11」咕咕咕" class="headerlink" title="「ep11」咕咕咕"></a>「ep11」咕咕咕</h4><h4 id="「ep12」咕咕咕"><a href="#「ep12」咕咕咕" class="headerlink" title="「ep12」咕咕咕"></a>「ep12」咕咕咕</h4><h4 id="「ep13」咕咕咕"><a href="#「ep13」咕咕咕" class="headerlink" title="「ep13」咕咕咕"></a>「ep13」咕咕咕</h4><h4 id="「ep14」Va-11-Hall-a-by-ihopenot"><a href="#「ep14」Va-11-Hall-a-by-ihopenot" class="headerlink" title="「ep14」Va-11 Hall-a (by ihopenot)"></a>「ep14」Va-11 Hall-a (by ihopenot)</h4><h5 id="「题目描述」"><a href="#「题目描述」" class="headerlink" title="「题目描述」"></a>「题目描述」</h5><p>$Jill$是在$Vallhalla$工作的调酒师。为客人送上美味的饮料是她的工作内容。但$Jill$是个有创造力和上进心的女孩，她并不满足于仅为客人调制菜单上的饮料，她想自己去创造属于自己的饮料。虽说如此，她并不知道怎么去创造一种受客人欢迎的饮料，于是她想出了一个绝妙的办法。$Jill$将$n$瓶酒摆成一列，每瓶酒初始评价值都为$1$，然后有$m$次操作。每次操作$Jill$会在$[l,r]$内的酒中随机选择任意瓶每瓶加入一个评价值随机（不一定相同）的配料，并重复这个操作$k_i$次。由于原料和配料会发生剧烈的化学反应，所以混合之后评价值并不是相加 那么简单。据$Jill$观察，一瓶评价值为$a$酒在加入评价值为整数$b(0 \leq b &lt; c)$，的配料后评价值会变为$a\cdot b \ mod \ c$。现在$Jill$想知道她最终调制出的酒的评价值的和期望是多少。</p><p><strong>一句话题意</strong>：给你一个初始全为$1$的长度为$n$的序列，$m$次操作，每次操作重复$ki$次，对于$[l,r]$间的随机一些数$a$，再对每个数选择一个随机整数$b(0 \leq b &lt; c)$，将这些数变成$a\cdot b \ mod \ c$。问最终所有数的和期望是多少。 为了方便保证精度，你需要输出答案对$10^9+7$取模后的结果。 提示：如果答案是$\frac{a}{b}$的形式，那么你需要输出$a \cdot b^{-1} \ mod \ (10^9 + 7)$的结果。由于费马小定理，你只需输出$a \cdot b^{10^9 + 5} \ mod \ (10^9 + 7)$就可以了。</p><h5 id="「输入格式」"><a href="#「输入格式」" class="headerlink" title="「输入格式」"></a>「输入格式」</h5><p>第一行三个正整数$n, m, c$接下来每行三个数$l_i, r_i, k_i$表示操作的区间和重复次数。</p><h5 id="「输出格式」"><a href="#「输出格式」" class="headerlink" title="「输出格式」"></a>「输出格式」</h5><p> 一行一个整数表示答案对$10^9+7$取模后的整数。</p><h5 id="「样例输入」"><a href="#「样例输入」" class="headerlink" title="「样例输入」"></a>「样例输入」</h5><p><code>3 1 3 1 2 1</code></p><h5 id="「样例输出」"><a href="#「样例输出」" class="headerlink" title="「样例输出」"></a>「样例输出」</h5><p><code>500000007</code></p><h5 id="「数据规模及约定」"><a href="#「数据规模及约定」" class="headerlink" title="「数据规模及约定」"></a>「数据规模及约定」</h5><p>对于$30%$的数据$n=10, m \leq 10, k_i \leq 10, c \leq 5$<br>对于$100%$的数据$n \leq 100, m \leq 1e6, k_i \leq 100, c \leq 50$</p><h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><p>由于期望的可加性，我们可以这么处理这道题。对于每个数，我们求出它最后为某一个数的期望，然后求和。因为它最后的值一定属于$[0, c)$。所以我们建立矩阵：<br>$$<br>\begin{bmatrix}<br>    p_0 \<br>    p_1 \<br>    p_2 \<br>    \cdots \<br>    p_{c - 1} \<br>\end{bmatrix}<br>$$<br>$p_i$表示最后值为$i$的概率是。当然，现在的矩阵是初始的，我们考虑如何对这个矩阵进行转移。即转移到某一次操作后，某一个数变换成某一个数的概率是。转移矩阵的第$i$行第$j$列定义为，数值$i$变换到数值$j$的概率是。特别的，这个矩阵有第$0$行第$0$列。对于一次$[L, R]$的操作，选取到某个数的概率是$\frac{1}{2}$。而选取到这个数之后，进行的操作可能是乘上$[0, c)$中的任意一个数，乘这个数的概率就是$\frac{1}{c \cdot 2}$。所以我们在某个数$x$乘上$[0, c)$后的数$y$，$x \rightarrow y$之间的边加上概率$\frac{1}{c \cdot 2}$。</p><p>对于这道题的矩阵乘法，我们这么考虑：$a_{1, 2}$的意思是经过一次操作后，$1$变到$2$的概率，则在乘上原矩阵第二列之后，最后的变为$2$的概率自然加上了某个值，这个值是$1$变为$2$的概率。</p><p>按照套路，这个时候该进行矩阵快速幂了。但是，如果直接进行矩阵快速幂的话…我们看看复杂度：$O(nc^3log{km})$，$2.5 \cdot 10^8$有点玄乎啊。这个时候，考虑优化矩阵乘法。我们$n \times n$的矩阵乘法的复杂度是$O(n^3)$，如果是$n \times n$和$n \times 1$的矩阵乘法，不就是$O(n^2)$了。我们预处理出转移矩阵的$2^k$次方，复杂度是$O(n^3log{k})$，可以接受，然后，用预处理出的信息和$n \times 1$的矩阵一一结合，得出的就是最后的矩阵，然后对所有求和，得出期望。</p><p>$std$代码如下</p><pre><code class="cpp">#include&lt;bits/stdc++.h&gt;using namespace std;#define MOD 1000000007#define LL long longint n,m,c,ans;int num[105];struct Matrix{    int x[55][55];    Matrix operator * (const Matrix &amp;b) const {        Matrix ret;        memset(ret.x,0,sizeof(ret.x));        for(int i=0;i&lt;c;i++)            for(int j=0;j&lt;c;j++)                for(int k=0;k&lt;c;k++)                    ret.x[i][k]=(ret.x[i][k]+(LL) x[i][j]*b.x[j][k])%MOD;        return ret;    }}pw[35],st;int now[55],t[55];void Merge(int k) {    memset(t,0,sizeof(t));    for(int i=0;i&lt;c;i++)        for(int j=0;j&lt;c;j++)            t[i]=(t[i]+(LL) now[j]*pw[k].x[i][j])%MOD;    for(int i=0;i&lt;c;i++) now[i]=t[i];}int fpow(int a,int b) {    LL t=a,ret=1;    while(b) {        if(b&amp;1) ret=ret*t%MOD;        b&gt;&gt;=1;t=t*t%MOD;    }    return ret;}int main() {    freopen(&quot;bar.in&quot;,&quot;r&quot;,stdin);    freopen(&quot;bar.out&quot;,&quot;w&quot;,stdout);    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;c);    for(int l,r,k,i=1;i&lt;=m;i++) {        scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k);        num[r+1]-=k;num[l]+=k;    }    for(int i=1;i&lt;=n;i++) num[i]+=num[i-1];    LL rev_2=fpow(2,MOD-2),rev_c=fpow(c,MOD-2);    for(int to,i=0;i&lt;c;i++) {        for(int j=0;j&lt;c;j++) {            to=i*j%c;            st.x[i][to]=(st.x[i][to]+rev_2*rev_c)%MOD;        }        st.x[i][i]=(st.x[i][i]+rev_2)%MOD;    }    pw[0]=st;    for(int i=1;i&lt;=30;i++) pw[i]=pw[i-1]*pw[i-1];    for(int i=1;i&lt;=n;i++) {        memset(now,0,sizeof(now));        now[1]=1;        for(int j=0;j&lt;=30;j++) if(num[i]&gt;&gt;j&amp;1) Merge(j);        for(int j=0;j&lt;c;j++)            ans=(ans+(LL)now[j]*j)%MOD;    }    printf(&quot;%d\n&quot;,ans);    return 0;}</code></pre><p>概率$dp$</p><p>$$P(B) = \sum{P(A)P(B | A)}$$</p><p>$B$事件是及格，$A$事件是$100$分以上，所以说$B$事件发生的概率是$A$发生的概率乘$A$发生的前提下$B$发生的概率。</p><p>$P(B | A) = \frac{P(A, B)}{P(A)}$。$A, B$不是独立事件，所以不能直接相乘。可以这么$A$发生的前提下$B$发生的概率。</p><p>期望$dp$</p><p>$E(A) = \sum{P(a_i) \times a_i} = \sum{E(a_i)}$;</p><p>经常会出现$a_i$的值一定的时候，也就是贡献一定的时候，有时会转化为求$P(a_i)$，$a_i$不同的时候，就需要单独计算了。</p><h4 id="HDU3853"><a href="#HDU3853" class="headerlink" title="HDU3853"></a>HDU3853</h4><h4 id="POJ2151"><a href="#POJ2151" class="headerlink" title="POJ2151"></a>POJ2151</h4><p>$f[i][j][k]$，选到第$i$个队伍，从前$j$个中选$k$个，所有合法情况的概率之和为$f[i][j][k]$。</p><p>所有队伍至少做出一个的概率就是$1 - f[n][m][0]$。所有队伍都做出$n$以下的概率是$f[i][m][n]$的前缀和。</p><h4 id="POJ3071"><a href="#POJ3071" class="headerlink" title="POJ3071"></a>POJ3071</h4><p>二进制性质优化概率dp</p><p>对于所有点建树，树状数组式建树，对于$i$层，编号从$0$开始，可以发现性质，当前<code>&gt;&gt; 1</code>之后是起父亲节点，当前<code>&gt;&gt; 1 xor 1</code>是其父亲节点的右节点。然后进行普通的转移。对于第$i$层，先把某个值右移$i - 1$层，然后异或$1$，相等，能打。什么骚操作。。。</p><h4 id="CF148D"><a href="#CF148D" class="headerlink" title="CF148D"></a>CF148D</h4><p>$f[i][j]$表示剩余$i$只白鼠，$j$只黑鼠，$A$先手，胜利的概率。</p><p>$f[i][0] = 1$，因为$A$先手，如果没有黑鼠就赢了。</p><p>$f[0][i] = 0$，没有白鼠$B$胜利。</p><p>在这一场胜利有三种情况，这一次抓到白鼠，上一次$B$抓到黑鼠，跑出来只白鼠、这一次抓到白鼠，上一次$B$抓到黑鼠，跑出来只黑鼠。输出$f[w][b]$。</p><h4 id="POJ3744"><a href="#POJ3744" class="headerlink" title="POJ3744"></a>POJ3744</h4><p>  先考虑数值范围很小的情况，$a_i \leq 1000$，假如说$i$位置有雷，到达$i - 1$位置的概率乘以转移两步的概率就是到达$i + 1$位置的概率，然后跳过$i$位置的计算，中间分开的部分用矩阵快速幂优化一下。</p><h4 id="BZOJ4318"><a href="#BZOJ4318" class="headerlink" title="BZOJ4318"></a>BZOJ4318</h4><p>$f[i][j]$表示到了$i$位置，连续$1$的长度为$j$，的期望分数。$i + 1$，$p_i$的概率是$1$，$1 - p_i$的概率是0.$f[i + 1][j + 1]$的概率是$p_i$，转移到$f[i + 1][0]$的概率是$1 - p_i$。第二种的权值是$0$，前者的权值是$(j + 1)^3$。不过。。。我貌似搞忘看数据范围了，$n \leq 10^6$。</p><p>所以说，$f[i]$表示到$i$位置的期望分数，$g[i]$表示到$i$的期望长度。</p><p>TODO</p><h4 id="HDU4405"><a href="#HDU4405" class="headerlink" title="HDU4405"></a>HDU4405</h4><p>本题目的大体意思是有n个格子，掷色子的掷出的数目就是你一次到移动格数。其中有m个飞行通道可以让你直接从第xi格飞到第yi格。问你走到终点的期望是多少。</p><h4 id="HDU4336"><a href="#HDU4336" class="headerlink" title="HDU4336"></a>HDU4336</h4><p>有N种卡片，每一袋零食里面最多有一张卡片，给出一袋零食里面每种卡片的概率，问平均要买多少袋零食能收集到所有的卡片。</p><h4 id="BZOJ3143"><a href="#BZOJ3143" class="headerlink" title="BZOJ3143"></a><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=3143" target="_blank" rel="noopener">BZOJ3143</a></h4><p>首先求出每个点到达的期望次数，$x_i​$，$x_i = \sum{x_j \cdot \frac{1}{d[j]}$。列出系数矩阵，$x_n = 0$。高斯消元解出每个点到达的期望次数。然后每条边到达的期望次数是$w_k = x_i \cdot \frac{1}{d[i]} + x_j \cdot \frac{1}{d[j]}$。对期望次数从大到小排序，然后依次分配权值。</p><h3 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h3><p>非线性的函数 $\rightarrow$ 函数多项式。</p><p>$f(x) = f(x_0) + f^{‘}(x_0)(x - x_0) + frac{f^{‘’}(x_0)(x - x_0)^2}{2!} \cdots$。</p><h3 id="指数型母函数"><a href="#指数型母函数" class="headerlink" title="指数型母函数"></a>指数型母函数</h3><p>假如说有$8$个元素，数值可重复。从中取出$k$个元素，求排列数。</p><p>$1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} \cdots$。进行排列计数。$\frac{x^i}{i!}$表示某物品选取了$i$次，排列个数。</p><p>除以阶乘的原因是排除自身重复排列的影响。</p><h4 id="POJ3734"><a href="#POJ3734" class="headerlink" title="POJ3734"></a><a href="http://poj.org/problem?id=3734" target="_blank" rel="noopener">POJ3734</a></h4><p>$e^x$通过在$0$处的泰勒展开，其实就是指数型母函数的标准形式。</p><p>$e^{-x}$在$0$处泰勒展开，和指数型母函数进行加法或减法运算，可以得出奇数项，偶数项的和。备注：$f^{n \cdot ‘}(x) = (-1)^n \cdot e^-x$。</p><h3 id="SG函数-Sprague-Grundy"><a href="#SG函数-Sprague-Grundy" class="headerlink" title="SG函数 $Sprague - Grundy$"></a>SG函数 $Sprague - Grundy$</h3><p>在DAG上进行。</p><p>先手必败态。非先手必败，都是先手必胜！</p><p>假设是$NIM$游戏，对于每一堆有$a_i$个物品，则当前堆的$SG(i) = a_i$。结论:对于任意一个$SG$异或值为0的状态，通过一步只能变为$SG$异或值非零。对于任意一个$SG$异或和非零的状态，一定能一步转移到$SG$异或和为0的状态。</p><p>阶梯上的博弈问题。给出$n$级阶梯，每次可以把上级阶梯的石子移到下一层。最后当石子全在1时无法移动。$A$先手，问谁胜利。$n \leq 10^6$。加入说$A$将一堆石子从奇数层移到了偶数层，我们可以再进行一次移动使得局面不变，依然$A$先手。假如说我们将偶数层移动到奇数层，就等同于把一堆石子拿走了，因为奇数层的都可以xjb处理。对于所有偶数层的进行$NIM$，得出答案。</p><h4 id="LUOGU2575"><a href="#LUOGU2575" class="headerlink" title="LUOGU2575"></a>LUOGU2575</h4><p>首先考虑暴力求解，状压枚举，不说了。</p><p>问题在于这道题tmd居然还有阶梯博弈的抽象。。。</p><p>我们知道，我们每次移走一个棋子的时候，空格的个数是不会改变的，我们把每个0看成一个阶梯的分界线，假如说把$i \rightarrow j$，$j$的0没了，$i$多出一个$0$，也就是阶梯的分界线变为了$i$，也就是说，把$i$分界线对应阶梯的一部分棋子放到$j$对应阶梯上了。对于每一行，抽出偶数位置，进行$NIM$，作为当前行的$SG$，然后对于每一行$SG$，可以解决问题。</p><h1 id="骚操作补充"><a href="#骚操作补充" class="headerlink" title="骚操作补充"></a>骚操作补充</h1><h2 id="十进制快速幂"><a href="#十进制快速幂" class="headerlink" title="十进制快速幂"></a>十进制快速幂</h2><p>首先，快速幂要求一下东东$a^b \ mod \ p$。但是，直接跑太慢啦，于是我们队$b$进行了二进制的拆分，拆分成了$2^0 + 2^j \cdots$，于是变成了$a^{2^0 + …}$，化为$a^{2^{0}} \cdot a^{2^{j}} \cdots$。注意到只有$\log{n}$项，所以复杂度是$O(\log{n})$。但是，细心的人就会发现，关于$b$，还有一个拆分方法。$while(b)\ a[++curr] = b % 10, b /= 10;$。这样，拆分成了$b = \sum_{i = 1}^{n}{c_i \cdot 10^{i - 1}}$。$a^b = a^{c_i \cdot 10^{i - 1}} \cdots$。因为带上了$c_i$，实现上还会有一些小问题，这些一会儿解决~这样，我们就可以写出十进制的快速幂！更快！更重要的是，可以部分代替高精度，不信请看。</p><h3 id="求-a-b-mod-p-，-b-leq-10-10000-。"><a href="#求-a-b-mod-p-，-b-leq-10-10000-。" class="headerlink" title="求$a^b \ mod \ p$，$b \leq 10^{10000}$。"></a>求$a^b \ mod \ p$，$b \leq 10^{10000}$。</h3><p>大概，只能用数组来存了，不过无所谓。看代码：</p><pre><code class="cpp">const int N = 10005;char b[N];inline ll fpow2(ll a, ll p, ll mod){  ll ans = 1;  for (; p; p &gt;&gt;= 1) {    if(p &amp; 1) (ans *= a) %= mod;    (a *= a) %= mod;  } return ans;}inline ll fpow10(ll a, char p[], ll mod){  ll ans = 1;  int l = strlen(p + 1);  for (int i = l; i &gt;= 1; --i) {    (ans *= fpow2(a, p[i] - &#39;0&#39;, mod)) %= mod;    a = fpow2(a, 10, mod);  } return ans;}</code></pre><h1 id="一些题目备选"><a href="#一些题目备选" class="headerlink" title="一些题目备选"></a>一些题目备选</h1><p>概率：BZOJ2318，BZOJ4720，BZOJ2720，BZOJ3720，收集邮票</p><p>各种：NOI2010能量采集</p><p>在 daily blog 里加上一篇数论笔记也能体现我真的不是文科生吧</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Atcoder 爽题集合</title>
      <link href="2018/06/22/atc_problems/"/>
      <url>2018/06/22/atc_problems/</url>
      
        <content type="html"><![CDATA[<h1 id="Atcoder爽题集合"><a href="#Atcoder爽题集合" class="headerlink" title="Atcoder爽题集合"></a>Atcoder爽题集合</h1><a id="more"></a><p>口胡和完整代码<br>对于$[1 .. n]$的排列$A$，每次可以选择一个数放到开头，最后使得数列有序，求最少操作次数。 简单dp</p><p>错了错了！！！题目记错了<br><a href="https://www.51nod.com/Question/Index.html#questionId=1060&amp;isAsc=false" target="_blank" rel="noopener">https://www.51nod.com/Question/Index.html#questionId=1060&amp;isAsc=false</a><br>这是当时写的题解：<br>虽然是简单dp，但是分析过程并不是很简单<br>首先思考，如何成本最小化<br>当前已经排好序的就不用动了，只动没有排好序的，这样成本最小化了<br>什么是排序好的呢？连续的一段+1的<br>然后我们把两段排好的组合起来，能够组合的情况，只有右段的最小值 = 左的最大值 + 1<br>于是我们就把问题转化成了<br>求一段，最长，连续上升，的子序列。<br>这个问题递推就好，注意是按照“数”来进行递推<br>这是 atcoder 的版本：<a href="https://atcoder.jp/contests/agc024/tasks/agc024_b" target="_blank" rel="noopener">https://atcoder.jp/contests/agc024/tasks/agc024_b</a></p><pre><code class="cpp">scanf(&quot;%d&quot;, &amp;n);for (R int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]);for (R int i = 1; i &lt;= n; ++i)    f[a[i]] = f[a[i] - 1] + 1, ans = max(ans, f[a[i]]);printf(&quot;%d&quot;, n - ans);</code></pre><p>对于数列$A$，$B$，每一次可以选择$A$中任意多个数，然后选择一个数$k$，使得每个选择的数$a_i$ 变成$a_i\mod k$。然后代价是$2^k$，最后使得$A$和$B$相同，求代价最小值。 贪心 + 状压dp</p><pre><code class="cpp">scanf(&quot;%d&quot;, &amp;n);for (int j = 0; j &lt;= 50; ++j){  f[j] = 0, f[j] |= (1ll &lt;&lt; j);  for (int k = 1; k &lt;= j; ++k)    if(((1ll &lt;&lt; 51) - 1) &amp; (1ll &lt;&lt; k)) f[j] |= f[j % k];}for (R int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]);for (R int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;b[i]);int flag = 1;for (R int j = 1; j &lt;= n; ++j)  if((f[a[j]] &amp; (1ll &lt;&lt; b[j])) == 0) flag = 0;if(flag == 0) return printf(&quot;%lld\n&quot;, -1ll), void();for (int i = 50; i; --i){  for (int j = 0; j &lt;= 50; ++j)  {    f[j] = 0, f[j] |= (1ll &lt;&lt; j);    for (int k = 1; k &lt;= j; ++k)      if((ans + (1ll &lt;&lt; i) - 1) &amp; (1ll &lt;&lt; k)) f[j] |= f[j % k];  }  int flag = 1;  for (R int j = 1; j &lt;= n; ++j)    if((f[a[j]] &amp; (1ll &lt;&lt; b[j])) == 0) flag = 0;  if(!flag) ans += (1ll &lt;&lt; i);}printf(&quot;%lld\n&quot;, ans);</code></pre><p>对于初始为0的数列$A$，每次可以选择一个$a_i$变成$a_{i - 1} + 1$。最后使得$A$变成$B$，求最少操作次数。  蜜汁性质</p><pre><code class="cpp">scanf(&quot;%d&quot;, &amp;n);for (R int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]);for (R int i = 1; i &lt;= n; ++i)    if(a[i] &gt;= i) return puts(&quot;-1&quot;), 0;for (R int i = 2; i &lt;= n; ++i){    if(a[i] - a[i - 1] &gt; 1) return puts(&quot;-1&quot;), 0;    if(a[i] == a[i - 1] + 1) ++ans;    else ans += a[i];}printf(&quot;%d\n&quot;, ans);</code></pre><p>对于数列$A$的所有子集之和，进行排序，然后求出排序后的中位数</p><pre><code class="cpp">scanf(&quot;%d&quot;, &amp;n);f[0] = 1;for (R int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;val), f |= (f &lt;&lt; val), sum += val;if(n == 1) return printf(&quot;%d&quot;, sum), 0;for (R int i = (sum &gt;&gt; 1); i; --i) if(f[i]) return printf(&quot;%d&quot;, sum - i), 0;</code></pre>]]></content>
      
      
      <categories>
          
          <category> CS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Atcoder </tag>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
